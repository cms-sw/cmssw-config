-include $(TOOLS_MKDIR).mk
LIB_TYPES:=$(sort $(ALL_LIB_TYPES))
OVERRIDABLE_FLAGS:=$(strip $(sort $(TOOLS_OVERRIDABLE_FLAGS) $(foreach x,$(patsubst %_LIB,%,$(LIB_TYPES)),$x_LDFLAGS)))
ALL_COMPILER_FLAGS:=$(sort $(ALL_COMPILER_FLAGS) $(OVERRIDABLE_FLAGS))
##############################################################################
TARGETDIR:= $(subst /,_,$(THISDIR))
.DEFAULT_GOAL := all
.PHONY: FORCE_TARGET
##############################################################################
multipletools := info
wrongtool := info
comma:= ,
empty:= 
colon:= :
path_seperator := :
space:= $(epmty) $(empty)
prebuild       := 
postbuild      :=
prelibdeps     :=
prebindeps     :=
ALL_SCRAM_PROJECTS :=
ALL_SUBSYSTEMS     :=
ALL_PACKAGES       :=
ALL_PYTHON_DIRS    :=
ALL_EMPTY_PACKAGES :=
ALL_BUILDFILES     :=
ALL_PRODS          :=
SKIP_UNITTESTS     := $(patsubst skiptest_%,%,$(filter skiptest_%,$(MAKECMDGOALS)))
FAST:=
XFAST:=
UFAST:=
ONLYECHOTARGETS:=
OBJEXT:=o
MODULE_PREFIX:=lib
COMMON_WORKINGDIR := $(SCRAM_TMP)/common
WORKINGDIR := $(SCRAM_INTwork)
PRECOMPILE_FLAGS_EXTENSION  := cxxflags
PRECOMPILE_EXTENSION        := gch
YACC                        := bison
LEX                         := flex
LATEX                       := latex
DVISUFFIX                   := dvi
PSSUFFIX                    := ps
PDFSUFFIX                   := pdf
PS2PDF                      := ps2pdf
DVIPS                       := dvips
BIGLIB_OBJEXT               := obj
OLD_TIMESTAMP               := 198001010100
NON_XML_BUILDFILE           := 
UPDATE_CLASSVERSION         :=
ALL_CLASS_VERSION_RULES     :=
HOOK_PROJECT                :=
HOOK_PACKAGE                :=
HOOK_PRODUCT                :=
CLASSES_H_GENERATOR         := $(LOCALTOP)/$(SCRAM_CONFIGDIR)/genClassesH
DROP_EXTERNAL_HEADER_MMD_DEPS:= yes
NO_CAPABILITIES             := $(if $(strip $(filter yes YES Yes 1,$(root_EX_FLAGS_NO_CAPABILITIES))),yes)
IS_MIC:=$(if $(strip $(filter mic,$(subst _, ,$(SCRAM_ARCH)))),yes,no)
IS_DARWIN:=no
IS_LINUX:=yes
ifeq ($(strip $(filter-out osx%,$(SCRAM_ARCH))),)
IS_DARWIN:=yes
IS_LINUX:=no
endif
GENERATE_ROOT_PCMS:=
ifneq ($(strip $(GENREFLEX)),)
GENERATE_ROOT_PCMS:=$(if $(strip $(shell $(GENREFLEX) --help 2>&1 | grep multiDict)),yes,)
endif
ifeq ($(strip $(GENERATE_ROOT_PCMS)),yes)
LCGDICT_FILE_PREFIX = $(1)_
endif
ROOTDICT_FILE_PREFIX = $(1)_
ALL_BIGPRODS                :=
POISON_EDMPLUGIN_CACHE      :=
EDM_CHECKSUM_HELP_MSG       = Suggestion: You can run 'scram build updateclassversion' to generate $$x.generated with updated ClassVersion
CMDS_COMPILERS_MAP          := CXX:g++ CC:gcc FC:g77
ALL_CMDS                    := sh awk basename cat cd chmod cp dirname diff echo false find g77 g++ gcc grep ln ls mkdir mv perl python rm sed sort touch tr true uname uniq xargs ld wc cut git
SHELL                       := /bin/sh
BASECMD_which               := which
CMD_cd  := cd
ifdef CXX
CMD_g++ := $(CXX)
endif
ifdef CC
CMD_gcc := $(CC)
endif
ifdef FC
CMD_g77 := $(FC)
endif
LLVM_CCDB_EXT:=compile_commands.json
CODE_ANALYSIS_RULES:=NO
ifeq ($(strip $(SCRAM_GENERATE_LLVM_CCDB)),YES)
CODE_ANALYSIS_RULES:=YES
OBJEXT:=$(OBJEXT).$(LLVM_CCDB_EXT)
endif
ifeq ($(strip $(SCRAM_MULTIPLE_COMPILERS)-$(SCRAM_COMPILER)-$(RUN_LLVM_ANALYZER_ON_ALL)),yes-$(LLVM_ANALYZER)-no)  #If not llvm-analyzer else requested to run llvm-alayzer for gen code too
CODE_ANALYSIS_RULES:=YES
endif
###################################
SetLocalCMDs    = $(if $($1),$(eval CMD_$2:=$($1)),)
SetCompilerCMDs = $(if $($1),,$(eval $1:=$(CMD_$2)))
ShellCMDs       = $(if $(CMD_$1),,$(eval CMD_$1:=$(eval x:=$(strip $(firstword $(shell $(BASECMD_which) $1 2>&1))))$(if $(wildcard $x),$x,$1)))
###################################
$(eval $(call ShellCMDs,which))
BASECMD_which := $(CMD_which)
$(foreach c,$(CMDS_COMPILERS_MAP),$(eval $$(call SetLocalCMDs,$(subst :,$(comma),$c))))
$(foreach c,$(ALL_CMDS)         ,$(eval $(call ShellCMDs,$c)))
$(foreach c,$(CMDS_COMPILERS_MAP),$(eval $$(call SetCompilerCMDs,$(subst :,$(comma),$c))))
###################################
UNAME                       := $(CMD_uname)
ifndef CXX_MF
CXX_MF:=-MF
endif
ifndef C_MF
C_MF:=-MF
endif
ifndef F77_MF
F77_MF:=-MF
endif
ifndef CXX_MMD
CXX_MMD:=-MMD
endif
ifndef C_MMD
C_MMD:=-MMD
endif
ifndef F77_MMD
F77_MMD:=-MMD
endif
ifndef CXX_MM
CXX_MM:=$(patsubst %D,%,$(CXX_MMD))
endif
ifndef C_MM
C_MM:=$(patsubst %D,%,$(C_MMD))
endif
ifndef F77_MM
F77_MM:=$(patsubst %D,%,$(F77_MMD))
endif
###################################
SHAREDSUFFIX := so
ifeq ($(IS_DARWIN),yes)
SHAREDSUFFIX := dylib
endif
ifndef OS_RUNTIME_LIBRARY_PATH
OS_RUNTIME_LIBRARY_PATH := LD_LIBRARY_PATH
ifeq ($(IS_DARWIN),yes)
OS_RUNTIME_LIBRARY_PATH := DYLD_FALLBACK_LIBRARY_PATH
endif
endif
UC_PROJECTNAME:=$(SCRAM_PROJECTNAME)
LC_PROJECTNAME:=$(shell $(CMD_echo) $(UC_PROJECTNAME) | $(CMD_tr) '[A-Z]' '[a-z]')
##############################################################################
ifndef RUN_LLVM_ANALYZER_ON_ALL
RUN_LLVM_ANALYZER_ON_ALL:=no
endif
ifndef SCRAMSTORENAME_LIB
SCRAMSTORENAME_LIB:=lib
endif
ifeq ($(strip $(SCRAM_SOURCEDIR)),)
SCRAM_SOURCEDIR:=src
endif

ifneq ($(strip $(PYTHON_BASE)),)
CMD_python := $(PYTHON_BASE)/bin/python
endif
ifeq ($(IS_MIC),yes)
CMD_python := $(PYTHONHOST_BASE)/bin/python
endif

ifneq ($(wildcard $(WORKINGDIR)/cache/bf/$(SCRAM_CONFIGDIR)/$(SCRAM_BUILDFILE)),)
CONFIGDEPS += $(WORKINGDIR)/cache/bf/$(SCRAM_CONFIGDIR)/$(SCRAM_BUILDFILE)
endif
CONFIGDEPS += $(WORKINGDIR)/cache/xlibs

ifndef SCRAM_BUILDVERBOSE
VERB:=@
VERB_ECHO:=:
else
VERB:=
VERB_ECHO:=echo
endif

ifeq ($(strip $(BUILD_LOG)),yes)
DO_BUILD_LOG:=
else
DO_BUILD_LOG:=:
endif

KEEP_ON_BUILDING:=
ifneq ($(findstring k,$(firstword  $(MAKEFLAGS))),)
KEEP_ON_BUILDING:=yes
FORCE_BUILD_START = (
FORCE_BUILD_END = ) || ($(CMD_echo) gmake: \*\*\* [$@] Error $$?; $(CMD_touch) $(WORKINGDIR)/build_error || exit 0)
else
ifeq ($(strip $(BUILD_LOG)),yes)
FORCE_BUILD_START = (
FORCE_BUILD_END = ) || (exitcode=$$?; $(CMD_echo) gmake: \*\*\* [$@] Error $$exitcode; $(CMD_touch) $(WORKINGDIR)/build_error; exit $$exitcode)
else
FORCE_BUILD_START =
FORCE_BUILD_END =
endif
endif

$(SCRAM_SOURCEDIR) :=

##############################################################################
##############################################################################
define set_cached_var_func_arg_
cached_var_func_arg$(cached_var_func_arg_count_$(1))_$(1) := $(2)
cached_var_func_arg_count_$(1) := $(cached_var_func_arg_count_$(1))1
endef
define set_cached_var_
cached_var_func_arg_count_$(1) := 
$(foreach arg,$(subst $(comma),$(space),$(cached_var_function_$(1))),$(eval $(call set_cached_var_func_arg_,$(1),$(arg))))
cached_var_$(1) := $(call $(cached_var_func_arg_$(1)),$(cached_var_func_arg1_$(1)),$(cached_var_func_arg11_$(1)),$(cached_var_func_arg111_$(1)),$(cached_var_func_arg1111_$(1)),$(cached_var_func_arg11111_$(1)))
endef
define get_cached_var_
$(if $(subst undefined,,$(origin cached_var_$(1))),$(cached_var_$(1)),$(eval $(call set_cached_var_,$(1)))$(cached_var_$(1)))
endef
define get_uniq_cached_var_
$(if $(subst undefined,,$(origin cached_var_$(1))),$(cached_var_$(1)),$(eval $(call set_cached_var_,$(1)))$(eval cached_var_$(1):=$(call Uniq,$(cached_var_$(1))))$(cached_var_$(1)))
endef
##############################################################################
do_rsort=$(if $(wordlist 2,2,$(1)),$(call do_rsort,$(wordlist 2,$(words $(1)),$(1))) $(firstword $(1)),$(1))
rsort=$(call do_rsort,$(sort $1))
define GetTimeStamp
$(CMD_perl) -e '@d=stat "$(1)"; print "$$d[9]\n";'
endef
define Uniq
$(eval uniq_string_:=)$(strip $(foreach v,$(1),$(if $(filter $(v),$(uniq_string_)),,$(eval uniq_string_+=$(v))))$(uniq_string_))
endef
define AddCachedVariable
cached_var_function_$(1)  := $(subst $(colon),$(comma),$(2))
ifeq ($$(strip $(3)),)
$(1) = $$(call get_cached_var_,$(1))
else
$(1) = $$(call get_uniq_cached_var_,$(1))
endif
endef
define GetVariable
$($(1))
endef
define AdjustFlag
$(strip $(filter-out $(strip $(REM_$1_$2) $(REM_$2)),$($2)) $($1_$2))
endef
define AdjustFlags
$(strip \
  $(foreach f,$3,\
    $(if $(subst undefined,,$(origin ADJUST_$1_$f_COMP$4_FILE$5_TYPE_$(subst $(space),_,$2))),$(ADJUST_$1_$f_COMP$4_FILE$5_TYPE_$(subst $(space),_,$2)),\
      $(eval ADJUST_$1_$f_COMP$4_FILE$5_TYPE_$(subst $(space),_,$2):=\
        $(strip \
          $(USER_PRE_$f) \
          $(filter-out \
            $(strip $(USER_PRE_$f) $(USER_$f) $(USER_REM_$f) $(REM_$f) $($1_LOC_FLAGS_REM_$f) $($1_LOC_FLAGS_$f)\
              $(if $(strip $4),$($4_EX_FLAGS_REM_$f_ALL)) $(foreach t,$2 $($1_CLASS),$(REM_$t_$f) $($t_$f))),\
            $(if $(strip $4),$($4_EX_FLAGS_$f_ALL),$($f)) $(foreach t,$2 $($1_CLASS),$($t_$f)) $($1_$f))\
          $(strip $(foreach t,$2 $($1_CLASS),$($t_$f)) $($1_LOC_FLAGS_$f) $($(2)_LOC_FLAGS_$f) $(USER_$f))\
        )\
      )\
      $(ADJUST_$1_$f_COMP$4_FILE$5_TYPE_$(subst $(space),_,$2))\
    )\
  )\
)
endef
TOOLS_FLAGS_FUNC=$(strip $($(2)_LOC_FLAGS_$(1)_ALL))
TOOLS_FLAGS_FUNC_ORIG=$(strip $(USER_PRE_$(1)) $(filter-out $(strip $(USER_REM_$(1)) $($(2)_LOC_FLAGS_REM_$(1)) $($(2)_LOC_FLAGS_$(1))),$($(1)) $($(2)_LOC_FLAGS_$(1)_ALL)) $($(2)_LOC_FLAGS_$(1)) $(USER_$(1)))
TOOLS_DIR_FUNC=$(strip $(addprefix $3,$(wildcard $(2) $(filter-out $(2),$($(1)_LOC_$(2)_ALL)))))
TOOLS_LIB_FUNC=$(strip $(addprefix -l,$($2)) $(addprefix -l,$($(1)_LOC_$(2)_ALL)))
$(foreach f,$(OVERRIDABLE_FLAGS),$(eval PreTool_$f=$$(call TOOLS_FLAGS_FUNC,$f,$$1)))
$(foreach f,$(OVERRIDABLE_FLAGS),$(eval Tool_$f=$$(PreTool_$f)))
$(foreach x,$(strip $(patsubst %_LIB,%,$(LIB_TYPES))),$(eval Tool_$(x)_LDFLAGS=$$(strip $$(call PreTool_$(x)_LDFLAGS,$$1) $$(call TOOLS_DIR_FUNC,$$1,LIBDIR,-L) $$(call TOOLS_LIB_FUNC,$$1,$(x)_LIB))))
Tool_CPPFLAGS=$(strip $(call PreTool_CPPFLAGS,$1) $(call AdjustFlags,$1,,CPPDEFINES) $(call TOOLS_DIR_FUNC,$1,INCLUDE,-I))
Tool_LDFLAGS=$(strip $(call PreTool_LDFLAGS,$1) $(call TOOLS_DIR_FUNC,$1,LIBDIR,-L) $(call TOOLS_LIB_FUNC,$1,LIB))
Tool_DependenctPCMS=$(foreach l,$($(1)_LOC_LIB_ALL),$(foreach p,$($(l)_LCGDICTS) $($(l)_ROOTDICTS),-m $(l)_$(p)r_rdict.pcm)) \
                      $(foreach u,$($(1)_LOC_USE_ALL),$(foreach p,$($(u)_EX_FLAGS_PCMS),-m lib$(p)_rdict.pcm))
CalculateToolOrder=$(if $(strip $($(1)_EX_USE)),$(shell $(CMD_perl) \-e '@z=($(2) $(foreach dep,$(foreach d,$($(1)_EX_USE),$($d)),$(comma)$($(dep)_ORDER))); \
                     @z=sort {$$a <=> $$b} @z;$$x=$$z[0];$$x--;print "$$x";'),$(2))
FindToolDependency=$(sort $(filter-out $(3),$(foreach dep,$(foreach d,$($(1)_$(2)_USE),$($d)),$(dep) $($(dep)_EX_USE_ALL))))
FindUOLibDependency=$(sort $(foreach d,$($(1)_EX_USE),$($($d)_EX_LIB) $($($d)_EX_UOLIB)))
FindToolDepVariable=$($(1)_$(3)_$(2)) $(foreach var,$(sort $(foreach dep,$($(1)_$(3)_USE_ALL),$($(dep)_ORDER)$(colon)$(dep))),\
                      $($(word 2,$(subst $(colon),$(space),$(var)))_EX_$(2)))
FindToolDepVariableR=$(foreach var,$(call rsort,$(foreach dep,$($(1)_$(3)_USE_ALL),$($(dep)_ORDER)$(colon)$(dep))),\
                      $($(word 2,$(subst $(colon),$(space),$(var)))_EX_$(2))) $($(1)_$(3)_$(2))

define ProductOrder
ifeq ($(strip $($(1)_ORDER)),)
$(call AddCachedVariable,$(1)_ORDER,CalculateToolOrder:$(1):$(if $(strip $(2)),$(strip $(2)),99999),)
endif
$(foreach err,$(foreach use,$(filter-out $(ALL_TOOLS),$(sort $($(1)_LOC_USE) $($(1)_EX_USE))),$(if $($($(use))_EX_USE),,$(use))),$(4)_USE_ERR+=$(err))
endef

define ProductCommonVarsTools
$(eval $(call ProductOrder,$1,$2,$3,$4))
$(foreach type,INCLUDE LIB $(LIB_TYPES) LIBDIR,$(eval $(call AddCachedVariable,$(1)_EX_$(type)_ALL,FindToolDepVariable:$(1):$(type):EX,1)))
$(foreach type,$(foreach f,$(ALL_COMPILER_FLAGS),FLAGS_$(f)),$(eval $(call AddCachedVariable,$(1)_EX_$(type)_ALL,FindToolDepVariableR:$(1):$(type):EX,)))
$(foreach type,$(foreach f,$(ALL_COMPILER_FLAGS),FLAGS_REM_$(f)),$(eval $(call AddCachedVariable,$(1)_EX_$(type)_ALL,FindToolDepVariable:$(1):$(type):EX,)))
$(call AddCachedVariable,$(1)_EX_USE_ALL,FindToolDependency:$(1):EX,)
endef

define ProductCommonVars
$(eval $(call ProductOrder,$1,$2,$3,$4))
$(foreach scope,$(if $(strip $($(1)_EX_LIB)$($(1)_EX_USE)),EX) LOC,$(foreach type,INCLUDE LIB $(LIB_TYPES) LIBDIR,$(eval $(call AddCachedVariable,$(1)_$(scope)_$(type)_ALL,FindToolDepVariable:$(1):$(type):$(scope),1))))
$(foreach scope,$(if $(strip $($(1)_EX_LIB)$($(1)_EX_USE)),EX) LOC,$(foreach type,$(foreach f,$(OVERRIDABLE_FLAGS),FLAGS_$(f)),$(eval $(call AddCachedVariable,$(1)_$(scope)_$(type)_ALL,FindToolDepVariableR:$(1):$(type):$(scope),))))
$(foreach scope,$(if $(strip $($(1)_EX_LIB)$($(1)_EX_USE)),EX) LOC,$(eval $(call AddCachedVariable,$(1)_$(scope)_USE_ALL,FindToolDependency:$(1):$(scope):$($(1)_DROP_DEP),)))
$(foreach f,$(OVERRIDABLE_FLAGS),$(eval $(call AddCachedVariable,$(1)_$f,Tool_$f:$(1),)))
endef

define ProductCommonVarsExternal
ifneq ($(strip $($(1)_BuildFile)),)
$(eval $(call AddCachedVariable,$(1)_ORDER,CalculateToolOrder:$(1):99999,))
$(eval $(call AddCachedVariable,$(1)_EX_LIB_ALL,FindToolDepVariable:$(1):LIB:EX,1))
$(eval $(call AddCachedVariable,$(1)_EX_USE_ALL,FindToolDependency:$(1):EX,))
$(eval $(call AddCachedVariable,$(1)_EX_UOLIB,FindUOLibDependency:$(1),))
else
$(1)_ORDER:=99999
endif
endef

define outputlog
  @if [ -d $(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR)/$(1) ] ; then \
    $(DO_BUILD_LOG) for f in `$(CMD_find) $(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR)/$(1) -name "*" -type f | $(CMD_grep) -v  '/build\.log$$'` ; $(DO_BUILD_LOG) do $(DO_BUILD_LOG) $(CMD_cat) $$f $(redirectlog_$(2)) ; $(DO_BUILD_LOG) $(CMD_rm) -f $$f;  $(DO_BUILD_LOG) done ;\
  fi
endef
define outputLogFile
  @if [ "X$1" != "X" ] ; then \
    $(CMD_cat) $1;\
    dir=`$(CMD_dirname) $1`;\
    while [ ! -f "$$dir/build.log" ] && [ "$$dir" != "$(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR)" ] ; do \
      dir=`$(CMD_dirname) $$dir`;\
    done ;\
    [ -f "$$dir/build.log" ] && $(CMD_cat) $1 >> $$dir/build.log ;\
    $(CMD_rm) -f $1;\
  fi
endef
define checklibs
  $(eval xliberr:=)$(foreach x,$($(1)_LOC_LIB),$(if $(strip $(filter-out $($(1)_PACKAGE),$($(x)_PACKAGE))),$(eval xliberr+=$x:$($(x)_PACKAGE)),)) \
  if [ "X$(xliberr)" != "X" ] ; then \
    $(CMD_echo) "****ERROR: Skipping build of $1 generated from $($(1)_PACKAGE) as it is explicitly linking following library/libraries." ;\
    for x in $(xliberr) ; do $(CMD_echo) "    -> $$x" | $(CMD_sed) -e 's|:self/| from |';  done;\
    $(CMD_false);\
  fi
endef
define find_project_file
$(strip $(eval scram_pfp:=)$(foreach d,$(LOCALTOP) $(RELEASETOP) $(FULL_RELEASE_FOR_A_PATCH),$(if $(strip $(scram_pfp)),,$(eval scram_pfp:=$(wildcard $(d)/$(1)))))$(scram_pfp))
endef
define biglib_setup
  proj_tool=`$(CMD_echo) $(SCRAM_PROJECTNAME) | tr '[A-Z]' '[a-z]'` ; \
  tool_file=$(SCRAM_CONFIGDIR)/toolbox/$(SCRAM_ARCH)/tools/selected/$$proj_tool.xml ;\
  BIGLIB_RESET_ENV=NO ;\
  for tool in $(SCRAM_CONFIGDIR)/Self.xml $(SCRAM_CONFIGDIR)/toolbox/$(SCRAM_ARCH)/tools/selected/$$proj_tool.xml ; do \
    [ -f $$tool ] || continue ;\
    if [ $@ = "disable-biglib" ] ; then \
      [ `grep '#:DISABLED_BIGLIB:#' $$tool | $(CMD_wc) -l` -eq 0 ] || continue ;\
      $(CMD_sed) -i -e 's|^\( *<runtime .*/biglib/\)|#:DISABLED_BIGLIB:#\1|' $$tool ;\
    elif [ `grep '#:DISABLED_BIGLIB:#' $$tool | $(CMD_wc) -l` -gt 0 ] ; then \
      $(CMD_sed) -i -e 's|#:DISABLED_BIGLIB:#||' $$tool ;\
    else \
      continue ;\
    fi ;\
    if [ "$$tool" = "$(SCRAM_CONFIGDIR)/Self.xml" ] ; then \
      $(SCRAM) setup self ;\
    else \
      $(CMD_echo) Setting up $$proj_tool;\
      $(SCRAM) setup $$proj_tool;\
    fi;\
    BIGLIB_RESET_ENV=YES ;\
  done ;\
  if [ "X$$BIGLIB_RESET_ENV" = "XYES" ] ; then \
    $(CMD_echo) "*** Please re-run cmsenv command to get your runtime environment updated ****";\
  fi
endef
##############################################################################
define BuildClean
  if [ "X$(1)" != "X" ] ; then \
    if [ -d $(WORKINGDIR)/$(1) ] ; then \
      regexp=$2; \
      if [ "X$$regexp" == "X" ] ; then regexp='[0-9][0-9]'; fi ;\
      $(CMD_find) $(WORKINGDIR)/$(1) -name "AUTOCLEAN.*.clean" -type f | $(CMD_xargs) $(CMD_cat) | $(CMD_grep) "^$$regexp:" | $(CMD_sort) | $(CMD_uniq) | $(CMD_sed) -e "s|^$$regexp:||" > $(WORKINGDIR)/$(1)/.AUTOCLEAN ; \
      if [ "X$3" == "X" ] ; then $(CMD_cat) $(WORKINGDIR)/$(1)/.AUTOCLEAN; fi;\
      $(CMD_sh) $(WORKINGDIR)/$(1)/.AUTOCLEAN;\
      $(CMD_rm) -rf $(WORKINGDIR)/$(1); \
      $(CMD_rm) -rf $(WORKINGDIR)/classes/$(1); \
    fi;\
  fi
endef

define AutoCleanFile
$(dir $(1))/AUTOCLEAN.$(notdir $(1)).$(2).clean
endef
##############################################################################
# Macros for pre/post build steps:
define copy_build_product
  if [ ! -d $(LOCALTOP)/$(1) ]; then 	\
    $(CMD_mkdir) -p $(LOCALTOP)/$(1)	&&\
    $(CMD_echo) "Creating product storage directory: $(LOCALTOP)/$(1)"; \
  fi &&\
  $(CMD_echo) "Copying $@ to productstore area:" &&\
  $(CMD_echo) "01:$(CMD_rm) -f $(1)/$(@F)" > $(call AutoCleanFile,$@,prod) &&\
  $(CMD_rm) -f $(LOCALTOP)/$(1)/$(@F) &&\
  $(CMD_cp) $@ $(LOCALTOP)/$(1) || ($(CMD_rm) -f $@ && $(CMD_echo) ">> Deleted: $@" && exit 1)
endef

define copy_lib_to_main_productstore
  $(call install_name_tool, @rpath/$(@F),$@) && \
  $(call install_name_tool_rpath, $(LOCALTOP)/$(1),$@) && $(call copy_build_product,$(1))
endef

define copy_bin_to_main_productstore
   $(call install_name_tool_rpath, $(LOCALTOP)/$(patsubst bin%,lib%,$1)/,$@) && $(call copy_build_product,$(1))
endef

define copy_test_to_main_productstore
  $(call install_name_tool_rpath, ${LOCALTOP)/$(patsubst test%, lib%,$1),$@) && $(call copy_build_product,$(1))
endef

define copy_py_to_main_productstore
  $(call copy_build_product,$(1))
endef

define delete_build_prod 
  $(CMD_rm) -f $@ $(LOCALTOP)/$(1)/$(@F)
endef

define delete_plugin_build_prod 
  $(call delete_build_prod,$(1)) &&\
  if [ "X$(2)" != X ] ; then \
    if [ -f $($(2)_pluginprod) ] ; then \
      $(CMD_touch) $(LOCALTOP)/$(SCRAM_INTwork)/cache/$($(2)_plugintype)_$($(2)_pluginrefresh) &&\
      $(CMD_rm) -f $(LOCALTOP)/$($(2)_pluginprod) ;\
    fi ;\
  fi
endef

define	clean_path
  @if [ -d $(LOCALTOP)/$(1) ] ; then \
    $(CMD_echo) "Cleaning local working directory:$(1)"; \
    $(CMD_rm) -rf $(LOCALTOP)/$(1) ; \
  fi
endef

define clean_prod
  @if [ -f $(LOCALTOP)/$(1) ] ; then \
    $(CMD_echo) "Cleaning product: $(1)" ; \
    $(CMD_rm) -f $(LOCALTOP)/$(1); \
  fi    
endef

define clean_src_scripts
  @$(call clean_files,$(1),$(2))
endef

define clean_files
  for f in $(1); do \
    $(CMD_rm) -rf $(LOCALTOP)/$(2)/$$f;	\
  done
endef

define do_plugin_refresh
endef
#############################################################################
##############################################################################
ifeq ($(filter-out osx%,$(SCRAM_ARCH)),)
  define install_name_tool
    $(CMD_echo) "calling install_name_tool -id $(1) $(2)" &&\
    install_name_tool -id $1 $2
  endef
  define install_name_tool_rpath
    $(CMD_echo) "calling install_name_tool -add_rpath $(1) $(2)" &&\
    install_name_tool -add_rpath $1 $2
  endef
else
  define install_name_tool
    $(CMD_true)
  endef
  define install_name_tool_rpath
    $(CMD_true)
  endef
endif

define run_plugin_refresh_cmd
  @if [ -f $< ] ; then \
    if [ -f $@ ] ; then \
      if [ -s $@ ] ; then \
        touch -t 198001010100 $@ ;\
      else \
        rm -f $@ ; \
      fi;\
    fi;\
    $(call do_$(1),$(@D)) &&\
    touch $@ ;\
  fi
endef
ifdef SCRAM_DUMP_PRODUCT_TO_SOURCE
define DumpProduct2SRC
endef
else
DumpProduct2SRC=
endif

##############################################################################
##############################################################################
#Compilation Rules
ifeq ($(strip $(SCRAM_GENERATE_LLVM_CCDB)),YES)
JsonStr = $(subst ",\\\",$(subst \,\\,$1))
define run_compile_command
  @[ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Generating LLVM Compile command for $(2) $< " &&\
  $(CMD_echo) '{"directory":"$(call JsonStr,$(LOCALTOP))",\
                "file":"$(call JsonStr,$<)",\
                "command":"$(call JsonStr,$(notdir $(firstword $4)) $(wordlist 2,999999,$4) $< -o $(subst .$(LLVM_CCDB_EXT),,$@))"}' > $@
endef
else
define run_compile_command
  @$(startlog_$(1)) [ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Compiling $(2) $< " &&\
  $(VERB_ECHO) $(SCRAM_PREFIX_COMPILER_COMMAND) "$4 $5 $< -o $@" &&\
              ($(SCRAM_PREFIX_COMPILER_COMMAND) $4 $5 $< -o $@ || ($(if $(strip $6),$4 $6 $< -o $(basename $@).d && $(CMD_sed) -i -e 's|.*:|$@:|' $(basename $@).d && exit 1,exit 1))) $3 $(endlog_$(1))
endef
endif
define compile_cxx_common
  $(call run_compile_command,$2,$4,$5,$(CXX) -c $(3) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS),$(if $(6),,$(CXX_MMD) $(CXX_MF) $(basename $@).d),$(if $(6),,$(CXX_MM)))
endef
define compile_c_common
  $(call run_compile_command,$2,$4,$5,$(CC)  -c $(3) $(COPTIMISEDFLAGS) $(CSHAREDOBJECTFLAGS),$(if $(6),,$(C_MMD) $(C_MF) $(basename $@).d),$(if $(6),,$(C_MM)))
endef
ifeq ($(strip $(SCRAM_DEFAULT_COMPILER)),icc)
define compile_fortran_common
  $(call run_compile_command,$2,$4,$5,$(FC)  -c $(3) $(FOPTIMISEDFLAGS) $(FSHAREDOBJECTFLAGS),,)
endef
else
define compile_fortran_common
  $(call run_compile_command,$2,$4,$5,$(FC)  -c $(3) $(FOPTIMISEDFLAGS) $(FSHAREDOBJECTFLAGS),$(if $(6),,$(F77_MMD) $(F77_MF) $(basename $@).d),$(if $(6),,$(F77_MM)))
endef
endif
define compile_cuda_common
  $(call run_compile_command,$2,$4,$5,$(NVCC) -dc $(3) --compiler-options '$(call AdjustFlags,$1,,CXXFLAGS) $(CXXSHAREDOBJECTFLAGS)',)
  $(if $(6),,@$(startlog_$(2)) ($(NVCC) -M $(3) --compiler-options \
     '$(call AdjustFlags,$1,,CXXFLAGS) $(CXXSHAREDOBJECTFLAGS)' $< -o $(basename $@).d && $(CMD_sed) -i -e 's|.*:|$@:|' $(basename $@).d) $(endlog_$(2)))
endef

#LLVM Analyzer Rules
define run_analyze_command
  @$(startlog_$(2)) [ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Analyzing $(4) $< " &&\
  $(VERB_ECHO) $5 $< -o /dev/null &&\
               $5 $< -o /dev/null $(endlog_$(2))
endef
define analyze_cxx_common
  $(call run_analyze_command,$1,$2,$3,$4,$(if $(strip $(SCRAM_DXR_RUN)),$(DXR_CXX) -fsyntax-only -xc++,$(CXX) -c) $(3) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS))
endef
define analyze_c_common
  $(call run_analyze_command,$1,$2,$3,$4,$(if $(strip $(SCRAM_DXR_RUN)),$(DXR_CC)  -fsyntax-only -xc,$(CC) -c)    $(3) $(COPTIMISEDFLAGS) $(CSHAREDOBJECTFLAGS))
endef

##############################################################################
define compile_cxx
  $(call compile_cxx_common,$1,$2,$(call AdjustFlags,$1,,CPPFLAGS CXXFLAGS))
endef
define compile_cxx_capabilities
  $(call compile_cxx_common,$1,$2,$(call AdjustFlags,$1,EDM CAPABILITIES,CPPFLAGS CXXFLAGS),capabilities)
endef
define compile_cxx_edm
  $(call compile_cxx_common,$1,$2,$(call AdjustFlags,$1,EDM,CPPFLAGS CXXFLAGS),edm plugin)
endef
define compile_c
  $(call compile_c_common,$1,$2,$(call AdjustFlags,$1,,CPPFLAGS CFLAGS))
endef
define compile_c_edm
  $(call compile_c_common,$1,$2,$(call AdjustFlags,$1,EDM,CPPFLAGS CFLAGS),edm plugin)
endef  
define compile_fortran
  $(call compile_fortran_common,$1,$2,$(call AdjustFlags,$1,,CPPFLAGS FFLAGS))
endef  
define compile_cuda
  $(call compile_cuda_common,$1,$2,$(call AdjustFlags,$1,,CPPFLAGS CUDA_FLAGS))
endef
define compile_boost
  $(call compile_cxx_common,$1,$2,-DSCRAM_PYTHON_MODULE="BOOST_PYTHON_MODULE($*)" $(call AdjustFlags,$1,,CPPFLAGS PY_CXXFLAG),boost)
endef  
define compile_pywrapper
  $(call compile_cxx_common,$1,$2,-DSCRAM_PYTHON_MODULE="BOOST_PYTHON_MODULE($(1)_PyWrapper)" $(call AdjustFlags,$1,,CPPFLAGS PY_CXXFLAG),pywrapper)
endef

define analyze_cxx
  $(call analyze_cxx_common,$1,$2,$(call AdjustFlags,$1,,CPPFLAGS CXXFLAGS))
endef
define analyze_c
  $(call analyze_c_common,$1,$2,$(call AdjustFlags,$1,,CPPFLAGS CFLAGS))
endef

define link_cuda_objs
  @$(startlog_$(1)) [ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Cuda Device Link $@ " &&\
  $(VERB_ECHO) $(SCRAM_PREFIX_COMPILER_COMMAND) "$(NVCC) $(call AdjustFlags,$1,,CUDA_LDFLAGS CUDA_FLAGS)  $? -o $@" &&\
              ($(SCRAM_PREFIX_COMPILER_COMMAND) $(NVCC) $(call AdjustFlags,$1,,CUDA_LDFLAGS CUDA_FLAGS) $? -o $@) $(endlog_$(1))
endef
##############################################################################
# Dictionary compilation
define processTmpMMDData
  [ -f $(basename $@).d ] && $(CMD_sed) -e 's#$1#$3#g;s#$2:#$<:#g;s#^  *\.\./\(\.\./\)*# #g' $(basename $@).d | $(CMD_grep) -v '^ *\\$$' > $<.dx; $(CMD_mv) $<.dx $(basename $@).d
endef
define compile_lcgdict
  @$(startlog_$(2)) [ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Compiling LCG dictionary: $<" &&\
  $(VERB_ECHO)                   $(CXX) $(CXX_MMD) $(CXX_MF) $(1)/$(patsubst $($(1)_objdir)/%,%,$(basename $@).d) -c -I$(LOCALTOP) $(call AdjustFlags,$1,LCGDICT,CPPFLAGS CXXFLAGS) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $(1)/$(patsubst $($(1)_objdir)/%,%,$<) -o $(1)/$(patsubst $($(1)_objdir)/%,%,$@) &&\
  (($(CMD_cd) $($(1)_objdir)/..; $(CXX) $(CXX_MMD) $(CXX_MF) $(1)/$(patsubst $($(1)_objdir)/%,%,$(basename $@).d) -c -I$(LOCALTOP) $(call AdjustFlags,$1,LCGDICT,CPPFLAGS CXXFLAGS) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $(1)/$(patsubst $($(1)_objdir)/%,%,$<) -o $(1)/$(patsubst $($(1)_objdir)/%,%,$@)) || ($(CMD_rm) -f $< && exit 1)) $(endlog_$(2))
  @$(startlog_$(2))$(call processTmpMMDData,$(1)/$(patsubst $($(1)_objdir)/%,%,$<),$(1)/$(patsubst $($(1)_objdir)/%,%,$@),$3)$(endlog_$(2))
endef
# Root Dictionary compilation
define compile_rootdict
  $(call compile_cxx_common,$1,$2,$(call AdjustFlags,$1,ROOTDICT,CPPFLAGS CXXFLAGS),root dictionary,|| ($(CMD_rm) -f $< && exit 1))
  @$(startlog_$(2))$(call processTmpMMDData,$<,$@,$3)$(endlog_$(2))
endef
define compile_python
  $(CMD_echo) ">> Compiling python modules $1" &&\
  $(VERB_ECHO) "$(CMD_python) -m compileall -q $1" &&\
  $(CMD_python) -m compileall -q $1 || $(CMD_touch) $(COMMON_WORKINGDIR)/cache/python_error
endef
##############################################################################
# Source Generators Rules
# boost source generation from Pyste
define pyste2boost
  @$(startlog_$(2))$(CMD_echo)  ">> Generating and compiling Boost stub for module $*" 	&& \
  $(VERB_ECHO) python $(PYSTE_EXEC) -D_REENTRANT $($(1)_CPPFLAGS) --out=$@ --module=$* $< &&\
  python $(PYSTE_EXEC) -D_REENTRANT $($(1)_CPPFLAGS) --out=$@ --module=$* $< $(endlog_$(2))
endef  
# PyWrapper Generation
define generate_pywrapper
  @$(startlog_$(2))$(CMD_echo) "Generating wrapper code to put the following files in a single module called: $(1)" $(endlog_$(2))
  @exec 5>&1;	\
  ( $(CMD_echo) "#include <boost/python.hpp>"; echo;	\
  for c in $($(1)_classnames) ..; do		\
    case $$c in .. ) continue ;; esac ;		\
    $(CMD_echo) "  $$c" 1>&5;				\
    $(CMD_echo) "extern void init_module_$$c ();";	\
  done;						\
  echo; $(CMD_echo) "void init_module_$(1) () {";	\
  for c in $($(1)_classnames) ..; do		\
    case $$c in .. ) continue ;; esac ;		\
    $(CMD_echo) "  init_module_$$c ();";		\
  done;						\
  $(CMD_echo) "}"; echo;				\
  $(CMD_echo) "extern \"C\" void init$(1) () {";	\
  $(CMD_echo) 'boost::python::detail::init_module("$(1)",'\
	'init_module_$(1));';			\
  $(CMD_echo) "}";					\
  ) > $@.tmp
  @$(CMD_mv) $@.tmp $@
endef  
#LCG dictionary generation
define generate_classes_h
  @$(startlog_$(2))[ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) && $(CMD_rm) -f $@ &&\
  $(CMD_echo) ">> Generating LCG reflex dict header file $(patsubst $(LOCALTOP)/$(SCRAM_SOURCEDIR)/%,%,$<)" &&\
  $(VERB_ECHO) $(CLASSES_H_GENERATOR) $< &&\
  (            $(CLASSES_H_GENERATOR) $< > $@ || ($(CMD_rm) -f $@ && exit 1)) \
  $(endlog_$(2))
endef

define generate_lcgdict
  @$(startlog_$(2))[ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) && $(CMD_rm) -f $@ &&\
  $(CMD_echo) ">> Building LCG reflex dict from header file $(patsubst $(LOCALTOP)/%,%,$4)" &&\
  $(VERB_ECHO) $(GENREFLEX) $(4) -s $(3) -o $@ $($(6)_GENREFLEX_ARGS) $(if $(strip $(GENERATE_ROOT_PCMS)),--rootmap=$(basename $(@F)).rootmap --rootmap-lib=$(MODULE_PREFIX)$(1).$(SHAREDSUFFIX) $(call Tool_DependenctPCMS,$1),$(GENREFLEX_GCCXMLOPT) --gccxmlpath=$(GCCXML_BASE)/bin) --capabilities=$(notdir $(5)) $(GENREFLEX_CPPFLAGS) $(call AdjustFlags,$1,LCGDICT,CPPFLAGS) &&\
  (            $(GENREFLEX) $(4) -s $(3) -o $@ $($(6)_GENREFLEX_ARGS) $(if $(strip $(GENERATE_ROOT_PCMS)),--rootmap=$(basename $(@F)).rootmap --rootmap-lib=$(MODULE_PREFIX)$(1).$(SHAREDSUFFIX) $(call Tool_DependenctPCMS,$1),$(GENREFLEX_GCCXMLOPT) --gccxmlpath=$(GCCXML_BASE)/bin) --capabilities=$(notdir $(5)) $(GENREFLEX_CPPFLAGS) $(call AdjustFlags,$1,LCGDICT,CPPFLAGS) || ($(CMD_rm) -f $@ && exit 1)) \
  $(endlog_$(2))
endef
# ROOT dictionary generation
define generate_rootdict
  @$(startlog_$(2))[ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Building Root dict from header file $< " &&\
  $(VERB_ECHO) $(ROOTCINT) -f $@ $(if $(strip $(GENERATE_ROOT_PCMS)),$(call Tool_DependenctPCMS,$1)) -c -p -DGNU_SOURCE $(call AdjustFlags,$1,ROOTDICT,CPPFLAGS) $(patsubst $(SCRAM_SOURCEDIR)/%,%,$<) &&\
  (            $(ROOTCINT) -f $@ $(if $(strip $(GENERATE_ROOT_PCMS)),$(call Tool_DependenctPCMS,$1)) -c -p -DGNU_SOURCE $(call AdjustFlags,$1,ROOTDICT,CPPFLAGS) $(patsubst $(SCRAM_SOURCEDIR)/%,%,$<) || ($(CMD_rm) -f $@ && exit 1)) &&\
  $(CMD_mv) $@ $@.base	&&\
  $(CMD_cat) $< $@.base > $@ &&\
  $(CMD_rm) -f $@.base $(endlog_$(2))
endef

# CondFormat Serialization generation
define generate_CondSerialization
  @$(startlog_$(2))[ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Generating CondFormat Serialization code from header file $< " &&\
  $(VERB_ECHO) $(COND_SERIALIZATION_SCRIPT) --output $(LOCALTOP)/$@ --package $(dir $3) -- $(call AdjustFlags,$1,,CPPFLAGS CXXFLAGS,llvm-cxxcompiler) &&\
  (            $(COND_SERIALIZATION_SCRIPT) --output $(LOCALTOP)/$@ --package $(dir $3) -- $(call AdjustFlags,$1,,CPPFLAGS CXXFLAGS,llvm-cxxcompiler) || ($(CMD_rm) -f $@ && exit 1)) $(endlog_$(2))
endef
# Pre-Compile Header generation
define generate_PreCompileHeader
  $(call compile_cxx_common,$1,$2,$(call AdjustFlags,$1,PRECOMPILE,CPPFLAGS CXXFLAGS),precompile header)
  @$(CMD_echo) $(call AdjustFlags,$1,PRECOMPILE,CPPFLAGS CXXFLAGS) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) > $@.$(PRECOMPILE_FLAGS_EXTENSION)
endef
# CodeGen record Generation
define generate_codegen_record
  @$(startlog_$(2))$(CMD_echo) ">> Generating file $(@F) from class descriptor $<" &&\
  $(VERB_ECHO) $($(1)_CODEGENPY) $(1) $($(1)_objdir) $< &&\
  $($(1)_CODEGENPY) $(1) $($(1)_objdir) $< $(endlog_$(2))
endef
# MOC generation
define generate_moc
  @$(startlog_$(2))[ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Running moc ( $(3) ) for $<" &&\
  $(3) -o $@ $< $(endlog_$(2))
endef
# Flex Generaton
define generate_lex
  @$(startlog_$(2))$(CMD_echo) "Flex: Generating $@ from $<" &&\
  $(VERB_ECHO) $(LEX) -o$@ -P$(patsubst %lex,%,$*) $< &&\
  ($(LEX) -o$@ -P$(patsubst %lex,%,$*) $< || ($(CMD_rm) -f $@ && exit 1))$(endlog_$(2))
endef
define generate_parse
  @$(startlog_$(2))$(CMD_echo) "Bison: Generating $@ from $<" &&\
  $(VERB_ECHO) $(YACC) -p$(patsubst %parse,%,$*) --defines=$(basename $@).h -o$(basename $@).cc $< &&\
  ($(YACC) -p$(patsubst %parse,%,$*) --defines=$(basename $@).h -o$(basename $@).cc $< ||($(CMD_rm) -f $(basename $@).h $(basename $@).cc && exit 1)) &&\
  $(CMD_cd) $(WORKINGDIR)/$(3) &&\
  $(CMD_rm) -f $*parse.h && $(CMD_ln) -s $(1)/$*parse.h $*parse.h $(endlog_$(2))
endef
##############################################################################
define processMMDData
  $(startlog_$(2))$(CMD_rm) -f $3 && $(CMD_touch) $3 &&\
  for dep in $4 ; do \
    if [ -f $$dep ] ; then $(CMD_sed) -e 's|: *|: \\\'$$'\n|' $$dep |  $(CMD_sed) -e 's|.*$(LOCALTOP)/| |g$(if $(strip $(DROP_EXTERNAL_HEADER_MMD_DEPS)),;s|^  */.*||,)' | $(CMD_grep) -v '^ *\\$$' | $(CMD_grep) -v '^ *$$' >> $3 ; $(CMD_echo) "" >> $3; fi ; \
  done &&\
  $(if $(strip $(DROP_EXTERNAL_HEADER_MMD_DEPS)),$(CMD_true),$(call addMMDDepsRules,$3)) $(endlog_$(2))
endef
define addMMDDepsRules
  $(CMD_tr) ' ' '\012' <  $1 | $(CMD_sed) -e 's/^'\\\\'$$//;/^$$/ d;/:$$/ d;s/$$/ :/' > $1.new &&\
  $(CMD_sort) $1.new | $(CMD_uniq) >> $1 &&\
  $(CMD_rm) -f $1.new
endef
##############################################################################
# Library linking Rules
# Shared library linking
define link_lib_common
  @$(startlog_$(2))$(CMD_echo) ">> Building $(5) $@" &&\
  $(CMD_touch) $(WORKINGDIR)/cache/prod/lib$(1) &&\
  $(VERB_ECHO)                $(CXX) $(6) $(CXXSHAREDFLAGS) $(call GetMissingSymbolFlags,$1)     $($(1)_objs) -o $@ $(if $7,$7,$(call AdjustFlags,$1,,LDFLAGS)) &&\
  (($(call checklibs,$(1)) && $(CXX) $(6) $(CXXSHAREDFLAGS) $(call GetMissingSymbolFlags,$1,yes) $($(1)_objs) -o $@ $(if $7,$7,$(call AdjustFlags,$1,,LDFLAGS))) || ($(call delete_plugin_build_prod,$(3),$(4)) && exit 1)) &&\
  if [ "X$($(1)_no_lib_copy)" = X ] ; then \
    $(call copy_lib_to_main_productstore,$(3)) ;\
  fi &&\
  $(call check_missing_symbols,$($(1)_libcheck),$(3),$(4)) $(call run_edm_checks,$1,$2,$3,$4) $(endlog_$(2))
  @$(call processMMDData,$1,$2,$@.dep,$(foreach d,$($(1)_objs:.$(OBJEXT)=.d),$d))
endef
define link_lib
  $(call link_lib_common,$1,$2,$3,$4,shared library,$(call AdjustFlags,$1,,CXXFLAGS))
endef  
define link_lib_edm
  $(call link_lib_common,$1,$2,$3,$4,edm plugin,$(call AdjustFlags,$1,EDM,CXXFLAGS),$(call AdjustFlags,$1,EDM,LDFLAGS))
endef
define link_pylib
  @$(startlog_$(2))$(CMD_echo) ">> Building Python module $($(1)_product)" && \
  $(CMD_touch) $(WORKINGDIR)/cache/prod/lib$(1) &&\
  $(VERB_ECHO)                $(CXX) $(CXXSHAREDFLAGS) $($(1)_objs) -o $@ $($(1)_CXXSharedLink) &&\
  (($(call checklibs,$(1)) && $(CXX) $(CXXSHAREDFLAGS) $($(1)_objs) -o $@ $($(1)_CXXSharedLink)) || ($(call delete_build_prod,$(3)) && exit 1)) &&\
  $(call copy_lib_to_main_productstore,$(3)) $(endlog_$(2))
  @$(call processMMDData,$1,$2,$@.dep,$(foreach d,$($(1)_objs:.$(OBJEXT)=.d),$d))
endef  
#Shared Capabilities library
define link_lib_capabilities
  @$(startlog_$(2))$(CMD_echo) ">> Building capability library $@" &&\
  $(VERB_ECHO)                $(CXX) $(call AdjustFlags,$1,EDM CAPABILITIES,CXXFLAGS) $(call GetMissingSymbolFlags,$1)     $(CXXSHAREDFLAGS) $5 -o $@ -l$(1) $(call AdjustFlags,$(1),EDM LCGDICT,LDFLAGS) &&\
  (($(call checklibs,$(1)) && $(CXX) $(call AdjustFlags,$1,EDM CAPABILITIES,CXXFLAGS) $(call GetMissingSymbolFlags,$1,yes) $(CXXSHAREDFLAGS) $5 -o $@ -l$(1) $(call AdjustFlags,$(1),EDM LCGDICT,LDFLAGS)) || ($(call delete_plugin_build_prod,$(3),$(4)) && exit 1)) &&\
  if [ "X$($(4)_no_lib_copy)" = X ] ; then \
    $(call copy_lib_to_main_productstore,$(3)) ;\
  fi &&\
  $(call check_missing_symbols,$($(1)_libcheck),$(3),$(4)) $(call check_edm_class_version,$1,$6,$3,$4) \
   $(if $(strip $($(1)_ROOTMAP_FILES)),$(call check_edm_class_transients,$1,$($(1)_ROOTMAP_FILES),$3,$4)) $(endlog_$(2))
endef

##############################################################################
# Binary/test building Rules
# Binary building 
define build_bin
  @$(startlog_$(2))$(CMD_echo) ">> Building binary $(1)" &&\
  $(VERB_ECHO)                $(CXX) $(call AdjustFlags,$1,,CXXFLAGS) $(CXXSHAREDOBJECTFLAGS) $($(1)_objs) $(call AdjustFlags,$1,,LDFLAGS) -o $@ &&\
  (($(call checklibs,$(1)) && $(CXX) $(call AdjustFlags,$1,,CXXFLAGS) $(CXXSHAREDOBJECTFLAGS) $($(1)_objs) $(call AdjustFlags,$1,,LDFLAGS) -o $@) || ($(call delete_build_prod,$(3)) && exit 1)) &&\
  $(call copy_bin_to_main_productstore,$(3)) $(endlog_$(2))
  @$(call processMMDData,$1,$2,$@.dep,$(foreach d,$($(1)_objs:.$(OBJEXT)=.d),$d))
endef
# Test executable building
define build_test
  $(call build_bin,$(1),$(2),$(3))
endef  
##############################################################################
# Data download and Copy
define script_copy
  @$(startlog_$(2))[ -d $(@D) ] || $(CMD_mkdir) -p $(@D) &&\
  $(CMD_rm) -rf $@ &&\
  $(CMD_cp) -rp $< $@	&&\
  $(CMD_echo) ">> Copied $(@F)" $(endlog_$(2))
endef
define generate_python_bytecode
  if [ "X$(PYTHON_COMPILE)" != X ] ; then \
    $(CMD_echo) ">> Generating python byte-code: $(1)" && \
    python $(PYTHON_COMPILE) -f $(1) >/dev/null 2>&1; \
  else \
    $(CMD_echo) "Python tool is not used. So not going to generate byte-code." ; \
  fi
endef
define python_script_copy
  @$(startlog_$(2))if [ ! -d $(LOCALTOP)/$(3) ]; then \
    $(CMD_mkdir) -p $(LOCALTOP)/$(3) &&\
    $(CMD_echo) "Creating product storage directory: $(LOCALTOP)/$(3)"; 	\
  fi &&\
  $(CMD_rm) -rf $($(1)_python_dir) && $(CMD_mkdir) -p $($(1)_python_dir) &&\
  $(CMD_echo) ">> Copying python/* to $($(1)_python_dir)" &&\
  for name in `$(CMD_ls) $($(1)_srcdir) | $(CMD_grep) -v "CVS\|BuildFile\|BuildFile.xml"` ; do \
    f=$($(1)_srcdir)/$$name &&\
    if [ -d $$f ] ; then \
      $(CMD_cp) -rp $$f $($(1)_python_dir) || continue ;\
    else  \
      [ "X`$(CMD_echo) $$f | $(CMD_grep) '\.py$$'`" != X ] || continue ; \
      $(CMD_cp) -rp $$f $($(1)_python_dir)/ || continue ;\
    fi \
  done &&\
  $(call generate_python_bytecode,$(LOCALTOP)/$($(1)_python_dir)) $(endlog_$(2))
endef
define copy_src_scripts
  @$(startlog_$(2))$(CMD_echo) "------- copying scripts from $(1) -------" &&\
  for f in $(3); do \
    [ -f $(LOCALTOP)/$(1)/$$f ] || continue ;\
    $(CMD_echo) ">> Copying $(LOCALTOP)/$(1)/$$f"	&&\
    $(CMD_cp) -p $(LOCALTOP)/$(1)/$$f  $(LOCALTOP)/$(4) || continue ;\
  done $(endlog_$(2))
endef
define src2store_copy
  @$(startlog_$(2)) $(CMD_echo) "------- copying files from $(1) -------" &&\
  [ -d $(LOCALTOP)/$(4) ] || $(CMD_mkdir) -p $(LOCALTOP)/$(4) &&\
  for f in $(3) ; do \
    if [ -d $(LOCALTOP)/$(4)/$$f ] ; then \
      $(CMD_rm) -rf $(LOCALTOP)/$(4)/$$f; \
    fi &&\
    $(CMD_cp) -rp $(LOCALTOP)/$(1)/$$f $(LOCALTOP)/$(4)/$$f &&\
    $(CMD_echo) ">> copied $$f"; \
  done $(endlog_$(2))
endef
define copy_python_products
  @$(startlog_$(2))[ -d $(4) ] || ($(CMD_mkdir) -p $(4) && $(CMD_echo) ">> $(4) created") &&\
  $(CMD_cp) $(3) $(4) $(endlog_$(2))
endef
#############################################################################
# Tesings test executable
define run_test
  @if [ "X$($(1)_NO_TESTRUN)" == "Xyes" ] ; then \
    $(CMD_echo) "Package "$(patsubst $(SCRAM_SOURCEDIR)/%/test,%,$(4))": Skipping test $(1)"; \
  else \
    $(CMD_echo) "Package "$(patsubst $(SCRAM_SOURCEDIR)/%/test,%,$(4))": Running test $(1)" &&\
    [ -d $($(1)_objdir) ] || $(CMD_mkdir) -p $($(1)_objdir) &&\
    $(CMD_rm) -f $($(1)_objdir)/testing.log; $(CMD_touch) $($(1)_objdir)/testing.log  &&\
    $(CMD_echo) " " >> $($(1)_objdir)/testing.log &&\
    $(CMD_echo) "===== Test \"$(1)\" ====" >> $($(1)_objdir)/testing.log &&\
    export PATH=$(LOCALTOP)/$(2):$(LOCALTOP)/$(4):$(PATH) && $(strip $($(1)_TEST_ENV)) (($(SCRAM_TEST_RUNNER_PREFIX) $($(1)_TEST_RUNNER_CMD) && $(CMD_echo) "" && $(CMD_echo) "---> test $(1) succeeded") >> $($(1)_objdir)/testing.log 2>&1 || ($(CMD_echo) "" && $(CMD_echo) "---> test $(1) had ERRORS") >> $($(1)_objdir)/testing.log) &&\
    $(CMD_echo) " " >> $($(1)_objdir)/testing.log &&\
    $(CMD_echo) "^^^^ End Test $(1) ^^^^" >> $($(1)_objdir)/testing.log &&\
    $(CMD_cat) $($(1)_objdir)/testing.log &&\
    $(CMD_cat) $($(1)_objdir)/testing.log >> $(LOCALTOP)/$(3)/testing.log; \
  fi
endef

##############################################################################
define bf_update
  @if [ ! -f $@ ] || [ "X$($(1)_BuildFile)" = X ] ; then \
    $(CMD_touch) $@;\
  elif [ "X`$(call get_time_stamp,$@)`" != "X`$(call get_time_stamp,$($(1)_BuildFile))`" ] ; then \
      $(CMD_touch) $@;\
  fi
endef
define config_update
  @[ -d  $(@D)] || $(CMD_mkdir) -p $(@D) ; $(CMD_touch) $@ ;\
  if [ "X$($(1)_BuildFile)" != X ] ; then \
    $(CMD_touch) -r $($(1)_BuildFile) $(WORKINGDIR)/cache/bf/$(1);\
  fi
endef
define timestamp_cmp
  $(CMD_perl) -e "my @s1=stat '$1'; my @s2=stat '$2';"'print $$s1[9]<=>$$s2[9];'
endef
define get_time_stamp
  $(CMD_perl) -e 'my @d=stat "$(1)"; print "$$d[9]\n";'
endef
define libdeps
$(prelibdeps) $(addprefix $(WORKINGDIR)/cache/prod/lib,$(sort $($(1)_LOC_LIB) $(foreach u,$($(1)_LOC_USE) $($(1)_EX_USE),$($u) $($($u)_EX_LIB) $($($u)_EX_UOLIB))))
endef
##############################################################################
define create_subdir_init
  for d in `find $1 -mindepth 1 -name '*' -type d` ; do \
    [ -e $$d/__init__.py ] || $(CMD_echo) "#Automatically created by SCRAM" > $$d/__init__.py ;\
  done
endef
define create_package_init
  $(CMD_echo) "#Automatically created by SCRAM" > $@ &&\
  $(CMD_echo) "import os" >> $@ &&\
  $(CMD_echo) "__path__.append(os.path.dirname(os.path.abspath(__file__).rsplit('/$(1)/',1)[0])+'/$(SCRAMSTORENAME_CFIPYTHON)/$(1)')" >> $@
endef
define create_subsystem_init
  if [ "X${RELEASETOP}" = "X" ] ; then \
    $(CMD_echo) "import os" > $@ ;\
    $(CMD_echo) "localrt=os.getenv('LOCALRT', None)" >> $@ ;\
    $(CMD_echo) "if localrt != None:__path__.insert(0,localrt+'/$(@D)')" >> $@ ;\
  else \
    $(CMD_echo) "__path__.append('${RELEASETOP}/$(@D)')" > $@ ;\
  fi
endef
#############################################################################
define SubSystem
.PHONY: $(1) $(SCRAM_SOURCEDIR)/$(1) $(2) all_$(2) runtests_$(2) unittests_$(2) compile_$(2) precompile_$(2) edm_checks_$(2)
ifneq ($(strip $(SCRAM_IGNORE_PACKAGES)),)
subdirs_$(2) := $$(filter-out $$(addprefix $(SCRAM_SOURCEDIR)_,$$(subst /,_,$(SCRAM_IGNORE_PACKAGES))),$$(subdirs_$(2)))
endif
$(1) $(SCRAM_SOURCEDIR)/$(1) $(2) all_$(2): $$(subdirs_$(2))
	@$(CMD_echo) ">> Subsystem $(1) built"
runtests_$(2): $$(addprefix runtests_,$$(subdirs_$(2)))
	@:
unittests_$(2): $$(addprefix unittests_,$$(subdirs_$(2)))
	@:
runpython_$(2): $$(addprefix runpython_,$$(subdirs_$(2)))
	@:
compile_$(2): $$(addprefix compile_,$$(subdirs_$(2)))
	@:
precompile_$(2): $$(addprefix precompile_,$$(subdirs_$(2)))
	@:
edm_checks_$(2): $$(addprefix edm_checks_,$$(subdirs_$(2)))
	@:
$(SCRAMSTORENAME_PYTHON)/$1/__init__.py: $(SCRAMSTORENAME_PYTHON)/__init__.py
	@[ -d $$(@D) ] || $(CMD_mkdir) $$(@D) && $$(call create_subsystem_init)
endef
define EmptyPackage
$(1)_libdeps      := $$(call libdeps,$1)
$(1)_CONFIGDEPS := $(CONFIGDEPS) $$(sort $$(foreach u,$$(sort $($(1)_LOC_USE) $($(1)_EX_USE)),$$($$($$(u))_XDEPS) $$(if $$($$($$(u))_BuildFile),$$($$($$(u))_BuildFile),$$(filter $(SCRAM_TOOLS_DIR)/$$(u),$(ToolTimeStamps)))))
ifneq ($$(strip $($(1)_BuildFile)),)
ALL_BUILDFILES += $($(1)_BuildFile)
$($(1)_BuildFile): $$($(1)_CONFIGDEPS)
	@$(CMD_touch) $($(1)_BuildFile)
endif
$(WORKINGDIR)/cache/prod/lib$(1): $($(1)_BuildFile) $$($(1)_libdeps)
	@$(CMD_touch) $$@
endef
define Package
.PHONY: $(1) $(SCRAM_SOURCEDIR)/$(1) $(2) all_$(2) runtests_$(2) unittests_$(2) compile_$(2) precompile_$(2) edm_checks_$(2)
ifeq ($(strip $(BUILD_LOG)),yes)
logfile_$(2) := $(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR)/$(1)/build.log
redirectlog_$(2) := >> $(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR)/$(1)/build.log
else
logfile_$(2) := 
redirectlog_$(2) := 
endif
ifneq ($(strip $(SCRAM_IGNORE_SUBDIRS)),)
subdirs_$(2) := $$(filter-out $$(addprefix $(2)_,$(SCRAM_IGNORE_SUBDIRS)),$$(subdirs_$(2)))
endif
$(WORKINGDIR)/cache/msg/$(SCRAM_SOURCEDIR)/$(1).msg: $$(logfile_$(2)) FORCE_TARGET
	@$(DO_BUILD_LOG) $(CMD_echo) ">> Entering Package $(1)" $$(redirectlog_$(2)) &&\
	$(CMD_echo) ">> Entering Package $(1)" $(if $(HOOK_PACKAGE), && $(HOOK_PACKAGE) -s -p $1 $(if $(KEEP_ON_BUILDING), || $(CMD_true)))
	@[ -d $$(@D) ] || $(CMD_mkdir) -p $$(@D) && $(CMD_touch) -t $(OLD_TIMESTAMP) $$@
$(1) $(SCRAM_SOURCEDIR)/$(1) $(2) all_$(2): $(if $(POISON_EDMPLUGIN_CACHE),$(WORKINGDIR)/$(SCRAM_SOURCEDIR)/$(1)/AUTOCLEAN.poison_edmplugin.clean) $(WORKINGDIR)/cache/msg/$(SCRAM_SOURCEDIR)/$(1).msg $$(addprefix all_,$$(subdirs_$(2))) $(SCRAMSTORENAME_PYTHON)/$(1)/__init__.py
	$$(call outputlog,$(1),$(2))
	@$(DO_BUILD_LOG) $(CMD_echo) ">> Leaving Package $(1)"  $$(redirectlog_$(2)) &&\
	$(DO_BUILD_LOG) $(CMD_echo) ">> Package $(1) built" $$(redirectlog_$(2)) &&\
	$(DO_BUILD_LOG) $(CMD_cat) $(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR)/$(1)/build.log &&\
	$(CMD_echo) ">> Leaving Package $(1)" &&\
	$(CMD_echo) ">> Package $(1) built" $(if $(HOOK_PACKAGE), && $(HOOK_PACKAGE) -e -p $1 $(if $(KEEP_ON_BUILDING), || $(CMD_true)))
$(SCRAMSTORENAME_CFIPYTHON)/$(1)/.scram: $(SCRAMSTORENAME_PYTHON)/$(1)/__init__.py
	@[ -d $$(@D) ] || $(CMD_mkdir) -p $$(@D) && $(CMD_touch) $$@
ifeq ($(strip $(origin $2_python_parent)),undefined)
$(SCRAMSTORENAME_PYTHON)/$(1)/__init__.py: $(SCRAMSTORENAME_PYTHON)/$(dir $1)__init__.py
	@[ -L $$(@D) ] && $(CMD_rm) -f $$(@D) &&\
	[ -d $$(@D) ] || $(CMD_mkdir) -p $$(@D) &&\
	$$(call create_package_init,$1)
else
$(SCRAMSTORENAME_PYTHON)/$(1)/__init__.py: $(SCRAMSTORENAME_PYTHON)/$(dir $1)__init__.py $(SCRAM_SOURCEDIR)/$1/python/__init__.py
	@[ -d $$(@D) ] && $(CMD_rm) -rf $$(@D) &&\
	[ -e $$(@D) ] || $(CMD_ln) -s ../../$(SCRAM_SOURCEDIR)/$1/python $(SCRAMSTORENAME_PYTHON)/$1
endif
$(SCRAM_SOURCEDIR)/$(1)/python/__init__.py:
	@$$(call create_package_init,$1) &&\
	[ -d $(WORKINGDIR)/$$(@D) ] || $(CMD_mkdir) -p $(WORKINGDIR)/$$(@D) &&\
	$(CMD_echo) "01:$(CMD_rm) -f $$(@D)/__init__.py $$(@D)/__init__.pyc" > $(call AutoCleanFile,$(WORKINGDIR)/$$(@D)/__init__.py,python)
ifeq ($$(filter $(2)_test,$$(subdirs_$(2))),$(2)_test)
runtests_$(2): $(2) runtests_$(2)_test
	@$(CMD_echo) ">> Tests for package $(1) ran."
unittests_$(2): unittests_$(2)_test
	@$(CMD_echo) ">> Tests for package $(1) ran."
endif
precompile_$(2): $$(addprefix precompile_,$$(subdirs_$(2)))
	@:
compile_$(2): $$(addprefix compile_,$$(subdirs_$(2)))
	@:
edm_checks_$(2): $$(addprefix edm_checks_,$$(subdirs_$(2)))
	@:
ifeq ($$(filter $(2)_python,$$(subdirs_$(2))),$(2)_python)
runpython_$(2): runpython_$(2)_python
	@$(CMD_echo) ">> Python for package $(1) ran."
endif
endef

define addPlugin
$(2)_pluginname    := $(1)
ALL_$(3)_PLUGINS   += $(1)
$(1)_plugintype    := $(3)
$(1)_no_lib_copy   := $(4)
$(1)_plugindir     := $(5)
$(1)_pluginrefresh := $(6)
$(1)_plugincache   := $(7)
$(1)_pluginprod    := $(5)/$(8)
$(1)_pluginlib     := $($(2)_objdir)/$(MODULE_PREFIX)$(1).$(SHAREDSUFFIX)
all_$(2)           += $(5)/$(8)
$(1)_extra_deps    += $(if $(strip $(6)),$(WORKINGDIR)/cache/prod/$(6),)
$(1)_package       := $(subst $(space),/,$(wordlist 2,3,$(subst /,$(space),$(10))))
$$($(1)_package)_$(3)_plugins += $(1)
ifndef SCRAM_NOEDMWRITECONFIG
ifeq ($$(strip $(3)),edm)
$(1)_extra_deps    += $(WORKINGDIR)/cache/prod/$(EDM_WRITE_CONFIG) $(SCRAMSTORENAME_CFIPYTHON)/$$($(1)_package)/.scram
endif
endif
$(5)/$(8): $$($(1)_pluginlib) $$($(1)_extra_deps)
	$$(call $(3)_register_plugin,$(1),$(9))
endef

ifeq ($(strip $(SCRAM_MULTIPLE_COMPILERS)-$(SCRAM_COMPILER)),yes-$(LLVM_ANALYZER))
define CXXCompileRule
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.$(2) $($(1)_objdir)/precompile FORCE_LLVM_CHECK
	$$(call analyze_cxx,$(1),$(3))
endef
define CCompileRule
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.$(2) $($(1)_objdir)/precompile FORCE_LLVM_CHECK
	$$(call analyze_c,$(1),$(3))
endef
else
define CXXCompileRule
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.$(2) $($(1)_objdir)/precompile
	$$(call compile_cxx$(4),$(1),$(3))
endef
define CCompileRule
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.$(2) $($(1)_objdir)/precompile
	$$(call compile_c$(4),$(1),$(3))
endef
endif

define F77CompileRule
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.$(2) $$($(1)_objdir)/precompile
	$$(call compile_fortran$(4),$(1),$(3))
endef

define CudeCompileRule
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.$(2) $$($(1)_objdir)/precompile
	$$(call compile_cuda,$(1),$(3))
endef

define EmptyProduct
.PHONY: $(1) all_$(1) $(2) all_$(2)
$(1) $(2): all_$(1)
	@:
endef

define LogFile
startlog_$(1) = $$(FORCE_BUILD_START)
endlog_$(1)   = $$(FORCE_BUILD_END)
ifeq ($$(strip $$(BUILD_LOG)),yes)
redirectlog_$(1) := >> $(WORKINGDIR)/cache/log/$(2)/$(1)
startlog_$(1) += (
endlog_$(1)   += ) $$(redirectlog_$(1)) 2>&1
logfile_$(1)  := $(WORKINGDIR)/cache/log/$(2)/$(1)
else
logfile_$(1)     := 
redirectlog_$(1) := 
endif
endef

#safename,path,safepath,scriptstore,scripts,binstore
define CommonBinaryHead
$(3)          += all_$(1)
$(eval $(call LogFile,$(1),$(2)))
.PHONY: $(1) all_$(1)
$(1)_objdir := $(WORKINGDIR)/$(2)/$(1)
$(1)_srcdir       := $(LOCALTOP)/$(2)
$(1)_cudafiles    := $$(filter $(foreach e,$(CUDASRC_FILES_SUFFIXES),%.$e),$($(1)_files))
ifneq ($(strip $$($(1)_cudafiles)),)
$(1)_cudaobj      := $$($(1)_objdir)/$(1)_scramcuda.$(OBJEXT)
endif
$(1)_files        := $$(filter-out $($(1)_SKIP_FILES), $($(1)_files))
$(1)_prodsrc      := $$(addprefix $(patsubst src/%,%,$2),$$($(1)_files))
$(1)_files_exts   := $$(sort $$(patsubst .%,%,$$(suffix $$($(1)_files))))
$(1)_LOC_USE      += $$(if $$(strip $$(filter $(FORTRANSRC_FILES_SUFFIXES),$$($(1)_files_exts))),$(F77_TYPE_COMPILER),)
$(1)_LOC_USE      += $$(if $$(strip $$(filter $(CUDASRC_FILES_SUFFIXES),$$($(1)_files_exts))),$(CUDA_TYPE_COMPILER),)
$(1)_libdeps      := $$(call libdeps,$1)
$(1)_objs         := $$(addprefix $$($(1)_objdir)/, $$(addsuffix .$(OBJEXT), $$(basename $$($(1)_files)))) $$($(1)_cudaobj)
ifneq ($(strip $(5)),)
.PHONY: $(1)_install_scripts_rule
$(1)_install_scripts_rule: $(logfile_$(1))
	$$(call copy_src_scripts,$(2),$(1),$(5),$(4))
all_$(1) += $(1)_install_scripts_rule
endif
$(1)_CONFIGDEPS := $(CONFIGDEPS) $(WORKINGDIR)/$(2)/productautocleanup $$(sort $$(foreach u,$$(sort $$($(1)_LOC_USE) $($(1)_EX_USE)),$$($$($$(u))_XDEPS) $$(if $$($$($$(u))_BuildFile),$$($$($$(u))_BuildFile),$$(filter $(SCRAM_TOOLS_DIR)/$$(u),$(ToolTimeStamps)))))
ifneq ($$(strip $($(1)_BuildFile)),)
ifeq ($(filter $($(1)_BuildFile),$(ALL_BUILDFILES)),)
ALL_BUILDFILES += $($(1)_BuildFile)
$($(1)_BuildFile): $$($(1)_CONFIGDEPS)
	@$(CMD_touch) $($(1)_BuildFile)
endif
$$($(1)_objdir)/config: $($(1)_BuildFile)
	@$$(call BuildClean,$(2)/$(1),0[0-9],1); $(CMD_mkdir) -p $$(@D) ; $(CMD_touch) $$@
else
$$($(1)_objdir)/config: $$($(1)_CONFIGDEPS)
	@$$(call BuildClean,$(2)/$(1),0[0-9],1); $(CMD_mkdir) -p $$(@D) ; $(CMD_touch) $$@
endif
$(1)_config += $(WORKINGDIR)/cache/msg/$(2)/$(1).msg $$($(1)_objdir)/config $(if $(strip $(filter $($(3)_parent),$(ALL_PACKAGES))),$(WORKINGDIR)/cache/msg/$(SCRAM_SOURCEDIR)/$($(3)_parent).msg,)
endef

#safename,path,productstore,type,logprodstore,safepath
define CommonBinaryTail
$(eval $($(1)_PRE_INIT_FUNC))
ifneq ($(strip $($(1)_cudaobj)),)
$($(1)_cudaobj): $$(addprefix $($(1)_objdir)/, $(addsuffix .$(OBJEXT), $(basename $($(1)_cudafiles))))
	$$(call link_cuda_objs,$1)
endif
ifneq ($(strip $($(1)_objs)),)
$$(eval $$(call AddBigObjRule,$1,$2))
ALL_$(4)_PRODUCTS += $(1)
$(1):  $($(1)_objdir)/$($(1)_product)
$($(1)_objdir)/$($(1)_product): $($(1)_objdir)/compile $($(1)_libdeps)
ifeq ($(strip $(4)),lib)
	$$(call link_lib$($(1)_BUILDRULES),$(1),$(1),$(3),$($(1)_pluginname))
	@$$(startlog_$(1)) $(if $(HOOK_PRODUCT),$(HOOK_PRODUCT) -e -p $1,$(CMD_true)) $$(endlog_$(1))
	@$$(startlog_$(1))$(CMD_echo) "Leaving library rule at $(patsubst src/%/src,%,$(2))" $$(endlog_$(1))
endif
ifeq ($(strip $(4)),bin)
	$$(call build_bin,$(1),$(1),$(3))
endif
ifeq ($(strip $(4)),python)
	$$(call link_pylib,$(1),$(1),$(3))
endif
ifeq ($(strip $(4)),test)
	$$(call build_test,$(1),$(1),$(3))
.PHONY: runtests_$(1) unittests_$(1)
ifeq ($(strip $(filter $(1),$(SKIP_UNITTESTS))),$(1))
$(1)_NO_TESTRUN := yes
endif
runtests_$(6) += runtests_$(1)
unittests_$(6) += unittests_$(1)
runtests_$(1): all_$(1) $(patsubst %,runtests_%,$($(1)_PRE_TEST)) unittests_$(1)
	@:
unittests_$(1): $(patsubst %,unittests_%,$($(1)_PRE_TEST)) $(LOCALTOP)/$(5)/testing.log
	$$(call run_test,$(1),$(3),$(5),$(2))
endif
.PHONY: precompile_$(6) compile_$(6)
ifneq ($(strip $(4)$($(1)_files)),test1)
ifneq ($(strip $($(1)_CLASSES_DEF_XML) $($(1)_CLASSES_DEF_XML)),)
edm_checks_$(6) += $(WORKINGDIR)/edm_checks/$($(1)_product)
$(WORKINGDIR)/edm_checks/$($(1)_product): $($(1)_objdir)/$($(1)_product)
	@$$(startlog_$(1)) [ -d $$(@D) ] || $(CMD_mkdir) -p $$(@D) $$(call run_edm_checks,$1,$1,$(3),$($(1)_pluginname)) && touch $$@ $$(endlog_$(1))
endif
$(WORKINGDIR)/cache/prod/$(1): $($(1)_objdir)/$($(1)_product)
	@if [ ! -f $$@ ] ; then $(CMD_touch) $$@; fi
ifneq ($(strip $($(1)_product)),)
ifneq ($(wildcard $($(1)_objdir)/$($(1)_product).dep),)
-include $($(1)_objdir)/$($(1)_product).dep
endif
endif
$(WORKINGDIR)/cache/msg/$(2)/$(1).msg: $(logfile_$(1)) FORCE_TARGET
	@$$(startlog_$(1))[ -d $$(@D) ] || $(CMD_mkdir) -p $$(@D) && $(CMD_touch) -t $(OLD_TIMESTAMP) $$@ $(if $(HOOK_PRODUCT), && $(HOOK_PRODUCT) -s -p $1) $$(endlog_$(1))
precompile_$(6):: $($(1)_objdir)/precompile $($(1)_extra_files)
	@:
compile_$(6):: $($(1)_objdir)/compile
	@:
$($(1)_objdir)/precompile: $($(1)_config) $($(1)_precompile) $(logfile_$(1))
	@$(CMD_touch) $$@
ifeq ($(strip $(4)),lib)
	@$(startlog_$(1))$(CMD_echo) "Entering library rule at $(patsubst src/%/src,%,$(2))" $(endlog_$(1))
endif
$($(1)_objdir)/compile: $($(1)_objdir)/precompile $($(1)_objs) $($(1)_compile)
	@$(CMD_touch) $$@
$($(1)_objdir)/link: $($(1)_objdir)/compile $($(1)_objdir)/$($(1)_product) $($(1)_link)
	@$(CMD_touch) $$@
	@$(CMD_echo) "$1 $$($(1)_prodsrc)" > $$(@D)/scram-prod2src.txt
all_$(1): $($(1)_objdir)/link $$(all_$(1))
	@:
else
precompile_$(6)::
	@:
compile_$(6)::
	@:
endif
endif
endef

define FindBuildFile
$(if $(wildcard $(1).xml),$(1).xml,$(1))
endef

define MultipleWarningMsg
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(call $$(multipletools),****WARNING: Multiple products with same name $(1))
$$(call $$(multipletools),             Previous defination: $($(1)))
$$(call $$(multipletools),             Current  defination: $(2))
endif
endef

define ProductWithNoFiles
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(info ****WARNING: Skipped building of $(1) from $$(call FindBuildFile,$(2)/$(SCRAM_BUILDFILE)) because)
ifeq ($(strip $(3)),)
$$(info $$(space)             there are no files mentioned in the this Buildfile)
else
$$(info $$(space)             \"$(3)\" does not match any file under $(2) directory)
endif
endif
endef

define UseError
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(call $$(wrongtool),****WARNING: Invalid tool $(1). Please fix $$(call FindBuildFile,$$(subst tmp/$(SCRAM_ARCH)/cache/bf/,,$2)) file.)
endif
endef

#safename
define CompileRules
$(foreach ext,$(filter $(CXXSRC_FILES_SUFFIXES),    $($(1)_files_exts)),$(eval $(call CXXCompileRule,$(1),$(ext),$(1),$($(1)_BUILDRULES))))
$(foreach ext,$(filter $(CSRC_FILES_SUFFIXES),      $($(1)_files_exts)),$(eval $(call CCompileRule,$(1),$(ext),$(1),$($(1)_BUILDRULES))))
$(foreach ext,$(filter $(FORTRANSRC_FILES_SUFFIXES),$($(1)_files_exts)),$(eval $(call F77CompileRule,$(1),$(ext),$(1))))
$(if $(strip $(CUDASRC_FILES_SUFFIXES)),$(foreach ext,$(filter $(CUDASRC_FILES_SUFFIXES),$($(1)_files_exts)),$(eval $(call CudeCompileRule,$(1),$(ext),$(1)))))
endef

#safename,path,safepath,scriptstore,scripts,productstore,type,logprodstore
define Binary
$$(eval $$(call CommonBinaryHead,$(1),$(2),$(3),$(4),$(5)))
ALL_BINARIES += $(1)
$(1)_product := $(1)
$$(eval $$(call CommonBinaryTail,$(1),$(2),$(6),$(7),$(8),$(3)))
$$(eval $$(call CompileRules,$(1)))
endef

#safename,path,safepath,scriptstore,scripts,libstore,logprodstore
define Library
$(eval $(call LibraryHead,$(1),$(2),$(3),$(4),$(5)))
$(eval $(call LibraryTail,$(1),$(2),$(6),$(7),$(3)))
endef

#safename,path,safepath,scriptstore,scripts
define LibraryHead
$(eval $(call CommonBinaryHead,$(1),$(2),$(3),$(4),$(5)))
$(1)_product      := $(MODULE_PREFIX)$(1).$(SHAREDSUFFIX)
endef

#safename,path,libstore,logprodstore,safepath
define LibraryTail
$(eval $(call CommonBinaryTail,$(1),$(2),$(3),lib,$(4),$(5)))
ifneq ($$(strip $$($(1)_objs)),)
ALL_LIBRARIES += $(1)
$(WORKINGDIR)/cache/prod/lib$(1): $($(1)_objdir)/$($(1)_product)
	@:
$$(eval $$(call CompileRules,$(1)))
$$(eval $$(call AddBigObjCompileRule,$1))
else
$(1) all_$(1): $$(all_$(1))
	@:
endif
endef

define AddExtraPythonProdRule
$(if $(2),$(eval $(call ExtraPythonProd,$(1),$(firstword $(2)),$(firstword $(3))))$(eval $(call AddExtraPythonProdRule,$(1),$(wordlist 2,100,$(2)),$(wordlist 2,100,$(3)))),)
endef

define ExtraPythonProd
all_$(1)_extra_python_prod += $(3)/$(2)
$(3)/$(2): $(2) $(1)_copy_python_scripts $($(1)_CONFIGDEPS)
	@$(CMD_echo) ">> Copying python products \"$(2)\" => $(3)"
	$$(call copy_python_products,$(1),$(logfile_$(1)),$(2),$(3))
endef

#safename,path,safepath,hasscripts,symlinkpython,pythonstore,xprodfiles,xproddirs
define PythonProductHead
$(3)          += all_$(1)
.PHONY: $(1) all_$(1) $(1)_copy_python_scripts $(WORKINGDIR)/$2/init_links
$(eval $(call LogFile,$(1),$(2)))
$(1)_objdir       := $(WORKINGDIR)/$(2)/$(1)
$(1)_python_dir := $(addprefix $(6)/,$(patsubst $(SCRAM_SOURCEDIR)/%/python,%,$(2)))
$(1)_files        := $$(filter-out $($(1)_SKIP_FILES), $($(1)_files))
$(1)_files_exts   := $$(sort $$(patsubst .%,%,$$(suffix $$($(1)_files))))
$(1)_LOC_USE      += $$(if $$(strip $$(filter $(FORTRANSRC_FILES_SUFFIXES),$$($(1)_files_exts))),$(F77_TYPE_COMPILER),)
$(1)_CONFIGDEPS := $(CONFIGDEPS) $$(sort $$(foreach u,$$(sort $$($(1)_LOC_USE) $($(1)_EX_USE)),$$($$($$(u))_XDEPS) $$(if $$($$($$(u))_BuildFile),$$($$($$(u))_BuildFile),$$(filter $(SCRAM_TOOLS_DIR)/$$(u),$(ToolTimeStamps)))))
ifneq ($$(strip $($(1)_BuildFile)),)
ALL_BUILDFILES += $($(1)_BuildFile)
$($(1)_BuildFile): $$($(1)_CONFIGDEPS)
	@$(CMD_touch) $($(1)_BuildFile)
$$($(1)_objdir)/config: $($(1)_BuildFile)
	@$$(call BuildClean,$(2)/$(1),0[0-9],1); $(CMD_mkdir) -p $$(@D) ; $(CMD_touch) $$@
else
$$($(1)_objdir)/config: $$($(1)_CONFIGDEPS)
	@$$(call BuildClean,$(2)/$(1),0[0-9],1); $(CMD_mkdir) -p $$(@D) ; $(CMD_touch) $$@
endif
$(1)_config += $$($(1)_objdir)/config
all_$(1) += $(1)_copy_python_scripts
ifeq ($(strip $(PYTHON_PACKAGE_SYMLINK)),YES)
$(WORKINGDIR)/$2/init_links:
	@$$(call create_subdir_init,$2)
all_$(1) += $(WORKINGDIR)/$2/init_links $(SCRAMSTORENAME_PYTHON)/$(dir $(subst $(SCRAM_SOURCEDIR)/,,$(2)))__init__.py
endif
ifeq ($(strip $(4)),1)
$(1)_copy_python_scripts: $(logfile_$(1)) $$($(1)_CONFIGDEPS)
	@:
else
$(1)_copy_python_scripts: $(logfile_$(1))
	@$(CMD_echo) "No source files to compile. Nothing to be done for Python modules at $(2)."
endif
runpython_$(3): $(1)_copy_python_scripts
	@:
ifneq ($(strip $(7)),)
.PHONY: $(1)_extra_python_prod
all_$(1) += $(all_$(1)_extra_python_prod)
$(eval $(call AddExtraPythonProdRule,$(1),$(7),$(8)))
all_$(1) += $(all_$(1)_extra_python_prod)
endif
$(1)_srcdir       := $(LOCALTOP)/$(2)
$(1)_files        := $$(notdir $$(wildcard $$(foreach dir,$$($(1)_srcdir),$$(foreach ext,$(CXXSRC_FILES_SUFFIXES),$$(dir)/*.$$(ext)))))
$(1)_files        += $$(patsubst %.pyste,%_boost.cc,$$(notdir $$(wildcard $$($(1)_srcdir)/*.pyste)))
$(1)_files        := $$(filter-out $($(1)_SKIP_FILES),$$($(1)_files))
endef

define PythonProductFlags
$(1)_files        += $($(1)_objdir)/$(1)_PyWrapper.cc
$(1)_objs         := $$(addprefix $($(1)_objdir)/, $$(addsuffix .$(OBJEXT), $$(basename $$(notdir $$($(1)_files)))))
$(1)_PY_CXXFLAGS   = $$(filter-out -pedantic-errors -ansi, $$($(1)_CXXFLAGS))
$(1)_libdeps      := $$(call libdeps,$1)
$(1)_objs         := $$(addprefix $($(1)_objdir)/, $$(addsuffix .$(OBJEXT), $$(basename $$(notdir $$($(1)_files)))))
$(1)_classnames   := $$(patsubst %_boost,%,$$(filter %_boost,$$(basename $$(notdir $$($(1)_files)))))
$(1)_CXXSharedLink = -rdynamic $$($(1)_LDFLAGS)
endef

#safename,path,productstore,logprodstore,safepath
define PythonProductTail
$(1)_product := $(1).$(SHAREDSUFFIX)
$$(eval $$(call CommonBinaryTail,$(1),$(2),$(3),python,$(4),$(5)))
$$(eval $$(call CompileRules,$(1)))
.PRECIOUS: $($(1)_objdir)/%_boost.cc
$($(1)_objdir)/%_boost.cc: $($(1)_srcdir)/%.pyste $($(1)_config)
	$$(call pyste2boost,$(1),$(1))
$($(1)_objdir)/%_boost.o: $($(1)_srcdir)/%_boost.cc $($(1)_config)
	$$(call compile_boost,$(1),$(1))
$($(1)_objdir)/%_boost.o: $($(1)_objdir)/%_boost.cc
	$$(call compile_boost,$(1),$(1))
$($(1)_objdir)/$(1)_PyWrapper.o: $($(1)_objdir)/$(1)_PyWrapper.cc
	$$(call compile_pywrapper,$(1),$(1))
$($(1)_objdir)/$(1)_PyWrapper.cc: $($(1)_config)
	$$(call generate_pywrapper,$(1),$(1))
endef

#safename,path,safepath,hasscripts,symlinkpython,pythonstore,libstore,xprodfiles,xproddirs,logprodstore
define PythonProduct
$(eval $(call PythonProductHead,$(1),$(2),$(3),$(4),$(5),$(6),$(8),$(9)))
ifneq ($$(strip $$($(1)_files)),)
ifneq ($$(strip $$($(1)_BuildFile)),)
ifneq ($$(strip $$(filter boost_python,$($(1)_LOC_USE))),)
$$(eval $$(call PythonProductFlags,$(1)))
$$(eval $$(call PythonProductTail,$(1),$(2),$(7),$(10),$(3)))
else
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(info ****WARNING: Skipped building product $(1).$(SHAREDSUFFIX) due to missing boost_python tool selecting in $(2)/$(SCRAM_BUILDFILE))
endif
endif
else
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(info ****WARNING: Skipped building product $(1).$(SHAREDSUFFIX) due to missing $(2)/$(SCRAM_BUILDFILE))
endif
endif
endif
ifeq ($$(strip $$($(1)_product)),)
$(1) all_$(1): $(all_$(1))
	@:
endif
endef

define Src2StoreCopy
.PHONY: $(1) all_$(1)
$(1)_files := $(filter-out CVS $(SCRAM_BUILDFILE) $(SCRAM_BUILDFILE).xml $($(1)_SKIP_FILES), $($(1)_files))
$(1): all_$(1)
	@:
ifneq ($$(strip $$($(1)_files)),)
$(eval $(call LogFile,$(1),$(2)))
$(1)_installdir := $(3)
all_$(1): $(logfile_$(1))
	@$$(call clean_files,$($(1)_SKIP_FILES),$$($(1)_installdir))
	$$(call src2store_copy,$(2),$(1),$$($(1)_files),$$($(1)_installdir))
endif
endef

define CommonDataRules
.PHONY: $(1) all_$(1)
$(1) all_$(1): $($(1)_data_copy_rule)
endef

define CommonProductRules
.PHONY: $(1) all_$(1) edm_checks_$(1)
ifeq ($(strip $(3)),TEST)
.PHONY: runtests_$(1) unittests_$(1) 
$(1) += $($(1)_data_copy_rule)
runtests_$(1): $(1) $(runtests_$(1))
	@:
unittests_$(1): $(unittests_$(1))
	@:
endif
edm_checks_$(1): $(edm_checks_$(1))
	@:
$(1) all_$(1): $($(1))
	@:
endef

ifeq ($(strip $(CODE_ANALYSIS_RULES)),NO)
define AddMOC
$(1)_LOC_FLAGS_CPPFLAGS     += -I$($(1)_objdir)/moc
$(1)_FILE_MOC	  := $(foreach suffix,h cc cpp cxx,$(patsubst %.$(suffix),%_$(suffix)_moc.cc,$(filter %.$(suffix),$(2))))
$(1)_FILE_MOC_SRC := $$(filter %_cc_moc.cc %_cpp_moc.cc %_cxx_moc.cc, $$($(1)_FILE_MOC))
$(1)_FILE_MOC_INC := $(filter-out $$($(1)_FILE_MOC_SRC),$$($(1)_FILE_MOC))
$(1)_files        += $$($(1)_FILE_MOC_INC)
$(1)_objs         += $$(addprefix $($(1)_objdir)/moc/, $$(addsuffix .$(OBJEXT), $$(basename $$(notdir $$($(1)_FILE_MOC_INC)))))
$(1)_extra_files   += $($(1)_objdir)/moc/run_moc
$($(1)_objdir)/moc/run_moc: $$(addprefix $($(1)_objdir)/moc/, $$($(1)_FILE_MOC))
	@[ -f $$@ ] || $(CMD_touch) $$@
$($(1)_objdir)/moc/%.$(OBJEXT):  $($(1)_objdir)/moc/%.cc
	$$(call compile_cxx,$(1),$(1))
$($(1)_objdir)/moc/%_h_moc.cc:   $(3)/%.h   $($(1)_config)
	$$(call generate_moc,$(1),$(1),$($(5))/bin/moc)
$($(1)_objdir)/moc/%_h_moc.cc:   $(4)/%.h   $($(1)_config)
	$$(call generate_moc,$(1),$(1),$($(5))/bin/moc)
$($(1)_objdir)/moc/%_cc_moc.cc:  $(4)/%.cc  $($(1)_config)
	$$(call generate_moc,$(1),$(1),$($(5))/bin/moc)
$($(1)_objdir)/moc/%_cpp_moc.cc: $(4)/%.cpp $($(1)_config)
	$$(call generate_moc,$(1),$(1),$($(5))/bin/moc)
$($(1)_objdir)/moc/%_cxx_moc.cc: $(4)/%.cxx $($(1)_config)
	$$(call generate_moc,$(1),$(1),$($(5))/bin/moc)
endef

define addPCMRule
ifeq ($(strip $(GENERATE_ROOT_PCMS)),yes)
all_$(1)  += $(4)/$(2)r_rdict.pcm
$(3)/$(2)r_rdict.pcm: $(3)/$(2)r.cc
	@[ -f $$< ] || $(CMD_rm) -f $$@
$(4)/$(2)r_rdict.pcm: $(3)/$(2)r_rdict.pcm
	@if [ -f $$< ] ; then \
	  $(CMD_cp) $$< $$@ &&\
	  $(CMD_echo) "01:$(CMD_rm) -f $$@" > $$(call AutoCleanFile,$$<,prod) ;\
	else \
	  $(CMD_rm) -f $$@;\
	fi
endif
endef

#safename,linkdefs,subdir,prodstore,rootdicts
define AddRootDictRule
$(if $(2),$(eval $(call RootDictRule,$(1),$(ROOTDICT_FILE_PREFIX)$(firstword $(2)),$(firstword $(3)),$(4),$(5)))$(eval $$(call AddRootDictRule,$(1),$(wordlist 2,100,$(2)),$(wordlist 2,100,$(3)),$(4),$(5))),)
endef

#safename,rootdict,linkdef,subdir,prodstore
define RootDictRule
$(1)_files  := $($(1)_objdir)/$(4)/$(2)r.cc $($(1)_files)
$(1)_objs   := $($(1)_objdir)/$(4)/$(2)r.$(OBJEXT) $($(1)_objs)
$(1)_extra_files += $($(1)_objdir)/$(4)/$(2)r.cc
.PRECIOUS: $($(1)_objdir)/$(4)/$(2)r.cc
$($(1)_objdir)/$(4)/$(2)r.cc: $(3) $($(1)_config)
	$$(call generate_rootdict,$(1),$(1))
$($(1)_objdir)/$(4)/$(2)r.$(OBJEXT): $($(1)_objdir)/$(4)/$(2)r.cc
	$$(call compile_rootdict,$(1),$(1),$(3))
$(eval $(call addPCMRule,$1,$2,$($(1)_objdir)/$(4),$(5)))
endef

#safename,path,linkdefs,prodstore
define RootDict
$(1)_LOC_FLAGS_CPPFLAGS     += -I$(LOCALTOP)/$(2)
$(eval $(call AddRootDictRule,$(1),$($(1)_ROOTDICTS),$(addprefix $2/,$(3)),b,$(4)))
endef

#safename,$path,$file
define CondSerialization
ifneq ($$(strip $$(COND_SERIALIZATION_SCRIPT)),)
$(1)_LOC_FLAGS_CPPFLAGS     += -I$(LOCALTOP)/$(2)
$(1)_files                  += $($(1)_objdir)/a/Serialization.cc
$(1)_objs                   += $($(1)_objdir)/a/Serialization.$(OBJEXT)
.PRECIOUS: $($(1)_objdir)/a/Serialization.cc
$(1)_extra_files += $($(1)_objdir)/a/Serialization.cc
$($(1)_objdir)/a/Serialization.cc: $3 $($(1)_config) $$(COND_SERIALIZATION_SCRIPT)
	$$(call generate_CondSerialization,$(1),$(1),$(2))
$($(1)_objdir)/a/Serialization.$(OBJEXT): $($(1)_objdir)/a/Serialization.cc
	$$(call compile_cxx,$(1),$(1))
	@$(startlog_$(1)) $$(call processTmpMMDData,$$<,$$@,$3) $(endlog_$(1))
endif
endef

#safename,path,file,pack
define PreCompileHeader
$(if $(strip $(wildcard $($(1)_objdir)/$(3).d)),$(eval -include $($(1)_objdir)/$(3).d))
all_$(1) += $(SCRAMSTORENAME_INCLUDE)/$(SCRAM_ARCH)/$(4)/$(3).$(PRECOMPILE_EXTENSION) $(SCRAMSTORENAME_INCLUDE)/$(SCRAM_ARCH)/$(4)/$(3).$(PRECOMPILE_FLAGS_EXTENSION)
$(SCRAMSTORENAME_INCLUDE)/$(SCRAM_ARCH)/$(4)/$(3).$(PRECOMPILE_EXTENSION): $($(1)_objdir)/$(3).$(PRECOMPILE_EXTENSION)
	@if [ -f $$< ] ; then \
	  [ -d $$(@D) ] ||  $(CMD_mkdir) -p $$(@D) &&\
	  $(CMD_cp) $$< $$@ &&\
	  $(CMD_echo) "01:$(CMD_rm) -f $$@" > $$(call AutoCleanFile,$$<,prod) ;\
	else \
	  $(CMD_rm) -f $$@;\
	fi
$(SCRAMSTORENAME_INCLUDE)/$(SCRAM_ARCH)/$(4)/$(3).$(PRECOMPILE_FLAGS_EXTENSION): $($(1)_objdir)/$(3).$(PRECOMPILE_EXTENSION)
	@if [ -f $$<.$(PRECOMPILE_FLAGS_EXTENSION) ] ; then \
	  [ -d $$(@D) ] ||  $(CMD_mkdir) -p $$(@D) &&\
	  $(CMD_cp) $$<.$(PRECOMPILE_FLAGS_EXTENSION) $$@ &&\
	  $(CMD_echo) "01:$(CMD_rm) -f $$@" > $$(call AutoCleanFile,$$<.$(PRECOMPILE_FLAGS_EXTENSION),prod) ;\
	else \
	  $(CMD_rm) -f $$@;\
	fi
$($(1)_objdir)/$(3).$(PRECOMPILE_EXTENSION): $(2)/$(3) $($(1)_objdir)/precompile
	$$(call generate_PreCompileHeader,$(1),$(1))
endef

#safename,hfiles,defxmlfiles,prodstore,genreflexargs,Cababilities
ifeq ($(strip $(NO_CAPABILITIES)),)
define LCGDict
$(1)_prodsrc += $(patsubst src/%,%,$2 $3)
$(1)$(6)_GENREFLEX_ARGS := $(5)
$(eval $(call AddLCGDictRule,$(1),$(2),$(3),$(1)$(6),a,$(4),$($(1)_LCGDICTS)))
$(eval $(call AddSealCapabilitiesRule,$(1),$(1)$(6),a/))
ifneq ($(strip $(6)),)
ALL_CLASS_VERSION_RULES += $($(1)_objdir)/updateclassversion
ifneq ($(strip $(UPDATE_CLASSVERSION)),)
all_$(1)       += $($(1)_objdir)/updateclassversion
$($(1)_objdir)/updateclassversion: $($(1)_objdir)/$(MODULE_PREFIX)$(1)$(6).$(SHAREDSUFFIX)
	@$(CMD_touch) $$@
endif
$$(eval $$(call LCGDictLibRule,$1,$4,$6,$3,$($(1)_objdir),$$($(1)$(6)_objs)))
endif
endef
else
define LCGDict
$(1)_prodsrc += $(patsubst src/%,%,$2 $3)
$(1)$(6)_GENREFLEX_ARGS := $(5)
$(1)_CLASSES_DEF_XML:=$3
$(eval $(call AddLCGDictRule,$(1),$(2),$(3),$(1)$(6),a,$(4),$($(1)_LCGDICTS)))
ALL_CLASS_VERSION_RULES += $($(1)_objdir)/updateclassversion
ifneq ($(strip $(UPDATE_CLASSVERSION)),)
all_$(1)       += $($(1)_objdir)/updateclassversion
$($(1)_objdir)/updateclassversion: $($(1)_objdir)/$(MODULE_PREFIX)$(1).$(SHAREDSUFFIX)
	@$(CMD_touch) $$@
endif
endef
endif

#safename,prodstore,Capabilities,defxmlfiles,objdir,objs,
define LCGDictLibRule
ALL_lib_PRODUCTS += $(1)$(3)
all_$(1)  += $(5)/$(MODULE_PREFIX)$(1)$(3).$(SHAREDSUFFIX)
$(5)/$(MODULE_PREFIX)$(1)$(3).$(SHAREDSUFFIX): $6 $(WORKINGDIR)/cache/prod/lib$(1)
	$$(call link_lib_capabilities,$(1),$(1),$(2),$(1)$(3),$(6),$(4))
endef

define AddLCGDictRule
$(if $(2),$(eval $(call LCGDictRule,$(1),$(LCGDICT_FILE_PREFIX)$(firstword $(7)),$(firstword $(2)),$(firstword $(3)),$(4),$(5),$(6)))$(eval $$(call AddLCGDictRule,$(1),$(wordlist 2,100,$(2)),$(wordlist 2,100,$(3)),$(4),$(5),$(6),$(wordlist 2,100,$(7)))),)
endef

define AddSealCapabilitiesRule
ifneq ($(strip $$($(2)_seal_cap)),)
$(1)_compile     += $($(1)_objdir)/$(3)seal_cap.$(OBJEXT)
$(2)_objs        += $($(1)_objdir)/$(3)seal_cap.$(OBJEXT)
$(1)_extra_files += $($(1)_objdir)/$(3)seal_cap.cc
$($(1)_objdir)/$(3)seal_cap.$(OBJEXT): $($(1)_objdir)/$(3)seal_cap.cc
	$$(call compile_cxx_capabilities,$(1),$(1))
$($(1)_objdir)/$(3)seal_cap.cc: $$($(2)_seal_cap)
	@($(CMD_echo) 'static  const char* clnames[] = {' ;\
	  $(CMD_cat) $$^ | $(CMD_grep) LCGReflex/ ;\
	  $(CMD_echo) '};' ;\
	  $(CMD_echo) 'extern "C" void SEAL_CAPABILITIES (const char**& names, int& n )' ;\
	  $(CMD_echo) '{names = clnames;n = sizeof(clnames)/sizeof(char*);}') > $$@
endif
endef

define LCGDictRule
$(1)_files  := $($(1)_objdir)/$(6)/$(2)r.cc        $($(1)_files)
$(1)_objs   := $($(1)_objdir)/$(6)/$(2)r.$(OBJEXT) $($(1)_objs)
$(1)_extra_files += $($(1)_objdir)/$(6)/$(2)r.cc
ifneq ($(strip $(filter $(LOCALTOP)/$(WORKINGDIR)/classes/%,$3)),)
$3: $4
	$$(call generate_classes_h)
endif
$($(1)_objdir)/$(6)/$(2)r.cc: $(4) $(3) $($(1)_config)
	$$(call generate_lcgdict,$(1),$(1),$(4),$(3),$(6)/$(2)i.cc,$(5))
$($(1)_objdir)/$(6)/$(2)r.$(OBJEXT): $($(1)_objdir)/$(6)/$(2)r.cc
	$$(call compile_lcgdict,$(1),$(1),$3)
$(eval $(call AddBigObjLCGDICTRule,$1,$(6)/$(2)))
ifeq ($(strip $(GENERATE_ROOT_PCMS)),yes)
all_$(1)  += $(7)/$(2)r_rdict.pcm
$(1)_libdeps += $(7)/$(2)r_rdict.pcm
$($(1)_objdir)/$(6)/$(2)r_rdict.pcm: $($(1)_objdir)/$(6)/$(2)r.cc
	@[ -f $$< ] || $(CMD_rm) -f $$@
$(7)/$(2)r_rdict.pcm: $($(1)_objdir)/$(6)/$(2)r_rdict.pcm
	@if [ -f $$< ] ; then \
	  $(CMD_cp) $$< $$@ &&\
	  $(CMD_echo) "01:$(CMD_rm) -f $$@" > $$(call AutoCleanFile,$$<,prod) ;\
	else \
	  $(CMD_rm) -f $$@;\
	fi
all_$(1)  += $(7)/$(2)r.rootmap
$(1)_ROOTMAP_FILES += $(7)/$(2)r.rootmap
$(1)_libdeps += $(7)/$(2)r.rootmap
$($(1)_objdir)/$(6)/$(2)r.rootmap: $($(1)_objdir)/$(6)/$(2)r.cc
	@[ -f $$< ] || $(CMD_rm) -f $$@
$(7)/$(2)r.rootmap: $($(1)_objdir)/$(6)/$(2)r.rootmap
	@if [ -f $$< ] ; then \
	  $(CMD_cp) $$< $$@ &&\
	  $(CMD_echo) "01:$(CMD_rm) -f $$@" > $$(call AutoCleanFile,$$<,prod) ;\
	else \
	  $(CMD_rm) -f $$@;\
	fi
endif
ifeq ($(strip $(NO_CAPABILITIES)),)
ifneq ($1,$5)
$(5)_seal_cap    += $($(1)_objdir)/$(6)/$(2)i.cc
$($(1)_objdir)/$(6)/$(2)i.cc: $($(1)_objdir)/$(6)/$(2)r.cc
	@[ -f $$< ] || $(CMD_rm) -f $$@
endif
endif
endef

#safename,path,lexyacc,parseyacc,
define LexYACC
$(1)_lex_files     :=  $(3)
$(1)_yacc_files    :=  $(4)
$(1)_generated_hdr := $$(addprefix $($(1)_objdir)/, $$(addsuffix .h,  $$(basename $$(notdir $$($(1)_yacc_files)))))
$(1)_generated_src := $$(addprefix $($(1)_objdir)/, $$(addsuffix .cc, $$(basename $$(notdir $$($(1)_lex_files)))))
$(1)_generated_src += $$(addprefix $($(1)_objdir)/, $$(addsuffix .cc, $$(basename $$(notdir $$($(1)_yacc_files)))))
ifneq ($$(strip $$($(1)_generated_src)),)
$(1)_LOC_FLAGS_CPPFLAGS  += -I$(LOCALTOP)/$(WORKINGDIR)/$(SCRAM_SOURCEDIR)
endif
$(1)_objs          += $$(patsubst %.cc,%.$(OBJEXT),$$($(1)_generated_src))
$(1)_extra_files    += $$($(1)_generated_src) $$($(1)_generated_hdr)
.PRECIOUS: $$($(1)_generated_src) $$($(1)_generated_hdr)
$($(1)_objdir)/%lex.cc: $($(1)_srcdir)/%lex.l $($(1)_config)
	$$(call generate_lex,$(1),$(1))
$($(1)_objdir)/%parse.cc $($(1)_objdir)/%parse.h: $($(1)_srcdir)/%parse.y $($(1)_config)
	$$(call generate_parse,$(1),$(1),$(2))
$($(1)_objdir)/%.$(OBJEXT): $($(1)_objdir)/%.cc $($(1)_objdir)/precompile
	$$(call compile_cxx,$(1),$(1))
endef

#safename,path,CODEGENPATH
define CodeGen
$(1)_CODEGENPY            := python $(3)/bin/codegen.py
$(1)_CODEGENTEMPLATES     := $(3)/templates
$(1)_codegen_object_names := $(foreach file,$(wildcard $(foreach dir,$($(1)_srcdir),$(dir)/*.desc.xml)),$(notdir $(patsubst %.desc.xml,%,$(file))))
$(1)_codegen_src := $$(addprefix $($(1)_objdir)/,$(foreach objname,$$($(1)_codegen_object_names), \
			$$(foreach suffix,.cpp .reg.cpp _T_Context.cpp,$$(objname)$$(suffix))))
$(1)_codegen_hdr := $$(addprefix $($(1)_objdir)/, $$(foreach objname,$$($(1)_codegen_object_names), \
			$$(foreach suffix,.h Record.h,$$(objname)$$(suffix))))
$(1)_codegen_rtvr_src :=$(addprefix $($(1)_objdir)/,$(1)Retriever.cpp)
$(1)_codegen_rtvr_hdr :=$(addprefix $($(1)_objdir)/,$(1)Retriever.h)
ifneq ($$(strip $$($(1)_codegen_src)),)
$(1)_LOC_FLAGS_CPPFLAGS  += -I$(LOCALTOP)/$(WORKINGDIR)/$(SCRAM_SOURCEDIR)
endif
ifneq ($$(strip $$($(1)_codegen_rtvr_src)),)
$(1)_LOC_FLAGS_CPPFLAGS  += -I$(LOCALTOP)/$(WORKINGDIR)/$(SCRAM_SOURCEDIR)
endif
$(1)_objs       += $$(patsubst %.cpp, %.$(OBJEXT), $$($(1)_codegen_src))
$(1)_objs       += $$(patsubst %.cpp, %.$(OBJEXT), $$($(1)_codegen_rtvr_src))
$(1)_extra_files += $$($(1)_codegen_src) $$($(1)_codegen_hdr)
$(1)_extra_files += $$($(1)_codegen_rtvr_src) $$($(1)_codegen_rtvr_hdr)
.PRECIOUS: $$($(1)_codegen_src) $$($(1)_codegen_hdr)
$($(1)_objdir)/%.h $($(1)_objdir)/%Record.h $($(1)_objdir)/%.cpp $($(1)_objdir)/%.reg.cpp $($(1)_objdir)/%_T_Context.cpp: $($(1)_srcdir)/%.desc.xml $($(1)_config)
	$$(call generate_codegen_record,$(1),$(1))
$($(1)_objdir)/$(1)Retriever.$(OBJEXT): $($(1)_objdir)/$(1)Retriever.cpp
	$$(call compile_cxx,$(1),$(1))
$($(1)_objdir)/$(1)Retriever.cpp $($(1)_objdir)/$(1)Retriever.h: $$($(1)_codegen_hdr)
	@:
$($(1)_objdir)/%.reg.$(OBJEXT): $($(1)_objdir)/%.reg.cpp $($(1)_objdir)/precompile
	$$(call compile_cxx,$(1),$(1))
$($(1)_objdir)/%_T_Context.$(OBJEXT): $($(1)_objdir)/%_T_Context.cpp $($(1)_objdir)/precompile
	$$(call compile_cxx,$(1),$(1))
$($(1)_objdir)/%.$(OBJEXT): $($(1)_objdir)/%.cpp $($(1)_objdir)/precompile
	$$(call compile_cxx,$(1),$(1))
endef
endif  #Finish CODE_ANALYSIS_RULES
##############################################################################
define SetTargetType
ifneq ($(strip $(filter updateclassversion,$(MAKECMDGOALS))),)
  UPDATE_CLASSVERSION:=yes
endif
ifeq ($(strip $(filter-out help enable-biglib enable-biglib enable-biglib outputlog clean ProjectRename projectrename PROJECTRENAME ExternalLinks ToolUpdated ToolUpdated_%,$(MAKECMDGOALS))),)
  ONLYECHOTARGETS:=yes
  FAST :=yes
  XFAST:=yes
  UFAST:=yes
endif
ifeq ($(strip $(filter-out productmap gindices skiptest_% echo_% clean_% fast xfast ufast outputlog updateclassversion,$(MAKECMDGOALS))),)
  ONLYECHOTARGETS:=yes
  ifneq ($(strip $(filter ufast,$(MAKECMDGOALS))),)
    FAST :=yes
    XFAST:=yes
    UFAST:=yes
  else
    ifneq ($(strip $(filter xfast,$(MAKECMDGOALS))),)
      FAST :=yes
      XFAST:=yes
    else
      ifneq ($(strip $(filter fast,$(MAKECMDGOALS))),)
        FAST :=yes
      endif
    endif
  endif
endif
endef
define UpdateMakeGoalTypes
$(if $(strip $(MAKECMDGOALS)),$(eval $(call SetTargetType)),)
endef
define GetEchoVariable
$(if $(strip $(filter echo_%,$(1))),$(patsubst echo_%,%,$(1)),)
endef
$(eval $(call UpdateMakeGoalTypes))
##############################################################################
.PHONY: ToolUpdated_% ToolUpdated ExternalLinks Non-xml\ BuildFile\ check
Non-xml\ BuildFile\ check:
	@if [ "X$(NON_XML_BUILDFILE)" != "X" ] ; then \
	  $(CMD_echo) "****ERROR: Non-XML BuildFiles found. Please convert these to xml format using 'scram build -c'";\
          $(foreach bf,$(NON_XML_BUILDFILE),$(CMD_echo) "          => $(bf)";) \
	  [ "X$(RELEASETOP)" = "X" ] || exit 1 ;\
	fi
FORCE_TARGET:  Non-xml\ BuildFile\ check
	@:
$(WORKINGDIR)/cache/prod/%:
	@$(CMD_touch) $@
$(LOCALTOP)/$(SCRAMSTORENAME_LOGS)/testing.log: FORCE_TARGET
	@$(CMD_mkdir) -p $(@D) ;\
	$(CMD_rm) -rf $@; \
	$(CMD_echo) "Creating test log file $(SCRAMSTORENAME_LOGS)/testing.log" ;\
	$(CMD_touch) $@
$(WORKINGDIR)/cache/log/%: FORCE_TARGET
	@if [ -f $@ ] ; then  \
	  $(CMD_rm) -f $@ ;\
	else \
	  [ -d $(@D) ] || $(CMD_mkdir) -p $(@D) ;\
	fi
	@$(CMD_touch) -t $(OLD_TIMESTAMP) $@
ToolUpdated_%: ToolUpdated
ExternalLinks ToolUpdated:
	@$(LOCALTOP)/$(SCRAM_CONFIGDIR)/SCRAM/linkexternal.pl --arch $(SCRAM_ARCH)
$(WORKINGDIR)/cache/xlibs: $(WORKINGDIR)/cache/xlibs.backup
	@$(CMD_touch) -t $(OLD_TIMESTAMP) $@
$(WORKINGDIR)/cache/xlibs.backup: $(LOCALTOP)/external/$(SCRAM_ARCH)/links.DB 
	@$(CMD_touch) $@
$(LOCALTOP)/external/$(SCRAM_ARCH)/links.DB: $(ToolTimeStamps)
	@[ -d $(@D) ] || $(CMD_mkdir) -p $(@D)
	@$(LOCALTOP)/$(SCRAM_CONFIGDIR)/SCRAM/linkexternal.pl --arch $(SCRAM_ARCH)
######################################################################
$(eval curtop:=$(shell $(CMD_echo) $$LOCALTOP))
ifneq ($(curtop),$(SCRAM_INIT_LOCALTOP))
  PROJECT_RENAME_TARGET:=
  ifeq ($(strip $(MAKECMDGOALS)),ProjectRename)
    PROJECT_RENAME_TARGET:=yes
  else
    ifeq ($(strip $(MAKECMDGOALS)),projectrename)
      PROJECT_RENAME_TARGET:=yes
    else
      ifeq ($(strip $(MAKECMDGOALS)),PROJECTRENAME)
        PROJECT_RENAME_TARGET:=yes
      endif
    endif
  endif
  ifneq ($(PROJECT_RENAME_TARGET),yes)
    $(eval dummyfile:=localtopchecking.file.$(shell date +%s.%N 2>/dev/null))
    $(eval xxtmp:=$(shell $(CMD_touch) $(SCRAM_INIT_LOCALTOP)/$(dummyfile) 2> /dev/null))
    ifeq ($(strip $(wildcard $(curtop)/$(dummyfile))),)
      $(eval xxtmp:=$(shell $(CMD_rm) -f $(SCRAM_INIT_LOCALTOP)/$(dummyfile)))
      $(info **** ERROR: You have moved/renamed this project area "$(curtop)" from "$(SCRAM_INIT_LOCALTOP)")
      $(error Please first run \"scramv1 b ProjectRename\")
    endif
    $(eval xxtmp:=$(shell $(CMD_rm) -f $(SCRAM_INIT_LOCALTOP)/$(dummyfile)))
  endif
endif

.PHONY: projectrename ProjectRename PROJECTRENAME
ProjectRename projectrename PROJECTRENAME:
	@if [ -f ./$(SCRAM_CONFIGDIR)/SCRAM/projectAreaRename.pl ] ; then \
	  ./$(SCRAM_CONFIGDIR)/SCRAM/projectAreaRename.pl $(SCRAM_INIT_LOCALTOP) $(curtop) $(SCRAM_ARCH); \
	  $(CMD_echo) "Done: $@"; \
	fi
######################################################################
#Common Rules
.PHONY: all project project_all all_$(SCRAM_SOURCEDIR) ProjectPluginRefresh CompilePython PostBuild
all: all_$(TARGETDIR)
	@if [ "X$(TARGETDIR)" != "X$(SCRAM_SOURCEDIR)" ] ; then \
	  $(DO_BUILD_LOG) $(MAKE) -f $(SCRAM_MAKEFILE) ufast outputlog ;\
	  $(MAKE) -f $(SCRAM_MAKEFILE) PostBuild ;\
	fi
project project_all all_$(SCRAM_SOURCEDIR): $(SCRAM_SOURCEDIR)
	@:

.PHONY: python help compile precompile edm_checks runtests unittests clean distclean cache_clean project_clean project_help
.PHONY: clean_$(SCRAM_SOURCEDIR) help_$(SCRAM_SOURCEDIR)
help: help_$(TARGETDIR)
clean: clean_$(TARGETDIR)
runtests: runtests_$(TARGETDIR)
unittests: unittests_$(TARGETDIR)
python: runpython_$(TARGETDIR)
compile: compile_$(TARGETDIR)
precompile: precompile_$(TARGETDIR)
edm_checks: edm_checks_$(TARGETDIR)

project_clean clean_$(SCRAM_SOURCEDIR) vclean cache_clean distclean:
	@$(CMD_echo) "Cleaning ProductStore directories:"
	$(CMD_rm) -rf $(ALL_PRODUCT_STORES)
	@$(CMD_echo) "Resetting project cache:"; $(CMD_mkdir) -p $(SCRAM_ADMIN_DIR)
	@for db in ProjectCache DirCache RuntimeCache ObjectCache; do \
	  $(CMD_echo) $(CMD_rm) -f $(SCRAM_ADMIN_DIR)/$$db.db* ; \
	  $(CMD_touch) $(SCRAM_ADMIN_DIR)/$$db.db.gz; \
	  $(CMD_rm) -f $(SCRAM_ADMIN_DIR)/$$db.db* ;  \
	done
	$(CMD_rm) -rf $(SCRAM_ADMIN_DIR)/MakeData
	$(CMD_rm) -f  $(LLVM_CCDB_EXT)
	@if [ "X$(COMPILE_PYTHON_SCRIPTS)" = "Xyes" ] ; then \
	  $(CMD_echo) "Cleaning up the compiled .pyc and generated __init__.py files in the $(SCRAM_SOURCEDIR) directory." &&\
	  if [ -d $(SCRAM_SOURCEDIR) ] ;      then $(CMD_find) $(SCRAM_SOURCEDIR)       -name '__init__.py' -type f | $(CMD_xargs) $(CMD_grep) '^#Automatically created by SCRAM' | $(CMD_sed) -e 's|/__init__.py:.*|/__init__.py|' | $(CMD_uniq) | $(CMD_xargs) $(CMD_rm) -f ; fi &&\
	  if [ -d $(SCRAMSTORENAME_CFIPYTHON) ] ; then $(CMD_find) $(SCRAMSTORENAME_CFIPYTHON)  -name '*.pyc' -type f | $(CMD_xargs) $(CMD_rm) -f ; fi &&\
	  if [ -d $(SCRAM_SOURCEDIR) ] ;      then $(CMD_find) $(SCRAM_SOURCEDIR)       -name '*.pyc' -type f       | $(CMD_xargs) $(CMD_rm) -f ; fi ;\
	fi
	$(CMD_rm) -rf $(SCRAM_INTwork) $(COMMON_WORKINGDIR)/cache/packs

project_help help_$(SCRAM_SOURCEDIR):
	@$(CMD_echo) "------------ Help for Project-level Builds rules/targets ------------"
	@$(CMD_echo) ""
	@$(CMD_echo) "help"
	@$(CMD_echo) "  Shows what SCRAM will build for your current working directory."
	@$(CMD_echo) ""
	@$(CMD_echo) "clean"
	@$(CMD_echo) "  Clean up all the products built/generated by SCRAM."
	@$(CMD_echo) ""
	@$(CMD_echo) "python"
	@$(CMD_echo) "  To just build python i.e. creating sym-links and compiling python modules."
	@$(CMD_echo) ""
	@$(CMD_echo) "runtests"
	@$(CMD_echo) "  Build and run all tests for the project, or package-level tests only"
	@$(CMD_echo) ""
	@$(CMD_echo) "unittests"
	@$(CMD_echo) "  Same as runtests but does not try to build the test first."
	@$(CMD_echo) ""
	@$(CMD_echo) "checker"
	@$(CMD_echo) "  Run LLVM static checkers"
	@$(CMD_echo) ""
	@$(CMD_echo) "code-checks-all(combination of code-checks-run and code-checks-apply)"
	@$(CMD_echo) "  Run clang-tidy. Following extra env can use set"
	@$(CMD_echo) "    USER_CODE_CHECKS: checks to apply"
	@$(CMD_echo) "    USER_CODE_CHECKS_FILES:  Files within $(SCRAM_SOURCEDIR) to apply the checks"
	@$(CMD_echo) "    USER_CODE_CHECKS_FILE: File containing list of files to apply the checks"
	@$(CMD_echo) "    USER_CODE_CHECKS_ARGS: Extra arguments to pass to clang-tidy"
	@$(CMD_echo) "    USER_CODE_CHECKS_APPLY_ARGS: Extra arguments to pass to clang-apply-replacements"
	@$(CMD_echo) ""
	@$(CMD_echo) "code-checks"
	@$(CMD_echo) "  Run clang-tidy (via code-checks-all build rule) on changed files w.r.t release"
	@$(CMD_echo) "    By default it uses 'git diff --name-only TAG' to find the changed files."
	@$(CMD_echo) "    One can set USER_CODE_CHECKS_FILE to provide list of change files."
	@$(CMD_echo) "    USER_CODE_CHECKS_CHANGE_ONLY can be set to apply changes only for changed files i.e."
	@$(CMD_echo) "    no un-touched included headers files will be changed."
	@$(CMD_echo) ""
	@$(CMD_echo) "code-checks-dump-config"
	@$(CMD_echo) "  Dump the clang-tidy config"
	@$(CMD_echo) ""
	@$(CMD_echo) "code-format"
	@$(CMD_echo) "  Run clang-format. Following extra env can use set"
	@$(CMD_echo) "    USER_CODE_FORMAT: Format style to apply"
	@$(CMD_echo) "    USER_CODE_FORMAT_FILES:  Files within $(SCRAM_SOURCEDIR) to apply the format"
	@$(CMD_echo) "    USER_CODE_FORMAT_FILE: File containing list of files to apply the format"
	@$(CMD_echo) "    USER_CODE_FORMAT_ARGS: Extra arguments to pass to clang-format"
	@$(CMD_echo) ""
	@$(CMD_echo) "code-format-dump-config"
	@$(CMD_echo) "  Dump the clang-format config"
	@$(CMD_echo) ""
	@$(CMD_echo) "dxr"
	@$(CMD_echo) "  Generate DXR indexes for the release."
	@$(CMD_echo) ""
	@$(CMD_echo) "gindices"
	@$(CMD_echo) "  Generate glimpse indexes for the release."
	@$(CMD_echo) ""
	@$(CMD_echo) "enable-biglib disable-biglib check-biglib"
	@$(CMD_echo) "  Disable/enable/check big EDM plugins"
	@$(CMD_echo) ""
	@$(CMD_echo) "deps-tree <package1> <package2>"
	@$(CMD_echo) "  To find the dependencies paths from <package1> to <package2>"
	@$(CMD_echo) ""
	@$(CMD_echo) "updateclassversion"
	@$(CMD_echo) "  Run the edmCheckClassVersion and generate new src/<package>/classes_def.xml.generated file."
	@$(CMD_echo) ""
	@$(CMD_echo) "prebuild postbuild"
	@$(CMD_echo) "  Execute any pre/post-build target for the project e.g. generating various source file for root/lcg dictionaries etc."
	@$(CMD_echo) ""
	@$(CMD_echo) "src release release-build all all_src project project_all"
	@$(CMD_echo) "  Build  all  products  (shared  libs,  plugins,  binaries) for the project"
	@$(CMD_echo) ""
	@$(CMD_echo) "<subsystem> <subsystem>/<Package>"
	@$(CMD_echo) "  Build all products (shared libs, plugins, binaries) and their dependencies for src/<path>"
	@$(CMD_echo) ""
	@$(CMD_echo) "runtime"
	@$(CMD_echo) "  Dump the runtime environment used at build time."
	@$(CMD_echo) ""
	@$(CMD_echo) "ProjectRename projectrename PROJECTRENAME"
	@$(CMD_echo) "  Fix the project area which was move/renamed after its creation."
	@$(CMD_echo) ""
	@$(CMD_echo) "ExternalLinks ToolUpdated"
	@$(CMD_echo) "  Re-create symblinks for externals tools."
	@$(CMD_echo) ""
	@$(CMD_echo) "echo_<tool|package>_USED_BY"
	@$(CMD_echo) "  Shows what depends on <tool> or <package> e.g."
	@$(CMD_echo) "    scram build echo_boost_USED_BY"
	@$(CMD_echo) "    scram build echo_FWCore/Framework_USED_BY"
	@$(CMD_echo) "  should show what depend on boost and FWCore/Framework"
	@$(CMD_echo) ""
	@$(CMD_echo) "echo_<tool|package>_USES"
	@$(CMD_echo) "  Shows what is the dependency of <tool> or <package>"
	@$(CMD_echo) ""
	@$(CMD_echo) "echo_<productname>_ORIGIN"
	@$(CMD_echo) "  Shows from which package <productname> was built."
	@$(CMD_echo) ""
	@$(CMD_echo) "echo_<variable>"
	@$(CMD_echo) "  Shows the value of a variable used by the game e.g."
	@$(CMD_echo) "    scram build echo_CXXFLAGS"
	@$(CMD_echo) ""

.PHONY: release release-build release-reset release-doc release-docs release-freeze

release: release-reset release-build postbuild

release-build: project_all
	@$(if $(HOOK_PROJECT),$(HOOK_PROJECT) -e $(if $(KEEP_ON_BUILDING), || $(CMD_true)),$(CMD_echo) ">> Project Build done")

release-reset: distclean

release-docs release-doc: doc

release-freeze: release-check
	@$(CMD_echo) "Cleaning up and protecting directories:"
	@$(CMD_cd) $(LOCALTOP); \
	$(CMD_rm) -fr $(SCRAM_INTwork)/$(SCRAM_SOURCEDIR) ; \
	$(CMD_rm) -fr $(SCRAM_INTwork)/cache ; \
	$(CMD_find) . -type f -print | $(CMD_xargs) $(CMD_chmod) a-w; \
	$(CMD_find) . -type d -print | $(CMD_xargs) $(CMD_chmod) 555

###############################################################################
PLUGIN_REFRESH_CMDS :=
CHECK_DELETED_PACKS:=
ifneq ($(strip $(CMSSW_GIT_HASH)),)
ifneq ($(strip $(wildcard $(SCRAM_SOURCEDIR)/.git/info/sparse-checkout)),)
ALL_DELETED_PACKAGES:=$(strip $(shell $(CMD_cd) $(SCRAM_SOURCEDIR) && $(LOCALTOP)/$(SCRAM_CONFIGDIR)/SCRAM/find_deleted_packages.py $(CMSSW_GIT_HASH) .git/info/sparse-checkout))
CHECK_DELETED_PACKS:=$(if $(strip $(ALL_DELETED_PACKAGES)),YES)
endif
endif
###############################################################################
-include $(TOOLS_MKDIR)/SCRAMBased/self_libs_def.mk
$(foreach x,$(ALL_TOOLS),$(eval $x := $x))
$(foreach x,$(ALL_TOOLS),$(eval $(call ProductCommonVarsTools,$x,,,$x)))
-include $(PUB_DIRCACHE_MKDIR)/src.mk
-include $(PUB_DIRCACHE_MKDIR)/DirCache.mk
-include $(DIRCACHE_MKDIR)/ExtraBuilsRules/*.mk
-include $(DIRCACHE_MKDIR)/DirCache.mk
$(foreach f,LLVM_ANALYZER MISSING_SYMBOL_FLAGS,$(eval $f:=$(self_EX_FLAGS_$f)))
$(foreach f,CXXFLAGS CPPFLAGS,$(foreach t,LCGDICT ROOTDICT BIGOBJ BINARY LIBRARY TEST TEST_LIBRARY,$(eval $t_$f:=$(self_EX_FLAGS_$t_$f))$(eval REM_$t_$f:=$(self_EX_FLAGS_REM_$t_$f))))
$(foreach p,$(ALL_PACKAGES) $(ALL_DELETED_PACKAGES),$(if $(strip $($p)),,$(eval $p:=$(subst /,,$p))))
-include $(TOOLS_MKDIR)/SCRAMBased/all.mk
-include $(DIRCACHE_MKDIR)/RmvDirCache.mk
ifeq ($(strip $(CODE_ANALYSIS_RULES)),YES)
CONFIGDEPS:=
endif
ifneq ($(strip $(filter deps-tree,$(MAKECMDGOALS))),)
    UFAST:=yes
    ALL_SUBSYSTEMS:=
    DEPS_TREE_PACKAGE:=$(wordlist 1,1,$(filter-out deps-tree,$(MAKECMDGOALS)))
    DEPS_TREE_DEPENDENCY:=$(wordlist 2,2,$(filter-out deps-tree,$(MAKECMDGOALS)))
$(MAKECMDGOALS)::
	@:
endif
HOOK_PROJECT := $(if $(strip $(USER_HOOK_PROJECT)),$(USER_HOOK_PROJECT),$(HOOK_PROJECT))
HOOK_PACKAGE := $(if $(strip $(USER_HOOK_PACKAGE)),$(USER_HOOK_PACKAGE),$(HOOK_PACKAGE))
HOOK_PRODUCT := $(if $(strip $(USER_HOOK_PRODUCT)),$(USER_HOOK_PRODUCT),$(HOOK_PRODUCT))
ifneq ($(strip $(edmPluginRefresh_cache)),)
POISON_EDMPLUGIN_CACHE      := $(strip $(if $(strip $(RELEASETOP)$(IS_PATCH)),yes))
endif
FULL_RELEASE_FOR_A_PATCH    := $(strip $($(SCRAM_PROJECTNAME)_BASE_FULL_RELEASE))
ifeq ($(IS_LINUX),yes)
ifeq ($(strip $(CXXSHAREDFLAGS)),)
CXXSHAREDFLAGS := -shared
endif
endif
APPLY_BIGLIB_RULES:=yes
ifeq ($(strip $(SCRAM_DEFAULT_COMPILER)),llvm)
APPLY_BIGLIB_RULES:=no
endif
ifneq ($(strip $(wildcard $(SCRAM_ADMIN_DIR)/no-bigproduct)),)
APPLY_BIGLIB_RULES:=no
endif
ifeq ($(strip $(APPLY_BIGLIB_RULES)),no)
ALL_BIGPRODS:=
subdirs_$(SCRAM_SOURCEDIR):=$(filter-out $(SCRAM_SOURCEDIR)_BigProducts,$(subdirs_$(SCRAM_SOURCEDIR)))
ALL_SUBSYSTEMS:=$(filter-out BigProducts,$(ALL_SUBSYSTEMS))
endif
ifeq ($(strip $(CODE_ANALYSIS_RULES)),NO)
ifneq ($(strip $(ALL_BIGPRODS)),)
-include $(SCRAM_CONFIGDIR)/SCRAM/GMake/Makefile.bigedm.rules
endif
endif
ifeq ($(IS_MIC),yes)
ROOTCINT:=LD_LIBRARY_PATH=$(ROOT_INTERFACE_BASE)/rootcint/lib:$$LD_LIBRARY_PATH $(ROOT_INTERFACE_BASE)/rootcint/bin/rootcint
endif
ifneq ($(strip $(COND_SERIALIZATION)),)
COND_SERIALIZATION_SCRIPT:=$(call find_project_file,$(COND_SERIALIZATION))
endif
##############################################################################
self_EX_INCLUDE := $(subst $(LOCALTOP)/$(SCRAM_SOURCEDIR),$(LOCALTOP)/$(SCRAM_SOURCEDIR) $(LOCALTOP)/poison ,$(self_EX_INCLUDE))
$(foreach f,$(OVERRIDABLE_FLAGS),$(eval $f:=$(if $(strip $(RELEASETOP)),$(call AdjustFlag,DEV,$f),$(call AdjustFlag,RELEASE,$f))))
####### Clean up the directories which were already build but now have been removed from src area ######
ifneq ($(strip $(REMOVED_DIRS)),)
$(shell $(CMD_echo) "" > $(WORKINGDIR)/.AUTOCLEAN)
$(foreach d,$(sort $(REMOVED_DIRS)),$(if $(wildcard $(WORKINGDIR)/$(d)),$(eval xx:=$(shell $(CMD_find) $(WORKINGDIR)/$(d) -name "AUTOCLEAN.*.clean" -type f | $(CMD_xargs) $(CMD_cat) | $(CMD_grep) "^[0-9][0-9]:" | $(CMD_sed) -e "s|^[0-9][0-9]:||" |$(CMD_sort) | $(CMD_uniq) >> $(WORKINGDIR)/.AUTOCLEAN)$(info Cleaning up removed directory:$(d))$(shell $(CMD_rm) -rf $(WORKINGDIR)/classes/$(d) $(WORKINGDIR)/$(d))),))
$(foreach d,$(REMOVED_DIRS),$(if $(wildcard $(WORKINGDIR)/cache/bf/$(d)/$(SCRAM_BUILDFILE)),$(shell $(CMD_touch) $(SCRAM_INTwork)/cache/bf/$(d)/$(SCRAM_BUILDFILE)),))
xx:=$(shell $(CMD_sh) $(WORKINGDIR)/.AUTOCLEAN; $(CMD_rm) -rf $(DIRCACHE_MKDIR)/RmvDirCache.mk $(DIRCACHE_MKDIR)/RmvDirCache; $(CMD_mkdir) -p $(DIRCACHE_MKDIR)/RmvDirCache; $(CMD_touch) $(DIRCACHE_MKDIR)/RmvDirCache.mk)
endif
####### Update Tools and Prods rules ##############
ifeq ($(strip $(UFAST)),)
$(foreach x,$(ALL_TOOLS),$(foreach err,$($(x)_USE_ERR),$(eval $(call UseError,$(err),$(x)))))
ifeq ($(strip $(XFAST)),)
$(foreach x,$(ALL_EXTERNAL_PRODS),$(eval $(call ProductCommonVarsExternal,$(x)))$(eval $($(x)_INIT_FUNC)))
$(foreach x,$(ALL_BIGPRODS),$(eval $(call BigProductVars,$x)))
$(foreach x,$(ALL_PRODS),$(eval $(call ProductCommonVars,$(x),,,$($(x)_BuildFile))))
$(foreach x,$(ALL_BIGPRODS),$(eval $(call ProductCommonVars,$(x),,,$($(x)_BuildFile))))
ifeq ($(strip $(FAST)),)
$(info >> Local Products Rules ..... started)
$(foreach x,$(ALL_PRODS),$(eval $($(x)_INIT_FUNC)))
$(foreach x,$(ALL_BIGPRODS),$(eval $($(x)_INIT_FUNC)))
$(info >> Local Products Rules ..... done)
endif
$(foreach bf,$(ALL_BUILDFILES),$(foreach err,$(sort $($(bf)_USE_ERR)),$(eval $(call UseError,$(err),$(bf)))))
$(foreach x,$(ALL_COMMONRULES),$(eval $($(x)_INIT_FUNC)))
endif
####### Update Subsystems and Packages rules ##############
$(foreach dir,$(ALL_SUBSYSTEMS),$(eval $(call SubSystem,$(dir),$(SCRAM_SOURCEDIR)_$(subst /,_,$(dir)))))
$(foreach dir,$(ALL_PACKAGES),$(eval $(call Package,$(dir),$(SCRAM_SOURCEDIR)_$(subst /,_,$(dir)))))
endif
###########################################################
LIBDIR := $(wildcard $(LIBDIR))
self_EX_LIBDIR := $(wildcard $(self_EX_LIBDIR))
PHONY: $(SCRAM_SOURCEDIR) prebuild postbuild runtests_$(SCRAM_SOURCEDIR) unittests_$(SCRAM_SOURCEDIR) runpython_$(SCRAM_SOURCEDIR) compile_$(SCRAM_SOURCEDIR) precompile_$(SCRAM_SOURCEDIR) edm_checks_$(SCRAM_SOURCEDIR)
$(SCRAM_SOURCEDIR): prebuild $($(SCRAM_SOURCEDIR)) $(subdirs_$(SCRAM_SOURCEDIR))
	@$(DO_BUILD_LOG) $(MAKE) -f $(SCRAM_MAKEFILE) ufast outputlog
	@$(MAKE) -f $(SCRAM_MAKEFILE) PostBuild
prebuild: $(prebuild)
	@$(CMD_echo) ">> Building $(SCRAM_PROJECTNAME) version $(SCRAM_PROJECTVERSION) ----" $(if $(HOOK_PROJECT), && $(HOOK_PROJECT) -s $(if $(KEEP_ON_BUILDING), || $(CMD_true)))
	@[ -d $(LOCALTOP)/logs/$(SCRAM_ARCH) ] || $(CMD_mkdir) -p $(LOCALTOP)/logs/$(SCRAM_ARCH)
postbuild: $(postbuild)
	@$(MAKE) -f $(SCRAM_MAKEFILE) PostBuild
	@$(CMD_echo) "Release $(SCRAM_PROJECTNAME) version $(SCRAM_PROJECTVERSION) build finished at `date`"
runpython_$(SCRAM_SOURCEDIR): $(addprefix runpython_, $(subdirs_$(SCRAM_SOURCEDIR)))
	@$(CMD_echo) ">> Python completed for $(SCRAM_PROJECTNAME) $(SCRAM_PROJECTVERSION)"
runtests_$(SCRAM_SOURCEDIR): $(addprefix runtests_, $(subdirs_$(SCRAM_SOURCEDIR)))
	@$(CMD_echo) ">> Test sequence completed for $(SCRAM_PROJECTNAME) $(SCRAM_PROJECTVERSION)"
unittests_$(SCRAM_SOURCEDIR): $(addprefix unittests_, $(subdirs_$(SCRAM_SOURCEDIR)))
	@$(CMD_echo) ">> Test sequence completed for $(SCRAM_PROJECTNAME) $(SCRAM_PROJECTVERSION)"
compile_$(SCRAM_SOURCEDIR): $(addprefix compile_, $(subdirs_$(SCRAM_SOURCEDIR)))
	@$(CMD_echo) ">> Compile sequence completed for $(SCRAM_PROJECTNAME) $(SCRAM_PROJECTVERSION)"
precompile_$(SCRAM_SOURCEDIR): $(addprefix precompile_, $(subdirs_$(SCRAM_SOURCEDIR)))
	@$(CMD_echo) ">> Pre-compile sequence completed for $(SCRAM_PROJECTNAME) $(SCRAM_PROJECTVERSION)"
edm_checks_$(SCRAM_SOURCEDIR): $(addprefix edm_checks_, $(subdirs_$(SCRAM_SOURCEDIR)))
	@$(CMD_echo) ">> EDM Checks sequence completed for $(SCRAM_PROJECTNAME) $(SCRAM_PROJECTVERSION)"
###########################################################
define GetMissingSymbolFlags
  $(if $($(1)_libcheck),$(if $2,$(info @@@@ Checking for missing symbols was SKIPPED due to NO_LIB_CHECKING flag in BuildFile: $(@F)),),$(MISSING_SYMBOL_FLAGS))
endef
ifndef SCRAM_NOSYMCHECK
ifeq ($(strip $(MISSING_SYMBOL_FLAGS)),)
define check_missing_symbols
  if [ "X$(1)" = X ] ; then \
    $(CMD_echo) "@@@@ Checking shared library for missing symbols: $(@F)" &&\
    $(CMD_echo) "int main(){}" > $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp  &&\
    $(VERB_ECHO) $(CXX) $(CXXFLAGS) $(CXXSHAREDOBJECTFLAGS) $(LDFLAGS) -o $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).out $@ $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp &&\
    ($(CXX) $(CXXFLAGS) $(CXXSHAREDOBJECTFLAGS) $(LDFLAGS) -o $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).out $@ $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp || ($(CMD_rm) -f $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).out && $(call delete_plugin_build_prod,$(2),$(3)) && exit 1)) &&\
    $(CMD_rm) -f $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).out	&&\
    $(CMD_echo) "@@@@ ----> OK, shared library FULLY-BOUND (no missing symbols): $(@F)" ; \
  else \
    $(CMD_echo) "@@@@ Checking for missing symbols was SKIPPED due to NO_LIB_CHECKING flag in BuildFile: $(@F)"; \
  fi
endef
else
check_missing_symbols:=$(CMD_true)
endif
else
define check_missing_symbols
  $(CMD_echo) "@@@@ Checking for missing symbols was SKIPPED due to SCRAM_NOSYMCHECK: $(@F)"
endef
endif

.PHONY: all_% clean_% help_% runtests_% unittests_% runpython_% compile_% precompile_% edm_checks_% ufast xfast fast %_USED_BY %_USES echo_% outputlog buildlog
.PHONY: help_%_python help_%_src help_%_plugins help_%_bin help_%_test help_$(SCRAM_SOURCEDIR)_%
.PHONY: skiptest_% deps-tree
help_%_python:
	@$(CMD_echo) "Running \"scram build\" here will run rules for pythin i.e. creates sym-links and compiles python modules"
help_%_src:
	@$(CMD_echo) "Running \"scram build\" here normally build a shared library."
help_%_plugins:
	@$(CMD_echo) "Running \"scram build\" here normally build EDM-plugins."
help_%_bin:
	@$(CMD_echo) "Running \"scram build\" here normally build public executables and shared libs (if any)."
help_%_test:
	@$(CMD_echo) "Running \"scram build\" here normally build test executables and shared libs (if any)."
help_$(SCRAM_SOURCEDIR)_%:
	@$(CMD_echo) "Doing \"scram build\" here will build every thing exist under this directory."
all_% runtests_% unittests_% help_% runpython_% compile_% precompile_% edm_checks_%:
	@if [ "X$(TARGETDIR)" = "X$*" ] ; then \
	  $(CMD_echo) ">> Nothing to be done for $(THISDIR)";\
	fi
clean_%:
	@if [ "X$($*_objdir)" != "X" ] ; then \
	  dir=`$(CMD_echo) $($*_objdir) | $(CMD_grep) '^$(WORKINGDIR)/' | $(CMD_sed) -e 's|^$(WORKINGDIR)/||'`;\
	  if [ "X$$dir" != "X" ] ; then \
	    if [ -d $(WORKINGDIR)/$$dir ] ; then \
	      $(CMD_echo) "Cleaning up $$dir"; $(call BuildClean,$$dir) ; exit 0;\
	    fi;\
	  fi;\
	elif [ "$(TARGETDIR)" == "$*" ] ; then \
	  $(CMD_echo) "Cleaning up $(THISDIR)"; $(call BuildClean,$(THISDIR));\
	else \
	  $(CMD_echo) "***WARNING: Unknown product $*. Failed to cleanup.";\
	fi
	$(if $(strip $(edmPluginRefresh_cache)),$(MAKE) -f $(SCRAM_MAKEFILE) poisoned_edmplugins)
ufast xfast fast:
	@:
%_USED_BY:
	@var=$(call GetEchoVariable,$@);\
	if [ "X$$var" != "X" ] ; then \
	  $(SCRAM_CONFIGDIR)/SCRAM/projectInfo.pl $(LOCALTOP) USED_BY $(patsubst %_USED_BY,%,$(call GetEchoVariable,$@)) $(SCRAM_ARCH);\
	fi
%_USES:
	@var=$(call GetEchoVariable,$@);\
	if [ "X$$var" != "X" ] ; then \
	  $(SCRAM_CONFIGDIR)/SCRAM/projectInfo.pl $(LOCALTOP) USES $(patsubst %_USES,%,$(call GetEchoVariable,$@)) $(SCRAM_ARCH);\
	fi
%_ORIGIN:
	@var=$(call GetEchoVariable,$@);\
	if [ "X$$var" != "X" ] ; then \
	  $(SCRAM_CONFIGDIR)/SCRAM/projectInfo.pl $(LOCALTOP) ORIGIN $(patsubst %_ORIGIN,%,$(call GetEchoVariable,$@)) $(SCRAM_ARCH);\
	fi
echo_%:
	@$(CMD_echo) "$* = $(subst ",\",$($*))"
$(SCRAMSTORENAME_PYTHON)/__init__.py:
	@$(CMD_touch) $@
$(COMMON_WORKINGDIR)/cache/python_symlinks: $(COMMON_WORKINGDIR)/cache/project_links $(addsuffix __init__.py,$(addprefix python/,$(dir $(ALL_PYTHON_DIRS))))
	@[ -f $@ ] || ($(CMD_mkdir) -p $(@D) ; $(CMD_touch) -t $(OLD_TIMESTAMP) $@)
$(WORKINGDIR)/%/productautocleanup: FORCE_TARGET
	@for dir in $(foreach x,$(patsubst productautocleanup,,$(notdir $(patsubst %/,%,$(dir $(wildcard $(@D)/*/AUTOCLEAN.*.clean))))),$(if $(findstring all_$x,$($(subst /,_,$*))),,$x)) ; do \
	  $(call BuildClean,$*/$$dir,0[0-9]);\
	done
	@[ -d $(@D) ] || $(CMD_mkdir) -p $(@D) &&\
	$(CMD_touch) -t $(OLD_TIMESTAMP) $@
outputlog: buildlog
	@:
buildlog:
	@for f in `$(CMD_find) $(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR) -name "build.log" -type f` ; do \
	  pack=`$(CMD_dirname) $$f` &&\
	  for l in `$(CMD_find) $$pack -name "*" -type f | grep -v "$$pack/build.log"` ; do \
	    $(CMD_cat) $$l >> $$f && $(CMD_cat) $$l && $(CMD_rm) -f $$l ;\
	  done;\
	done
runtime:
	@$(CMD_echo) ">> Runtime environment:"; env
$(WORKINGDIR)/errors: FORCE_TARGET
	@for err in $(foreach p,$(BUILDFILE_ERRORS),$($(p)_ERROR)); do \
	  echo "$$err" ;\
	done; $(CMD_touch) -t $(OLD_TIMESTAMP) $@
skiptest_%:
	@:
updateclassversion: $(filter $(WORKINGDIR)/$(THISDIR)/%,$(ALL_CLASS_VERSION_RULES))
	@:
PostBuild: CompilePython ProjectPluginRefresh $(WORKINGDIR)/errors $(if $(strip $(edmPluginRefresh_cache)),poisoned_edmplugins)
	@:
ifeq ($(strip $(COMPILE_PYTHON_SCRIPTS)),yes)
.PHONY: do_python_symlink PyCompile_%
CompilePython: $(addprefix PyCompile_,$(wildcard $(SCRAMSTORENAME_CFIPYTHON)$(patsubst $(SCRAM_SOURCEDIR)%,%,$(THISDIR)) $(SCRAMSTORENAME_PYTHON)) $(filter $(THISDIR)%,$(addprefix $(SCRAM_SOURCEDIR)/,$(ALL_PYTHON_DIRS))))
	@[ ! -f $(COMMON_WORKINGDIR)/cache/python_error ] || exit 1
	@$(CMD_echo) ">> All python modules compiled"
PyCompile_$(SCRAM_SOURCEDIR)/% PyCompile_cfipython/% PyCompile_%: do_python_symlink
	@$(call compile_python,$(patsubst PyCompile_%,%,$@))
do_python_symlink: $(COMMON_WORKINGDIR)/cache/python_symlinks
	@$(CMD_rm) -f $(COMMON_WORKINGDIR)/cache/python_error
	@$(CMD_echo) ">> Done python_symlink"
else
CompilePython:
	@$(CMD_echo) ">> Skipped python compilation"
endif
ProjectPluginRefresh: FORCE_TARGET $(foreach file,$(addsuffix _cache,$(PLUGIN_REFRESH_CMDS)),$($(file)))
	@$(CMD_echo) ">> Plugins of all types refreshed."
.PHONY: dxr checker FORCE_LLVM_CHECK llvm-ccdb
FORCE_LLVM_CHECK:
	@:
ifeq ($(strip $(SCRAM_MULTIPLE_COMPILERS)),)
checker:
	@$(CMD_echo) "**** ERROR: Can not run llvm analyzer as this project does not support multiple compilers" && exit 1
else
ifeq ($(strip $(filter $(LLVM_ANALYZER)-$(CXX_TYPE_COMPILER),$(ALL_TOOLS))),)
checker:
	@$(CMD_echo) "**** ERROR: Can not run llvm analyzer as $(LLVM_ANALYZER)-$(CXX_TYPE_COMPILER) tool does not exist" && exit 1
else
ifeq ($(strip $(LLVM_PLUGIN)),)
checker:
	@(CMD_echo) "**** ERROR: LLVM static plugin is not set for this project" && exit 1
else
checker: $(WORKINGDIR)/cache/prod/lib$(LLVM_PLUGIN)
	@+$(CMD_echo) Starting LLVM static checkers $(THISDIR) &&\
	plugin=$(call find_project_file,lib/$(SCRAM_ARCH)/$(MODULE_PREFIX)$(LLVM_PLUGIN).$(SHAREDSUFFIX)) &&\
	if [ "X$$plugin" == "X" ] ; then $(CMD_echo) "**** ERROR: Unable to find $(MODULE_PREFIX)$(LLVM_PLUGIN).$(SHAREDSUFFIX)" ; exit 1; fi ;\
	LLVM_BASE=$($(shell $(CMD_echo) $(LLVM_ANALYZER)-$(CXX_TYPE_COMPILER)_BASE | $(CMD_tr) 'a-z-' 'A-Z_')) &&\
	$(CMD_cd) $(THISDIR) && $(CMD_rm) -rf $(LOCALTOP)/llvm-analysis && $(CMD_mkdir) -p $(LOCALTOP)/llvm-analysis &&\
	$(VERB_ECHO) $$LLVM_BASE/bin/scan-build -o $(LOCALTOP)/llvm-analysis -load-plugin $$plugin $(LLVM_CHECKERS) $(USER_LLVM_CHECKERS) \
	  $(SCRAM) build -f $(if $(strip $(SCRAM_BUILDVERBOSE)),-v,) compile COMPILER=$(LLVM_ANALYZER) SCRAM_IGNORE_MISSING_COMPILERS=yes &&\
	$$LLVM_BASE/bin/scan-build              -o $(LOCALTOP)/llvm-analysis -load-plugin $$plugin $(LLVM_CHECKERS) $(USER_LLVM_CHECKERS) \
	  $(SCRAM) build -f $(if $(strip $(SCRAM_BUILDVERBOSE)),-v,) compile COMPILER=$(LLVM_ANALYZER) SCRAM_IGNORE_MISSING_COMPILERS=yes && $(DO_BUILD_LOG) $(SCRAM) build buildlog &&\
	  $(CMD_rm) -rf $(LOCALTOP)/llvm-analysis/*/failures
endif
endif
endif
ifneq ($(strip $(PY2_DXR_BASE)),)
dxr:    $(SCRAM_SOURCEDIR)/dxr.config
	@$(CMD_mkdir) -p dxr && SCRAM_DXR_RUN=yes $(PY2_DXR_BASE)/bin/dxr-build.py -v -f $(SCRAM_SOURCEDIR)/dxr.config
$(SCRAM_SOURCEDIR)/dxr.config: $(SCRAM_CONFIGDIR)/dxr.config
	@$(CMD_sed) -e "s|@LOCALTOP@|$$LOCALTOP|g" $< > $@ && $(CMD_echo) ">> Regenerated $@"
else
dxr:
	@$(CMD_echo) "**** ERROR: py2-dxr tool not available."
endif
enable-biglib:
	@$(CMD_rm) -f $(SCRAM_ADMIN_DIR)/no-bigproduct && $(CMD_echo) "Building big products is activated."
	@$(call biglib_setup)
disable-biglib:
	@$(CMD_touch) $(SCRAM_ADMIN_DIR)/no-bigproduct && $(CMD_echo) "Building big products is deactivated."
	@$(call biglib_setup)
check-biglib:
	@if [ -f $(SCRAM_ADMIN_DIR)/no-bigproduct ] ; then \
	  $(CMD_echo) Big products build is disabled ;\
	else \
	  $(CMD_echo) Big products build is enabled ;\
	fi
deps-tree::
	@$(CMD_echo) "Finding all dependencies paths from package/tool '$(wordlist 1,1,$(filter-out deps-tree,$(MAKECMDGOALS)))' to package/tool '$(wordlist 2,2,$(filter-out deps-tree,$(MAKECMDGOALS)))'"
	@$(LOCALTOP)/$(SCRAM_CONFIGDIR)/SCRAM/find-deps-tree.pl $(DEPS_TREE_PACKAGE) $(DEPS_TREE_DEPENDENCY) $(LOCALTOP) $(RELEASETOP) $(FULL_RELEASE_FOR_A_PATCH)
$(LLVM_CCDB_EXT): FORCE_TARGET
	@$(CMD_cd) $(LOCALTOP) && $(MAKE) -f $(SCRAM_MAKEFILE) compile COMPILER=llvm SCRAM_GENERATE_LLVM_CCDB=YES &&\
	[ -d $(@D) ] || $(CMD_mkdir) -p $(@D) &&\
	$(SCRAM_CONFIGDIR)/SCRAM/llvm-ccdb.py $(LLVM_CCDB_EXT)
llvm-ccdb: $(LLVM_CCDB_EXT)
	@:
ifneq ($(strip $(filter code-checks code-checks-% code-cormat,$(MAKECMDGOALS))),)
-include $(SCRAM_CONFIGDIR)/SCRAM/GMake/Makefile.coderules
endif
ifneq ($(strip $(RELEASETOP)),)
ifeq ($(strip $(filter checkdeps,$(MAKECMDGOALS))),checkdeps)
-include $(SCRAM_CONFIGDIR)/SCRAM/GMake/Makefile.checkdeps
endif
endif

%:
	@$(if $(strip $(wildcard $@ $(RELEASETOP)/$@)),true,$(CMD_echo) $(if $(subst undefined,,$(origin $@)),$@ = $($@),Unknow target $@))
