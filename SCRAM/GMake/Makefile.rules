TARGETDIR:= $(subst /,_,$(THISDIR))
.DEFAULT_GOAL := all
##############################################################################
multipletools := info
wrongtool := info
comma:= ,
empty:= 
colon:= :
space:= $(epmty) $(empty)
prebuild       := 
postbuild      :=
prelibdeps     :=
prebindeps     :=
ALL_SCRAM_PROJECTS :=
ALL_SUBSYSTEMS     :=
ALL_PACKAGES       :=
ALL_PYTHON_DIRS    :=
ALL_EMPTY_PACKAGES :=
ALL_BUILDFILES     :=
ALL_TOOLS          :=
ALL_PRODS          :=
FAST:=
XFAST:=
UFAST:=
ONLYECHOTARGETS:=
OBJEXT:=o
MODULE_PREFIX:=lib
COMMON_WORKINGDIR := $(SCRAM_TMP)/common
WORKINGDIR := $(SCRAM_INTwork)
YACC                        := bison
LEX                         := flex
LATEX                       := latex
DVISUFFIX                   := dvi
PSSUFFIX                    := ps
PDFSUFFIX                   := pdf
PS2PDF                      := ps2pdf
DVIPS                       := dvips
LD                          := ld
LD_UNIT                     := -r -m elf_i386
LD_UNIT_FLAGS               := -z muldefs
BIGLIB_OBJEXT               := obj
OLD_TIMESTAMP:=198001010100
###################################
ifndef CXX
CXX:=g++
endif
ifndef CC
CC:=gcc
endif
ifndef FC
FC:=g77
endif
ifndef JAVAC
JAVAC:=javac
endif
AR                          := /bin/ar
SHELL                       := /bin/sh
UNAME                       := $(shell uname)
ifeq ($(filter-out osx%,$(SCRAM_ARCH)),)
SHAREDSUFFIX                := dylib
else
SHAREDSUFFIX                := so
endif
ifeq ($(filter-out slc%,$(SCRAM_ARCH)),)
MODULEFLAGS                 := -shared
endif
MODULE_SUFFIX               := $(SHAREDSUFFIX)
SHARED_LIB_LOAD_CHECK       := 
##############################################################################
ifndef SCRAMSTORENAME_LIB
SCRAMSTORENAME_LIB:=lib
endif
ifeq ($(strip $(SCRAM_SOURCEDIR)),)
SCRAM_SOURCEDIR:=src
endif

ifneq ($(strip $(QT_BASE)),)
QTMOC := $(QT_BASE)/bin/moc
else
QTMOC := moc
endif

ifneq ($(wildcard $(WORKINGDIR)/cache/bf/$(SCRAM_CONFIGDIR)/$(SCRAM_BUILDFILE)),)
CONFIGDEPS += $(WORKINGDIR)/cache/bf/$(SCRAM_CONFIGDIR)/$(SCRAM_BUILDFILE)
endif
CONFIGDEPS += $(WORKINGDIR)/cache/xlibs

ifndef SCRAM_BUILDVERBOSE
VERB:=@
VERB_ECHO:=:
else
VERB:=
VERB_ECHO:=echo
endif

ifeq ($(strip $(BUILD_LOG)),yes)
DO_BUILD_LOG:=
else
DO_BUILD_LOG:=:
endif

ifneq ($(findstring k,$(firstword  $(MAKEFLAGS))),)
FORCE_BUILD_START = (
FORCE_BUILD_END = ) || (echo gmake: \*\*\* [$@] Error $$? ; exit 0)
else
ifeq ($(strip $(BUILD_LOG)),yes)
FORCE_BUILD_START = (
FORCE_BUILD_END = ) || (exitcode=$$?; echo gmake: \*\*\* [$@] Error $$exitcode ; exit $$exitcode)
else
FORCE_BUILD_START =
FORCE_BUILD_END =
endif
endif

PSR_BASE_TARGET:=
ifneq ($(strip $(MAKECMDGOALS)),)
ifeq ($(strip $(MAKECMDGOALS)),release)
PSR_BASE_TARGET := $(SCRAM_SOURCEDIR)
endif
ifeq ($(strip $(MAKECMDGOALS)),release-build)
PSR_BASE_TARGET := $(SCRAM_SOURCEDIR)
endif
else
ifeq ($(strip $(TARGETDIR)),src)
PSR_BASE_TARGET := $(TARGETDIR)
else
PSR_BASE_TARGET := all_$(TARGETDIR)
endif
endif

$(SCRAM_SOURCEDIR) :=

##############################################################################
define set_cached_var_func_arg_
cached_var_func_arg$(cached_var_func_arg_count_$(1))_$(1) := $(2)
cached_var_func_arg_count_$(1) := $(cached_var_func_arg_count_$(1))1
endef
define set_cached_var_
cached_var_func_arg_count_$(1) := 
$(foreach arg,$(subst $(comma),$(space),$(cached_var_function_$(1))),$(eval $(call set_cached_var_func_arg_,$(1),$(arg))))
cached_var_$(1) := $(call $(cached_var_func_arg_$(1)),$(cached_var_func_arg1_$(1)),$(cached_var_func_arg11_$(1)),$(cached_var_func_arg111_$(1)),$(cached_var_func_arg1111_$(1)),$(cached_var_func_arg11111_$(1)))
endef
define get_cached_var_
$(if $(subst undefined,,$(origin cached_var_$(1))),$(cached_var_$(1)),$(eval $(call set_cached_var_,$(1)))$(cached_var_$(1)))
endef
define get_uniq_cached_var_
$(if $(subst undefined,,$(origin cached_var_$(1))),$(cached_var_$(1)),$(eval $(call set_cached_var_,$(1)))$(eval cached_var_$(1):=$(call Uniq,$(cached_var_$(1))))$(cached_var_$(1)))
endef
##############################################################################
define GetTimeStamp
perl -e '@d=stat "$(1)"; print "$$d[9]\n";'
endef
define Uniq
$(eval uniq_string_:=)$(strip $(foreach v,$(1),$(if $(filter $(v),$(uniq_string_)),,$(eval uniq_string_+=$(v))))$(uniq_string_))
endef
define AddCachedVariable
cached_var_function_$(1)  := $(subst $(colon),$(comma),$(2))
ifeq ($$(strip $(3)),)
$(1) = $$(call get_cached_var_,$(1))
else
$(1) = $$(call get_uniq_cached_var_,$(1))
endif
endef
define GetVariable
$($(1))
endef
define ToolCXXFlags
$(CXXFLAGS) $($(1)_LOC_FLAGS_CXXFLAGS_ALL) $(USER_CXXFLAGS)
endef
define ToolFFlags
$(FFLAGS) $($(1)_LOC_FLAGS_FFLAGS_ALL) $(USER_FFLAGS)
endef
define ToolCFlags
$(CFLAGS) $($(1)_LOC_FLAGS_CFLAGS_ALL) $(USER_CFLAGS)
endef
define ToolCPPFlags
$(CPPFLAGS) $(CPPDEFINES) $($(1)_LOC_FLAGS_CPPDEFINES_ALL) $($(1)_LOC_FLAGS_CPPFLAGS_ALL) $(USER_CPPFLAGS) $(USER_CPPDEFINE) $(addprefix -I,$(INCLUDE)) $(addprefix -I,$($(1)_LOC_INCLUDE_ALL))
endef
define ToolLDFlags
$(USER_LDFLAGS) $(LDFLAGS) $(addprefix -L,$(LIBDIR) $(filter-out $(LIBDIR),$(filter $(LOCALTOP)/%,$($(1)_LOC_FLAGS_LIBDIR_ALL)))) $(addprefix -l,$(LIB)) $(addprefix -l,$($(1)_LOC_LIB_ALL)) $($(1)_LOC_FLAGS_LDFLAGS_ALL)
endef
define ScramOrderedTools
$(if $(strip $(SCRAM_PROJECTS)),$(warning Calculationg ScramOrderedTools)$(shell echo $(foreach t,$(SCRAM_PROJECTS),$($(t)_ORDER):$(t)) | tr ' ' '\n' | sort -r | sed 's|.*:||'),$(warning Calculationg ScramOrderedTools))
endef
define CalculateToolOrder
$(if $(strip $($(1)_LOC_USE)),$(shell perl \-e '@z=($(2) $(foreach dep,$(foreach d,$($(1)_LOC_USE),$($d)),$(comma)$($(dep)_ORDER))); @z=sort {$$a <=> $$b} @z;$$x=$$z[0];$$x--;print "$$x";'),$(2))
endef
define FindToolDependency
$(sort $(foreach dep,$(foreach d,$($(1)_$(2)_USE),$($d)),$(dep) $($(dep)_EX_USE_ALL)))
endef
define FindUOLibDependency
$(sort $(foreach d,$($(1)_LOC_USE) $($(1)_EX_USE),$($($d)_EX_LIB) $($($d)_EX_UOLIB)))
endef
define FindToolDepVariable
$($(1)_$(3)_$(2)) $(foreach var,$(sort $(foreach dep,$($(1)_$(3)_USE_ALL),$($(dep)_ORDER):$(strip $(subst $(space),$(colon),$($(dep)_EX_$(2)))))),$(wordlist 2,99999,$(subst $(colon),$(space),$(var))))
endef
define ProductCommonVars
ifeq ($$(strip $(3)),)
$$(eval $$(call AddCachedVariable,$(1)_ORDER,CalculateToolOrder:$(1):$(if $(strip $(2)),$(strip $(2)),99999),))
else
$(1)_ORDER:=$(3)
endif
$$(foreach scope,EX LOC,$$(foreach type,INCLUDE LIB LIBDIR FLAGS_CPPDEFINES FLAGS_CPPFLAGS FLAGS_CXXFLAGS FLAGS_LDFLAGS FLAGS_CFLAGS FLAGS_FFLAGS,$$(eval $$(call AddCachedVariable,$(1)_$$(scope)_$$(type)_ALL,FindToolDepVariable:$(1):$$(type):$$(scope),1))))
$$(foreach scope,EX LOC,$$(eval $$(call AddCachedVariable,$(1)_$$(scope)_USE_ALL,FindToolDependency:$(1):$$(scope),)))
$$(eval $$(call AddCachedVariable,$(1)_CXXFLAGS,ToolCXXFlags:$(1),))
$$(eval $$(call AddCachedVariable,$(1)_CPPFLAGS,ToolCPPFlags:$(1),))
$$(eval $$(call AddCachedVariable,$(1)_FFLAGS,ToolFFlags:$(1),))
$$(eval $$(call AddCachedVariable,$(1)_CFLAGS,ToolCFlags:$(1),))
$$(eval $$(call AddCachedVariable,$(1)_LDFLAGS,ToolLDFlags:$(1),))
$(foreach err,$(foreach use,$(sort $($(1)_LOC_USE) $($(1)_EX_USE)),$(if $($(use)),,$(use))),$(eval $(4)_USE_ERR+=$(err)))
endef
define ProductCommonVarsExternal
ifneq ($$(strip $$($(1)_BuildFile)),)
$$(eval $$(call AddCachedVariable,$(1)_ORDER,CalculateToolOrder:$(1):99999,))
$$(foreach type,INCLUDE LIB,$$(eval $$(call AddCachedVariable,$(1)_EX_$$(type)_ALL,FindToolDepVariable:$(1):$$(type):EX,1)))
$$(eval $$(call AddCachedVariable,$(1)_EX_USE_ALL,FindToolDependency:$(1):EX,))
$$(eval $$(call AddCachedVariable,$(1)_EX_UOLIB,FindUOLibDependency:$(1):,))
else
$(1)_ORDER:=99999
endif
endef
define outputlog
  @if [ -d $(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR)/$(1) ] ; then \
    $(DO_BUILD_LOG) for f in `find $(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR)/$(1) -name "*" -type f | grep -v  '/build\.log$$'` ; $(DO_BUILD_LOG) do $(DO_BUILD_LOG) cat $$f $(redirectlog_$(2)) ; $(DO_BUILD_LOG) rm -f $$f;  $(DO_BUILD_LOG) done ;\
  fi
endef
##############################################################################
define BuildClean
  if [ "X$(1)" != "X" ] ; then \
    if [ -d $(WORKINGDIR)/$(1) ] ; then \
      regexp=$2; \
      if [ "X$$regexp" == "X" ] ; then regexp='[0-9][0-9]'; fi ;\
      find $(WORKINGDIR)/$(1) -name "AUTOCLEAN.*.clean" -type f | xargs cat | grep "^$$regexp:" | sort | uniq | sed "s|^$$regexp:||" > $(WORKINGDIR)/$(1)/.AUTOCLEAN ; \
      if [ "X$3" == "X" ] ; then cat $(WORKINGDIR)/$(1)/.AUTOCLEAN; fi;\
      sh $(WORKINGDIR)/$(1)/.AUTOCLEAN;\
      rm -rf $(WORKINGDIR)/$(1); \
    fi;\
  fi
endef

define AutoCleanFile
$(dir $(1))/AUTOCLEAN.$(notdir $(1)).$(2).clean
endef
##############################################################################
# Macros for pre/post build steps:
define copy_build_product
  if [ ! -d $(LOCALTOP)/$(1) ]; then 	\
    mkdir -p $(LOCALTOP)/$(1)	&&\
    echo "Creating product storage directory: $(LOCALTOP)/$(1)"; \
  fi &&\
  echo "Copying $@ to productstore area:" &&\
  echo "01:rm -f $(1)/$(@F)" > $(call AutoCleanFile,$@,prod) &&\
  cp $@ $(LOCALTOP)/$(1) || (rm -f $@ && echo ">> Deleted: $@" && exit 1)
endef

define copy_lib_to_main_productstore
  $(call copy_build_product,$(1))
endef

define copy_bigobj_to_main_productstore
  $(call copy_build_product,$(1))
endef

define copy_bin_to_main_productstore
  $(call copy_build_product,$(1))
endef

define copy_test_to_main_productstore
  $(call copy_build_product,$(1))
endef

define copy_py_to_main_productstore
  $(call copy_build_product,$(1))
endef

define copy_java_to_java_productstore
  $(startlog_$(2)) clean=$(call AutoCleanFile,$($(1)_workdir)/$(1),java); echo "" > $$clean ;\
  for f in `ls $($(1)_workdir)/ | grep -v '.done$$\|AUTOCLEAN.'`; do \
    echo ">> Copying $$f => $(LOCALTOP)/$(3)" ;  \
    cp -rpf $($(1)_workdir)/$$f $(LOCALTOP)/$(3)/ ; \
    echo "01:rm -rf $(3)/$$f" >> $$clean;\
  done $(endlog_$(2))
endef

define delete_build_prod 
  rm -f $@ $(LOCALTOP)/$(1)/$(@F)
endef

define delete_plugin_build_prod 
  $(call delete_build_prod,$(1)) &&\
  if [ "X$(2)" != X ] ; then \
    if [ -f $($(2)_pluginprod) ] ; then \
      touch $(LOCALTOP)/$(SCRAM_INTwork)/cache/$($(2)_plugintype)_$($(2)_pluginrefresh) &&\
      rm -f $($(2)_pluginprod) ;\
    fi ;\
  fi
endef

define	clean_path
  @if [ -d $(LOCALTOP)/$(1) ] ; then \
    echo "Cleaning local working directory:$(1)"; \
    /bin/rm -rf $(LOCALTOP)/$(1) ; \
  fi
endef

define clean_prod
  @if [ -f $(LOCALTOP)/$(1) ] ; then \
    echo "Cleaning product: $(1)" ; \
    /bin/rm -f $(LOCALTOP)/$(1); \
  fi    
endef

define clean_src_scripts
  @$(call clean_files,$(1),$(2))
endef

define clean_files
  for f in $(1); do \
    /bin/rm -rf $(LOCALTOP)/$(2)/$$f;	\
  done
endef
define iglet_plugin_clean
  $(call clean_prod,$($(1)_pluginprod))
endef

define edm_plugin_clean
  $(call clean_prod,$($(1)_plugindir)/plugin$(1).$(SHAREDSUFFIX))
  $(call clean_prod,$($(1)_pluginprod))
endef

define seal_plugin_clean
  $(call clean_prod,$($(1)_plugindir)/$(MODULE_PREFIX)$(1).$(SHAREDSUFFIX))
  $(call clean_prod,$($(1)_pluginprod))
endef

define do_plugin_refresh
    if [ "X$(PSR_BASE_TARGET)" = X ] ; then \
      $(call do_$(1),$(2));\
    fi
endef
#############################################################################
##############################################################################
define check_module_load
  if [ "X$(SHARED_LIB_LOAD_CHECK)" != X ] ; then \
    if [ "X$(1)" = X ] ; then \
      echo "@@@@ Checking shared library load: $(@F)"	&&\
      ($(SHARED_LIB_LOAD_CHECK) $@ || ($(call delete_plugin_build_prod,$(2),$(3)) && exit 1)) &&\
      echo "@@@@ ----> OK, shared library loaded successfully: $(@F)" ; \
    else \
      echo "@@@@ Shared library loading was SKIPPED due to NO_LIB_CHECKING flag in BuildFile: $(@F)"; \
    fi ;\
  else \
    echo "@@@@ Shared library loading was SKIPPED due to SCRAM_NOLOADCHECK: $(@F)" ;\
  fi
endef

ifndef SCRAM_NOSYMCHECK
define check_missing_symbols
  if [ "X$(1)" = X ] ; then \
    echo "@@@@ Checking shared library for missing symbols: $(@F)" &&\
    echo "int main(){}" > $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp  &&\
    $(VERB_ECHO) $(CXX) $(CXXFLAGS) $(CXXSHAREDOBJECTFLAGS) $(LDFLAGS) -o $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).out $@ $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp &&\
    ($(CXX) $(CXXFLAGS) $(CXXSHAREDOBJECTFLAGS) $(LDFLAGS) -o $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).out $@ $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp || (rm -f $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).out && $(call delete_plugin_build_prod,$(2),$(3)) && exit 1)) &&\
    rm -f $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).out	&&\
    echo "@@@@ ----> OK, shared library FULLY-BOUND (no missing symbols): $(@F)" ; \
  else \
    echo "@@@@ Checking for missing symbols was SKIPPED due to NO_LIB_CHECKING flag in BuildFile: $(@F)"; \
  fi
endef
else
define check_missing_symbols
  echo "@@@@ Checking for missing symbols was SKIPPED due to SCRAM_NOSYMCHECK: $(@F)"
endef
endif

ifndef SCRAM_NOPLUGINREFRESH
define iglet_register_plugin
  @$(startlog_$(2))touch $(LOCALTOP)/$(SCRAM_INTwork)/cache/iglet_$($(1)_pluginrefresh) &&\
  if [ -f $< ] ; then \
    [ -d $(@D) ] || mkdir -p $(@D) &&\
    cp -f $< $@ &&\
    echo "01:rm -f $@"               > $(call AutoCleanFile,$<,iglet) &&\
    echo "90:IgPluginRefresh $(@D)" >> $(call AutoCleanFile,$<,iglet) &&\
    echo "--- Registered IgLet Plugin: $(1)"; \
  else \
    rm -f $@ ;\
  fi &&\
  $(call do_plugin_refresh,$($(1)_pluginrefresh),$(@D)) $(endlog_$(2))
endef

define edm_register_plugin
  @$(startlog_$(2)) touch $(LOCALTOP)/$(SCRAM_INTwork)/cache/edm_$($(1)_pluginrefresh) &&\
  if [ -f $< ] ; then \
    [ -d $(@D) ] || mkdir -p $(@D) &&\
    (touch $(@D)/$($(1)_plugincache) || true) &&\
    plugin=$(patsubst lib%,plugin%,$(<F)) &&\
    cp -f $< $(<D)/$$plugin &&\
    echo "module $$plugin" > $(<D)/$(@F) &&\
    (cp -f $(@D)/$($(1)_plugincache) $(<D) || touch $(<D)/$($(1)_plugincache)) &&\
    ($($(1)_pluginrefresh) $(<D)/$$plugin || (rm -f $< $(<D)/$$plugin && exit 1)) &&\
    rm -f $(<D)/$$plugin &&\
    cp -f $< $(@D)/$$plugin &&\
    cp -f $(<D)/$(@F) $@ &&\
    echo "01:rm -f $(@D)/$$plugin $@" > $(call AutoCleanFile,$<,edm) &&\
    echo "90:EdmPluginRefresh $(@D)" >> $(call AutoCleanFile,$<,edm) &&\
    (mv $(<D)/$($(1)_plugincache) $(@D) || true ) &&\
    echo "--- Registered EDM Plugin: $(1)"; \
  else \
    rm -f $@ $(@D)/$(patsubst lib%,plugin%,$(<F)) ;\
  fi &&\
  $(call do_plugin_refresh,$($(1)_pluginrefresh),$(@D)) $(endlog_$(2))
endef

define seal_register_plugin
  @$(startlog_$(2))touch $(LOCALTOP)/$(SCRAM_INTwork)/cache/seal_$($(1)_pluginrefresh) &&\
  if [ -f $< ] ; then \
    [ -d $(@D) ] || mkdir -p $(@D) &&\
    echo 'module $(MODULE_PREFIX)$(1).$(SHAREDSUFFIX)' > $@ &&\
    echo "01:rm -f $@"                 > $(call AutoCleanFile,$<,seal) &&\
    echo "90:SealPluginRefresh $(@D)" >> $(call AutoCleanFile,$<,seal) &&\
    echo "--- Registered Seal Plugin: $(1)"; \
  else \
    rm -f $@ ;\
  fi &&\
  $(call do_plugin_refresh,$($(1)_pluginrefresh),$(@D)) $(endlog_$(2))
endef
else
define iglet_register_plugin
  @$(startlog_$(2))touch $(LOCALTOP)/$(SCRAM_INTwork)/cache/iglet_$($(1)_pluginrefresh) &&\
  if [ -f $< ] ; then \
    [ -d $(@D) ] || mkdir -p $(@D) &&\
    cp -f $< $@ &&\
    echo "01:rm -f $@"               > $(call AutoCleanFile,$<,iglet) &&\
    echo "90:IgPluginRefresh $(@D)" >> $(call AutoCleanFile,$<,iglet) &&\
    echo "--- Registered IgLet Plugin: $(1)"; \
  else \
    rm -f $@ ;\
  fi $(endlog_$(2))
endef

define edm_register_plugin
  @$(startlog_$(2)) touch $(LOCALTOP)/$(SCRAM_INTwork)/cache/edm_$($(1)_pluginrefresh) &&\
  if [ -f $< ] ; then \
    [ -d $(@D) ] || mkdir -p $(@D) &&\
    plugin=$(patsubst lib%,plugin%,$(<F)) &&\
    echo "module $$plugin" > $(<D)/$(@F) &&\
    cp -f $< $(@D)/$$plugin &&\
    cp -f $(<D)/$(@F) $@ &&\
    echo "01:rm -f $(@D)/$$plugin $@" > $(call AutoCleanFile,$<,edm) &&\
    echo "90:EdmPluginRefresh $(@D)" >> $(call AutoCleanFile,$<,edm) &&\
    echo "--- Registered EDM Plugin: $(1)"; \
  else \
    rm -f $@ $(@D)/$(patsubst lib%,plugin%,$(<F)) ;\
  fi $(endlog_$(2))
endef

define seal_register_plugin
  @$(startlog_$(2))touch $(LOCALTOP)/$(SCRAM_INTwork)/cache/seal_$($(1)_pluginrefresh) &&\
  if [ -f $< ] ; then \
    [ -d $(@D) ] || mkdir -p $(@D) &&\
    echo 'module $(MODULE_PREFIX)$(1).$(SHAREDSUFFIX)' > $@ &&\
    echo "01:rm -f $@"                 > $(call AutoCleanFile,$<,seal) &&\
    echo "90:SealPluginRefresh $(@D)" >> $(call AutoCleanFile,$<,seal) &&\
    echo "--- Registered Seal Plugin: $(1)"; \
  else \
    rm -f $@ ;\
  fi $(endlog_$(2))
endef
endif
##############################################################################
#Compilation Rules
# CXX compilation
define compile_cxx
@$(startlog_$(2))mkdir -p $(@D) &&\
  echo ">> Compiling $< " &&\
  $(VERB_ECHO) $(CXX) -MMD  -c $($(1)_CPPFLAGS) $($(1)_CXXFLAGS) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $< -o $@ &&\
  $(CXX) -MMD  -c $($(1)_CPPFLAGS) $($(1)_CXXFLAGS) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $< -o $@  $(endlog_$(2))
endef  
# C compilation
define compile_c
  @$(startlog_$(2))mkdir -p $(@D) &&\
  echo ">> Compiling $< " &&\
  $(VERB_ECHO) $(CC) -MMD  -c $($(1)_CPPFLAGS) $($(1)_CFLAGS) $(COPTIMISEDFLAGS) $(CSHAREDOBJECTFLAGS) $< -o $@ &&\
  $(CC)  -c $($(1)_CPPFLAGS) $($(1)_CFLAGS) $(COPTIMISEDFLAGS) $(CSHAREDOBJECTFLAGS) $< -o $@ $(endlog_$(2))
endef  
# Fortran compilation
define compile_fortran
  @$(startlog_$(2))mkdir -p $(@D) &&\
  echo ">> Compiling $< " &&\
  $(VERB_ECHO) $(FC) -MMD -c $($(1)_CPPFLAGS) $($(1)_FFLAGS) $(FOPTIMISEDFLAGS) $(FCSHAREDOBJECTFLAGS) $< -o $@ &&\
  $(FC) -MMD -c $($(1)_CPPFLAGS) $($(1)_FFLAGS) $(FOPTIMISEDFLAGS) $(FCSHAREDOBJECTFLAGS) $< -o $@ $(endlog_$(2))
endef  
# Boost c++ source compilation
define compile_boost
  @$(startlog_$(2))mkdir -p $(@D) &&\
  echo ">> Compiling $< " &&\
  $(VERB_ECHO) $(CXX) -MMD  -c -DSCRAM_PYTHON_MODULE="BOOST_PYTHON_MODULE($*)" $($(1)_CPPFLAGS) $($(1)_PY_CXXFLAGS) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $< -o $@ &&\
  $(CXX) -MMD  -c -DSCRAM_PYTHON_MODULE="BOOST_PYTHON_MODULE($*)" $($(1)_CPPFLAGS) $($(1)_PY_CXXFLAGS) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $< -o $@ $(endlog_$(2))
endef  
# Boost c++ pywrapper compilation
define compile_pywrapper
  @$(startlog_$(2))echo "Generating and compiling wrapper file: " &&\
  mkdir -p $(@D)  &&\
  echo ">> Compiling $< " &&\
  $(VERB_ECHO) $(CXX) -MMD  -c -DSCRAM_PYTHON_MODULE="BOOST_PYTHON_MODULE($(1)_PyWrapper)" $($(1)_CPPFLAGS) $($(1)_PY_CXXFLAGS) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $< -o $@ &&\
  $(CXX) -MMD  -c -DSCRAM_PYTHON_MODULE="BOOST_PYTHON_MODULE($(1)_PyWrapper)" $($(1)_CPPFLAGS) $($(1)_PY_CXXFLAGS) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $< -o $@$(endlog_$(2))
endef  
# Dictionary compilation
define compile_lcgdict
  @$(startlog_$(2))mkdir -p $(@D) &&\
  echo ">> Compiling for LCG dictionary: $<" &&\
  $(VERB_ECHO) $(CXX) -MMD  -c $($(1)_CPPFLAGS) `echo "$($(1)_CXXFLAGS)" | tr ' ' '\n' | grep -v '^-O[0-9s]*$$' | tr '\n' ' '` -Os $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $(1)/$(patsubst $($(1)_objdir)/%,%,$<) -o $(1)/$(patsubst $($(1)_objdir)/%,%,$@) &&\
  ((cd $($(1)_objdir)/..; $(CXX) -MMD  -c $($(1)_CPPFLAGS) `echo "$($(1)_CXXFLAGS)" | tr ' ' '\n' | grep -v '^-O[0-9s]*$$' | tr '\n' ' '` -Os $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $(1)/$(patsubst $($(1)_objdir)/%,%,$<) -o $(1)/$(patsubst $($(1)_objdir)/%,%,$@)) || (rm -f $< && exit 1)) $(endlog_$(2))
  @$(startlog_$(2))[ -f $(basename $@).d ] && sed -e 's#^.*/$(3).o:#$<:#g' -e 's# .*$(3).cc ##g' $(basename $@).d | grep -v '^ *\\$$' > $<.d &&\
  if [ -f $<.d ] ; then sed -i -e 's|$(LOCALTOP)/||' $<.d ; rm -f $(basename $@).d; fi $(endlog_$(2))
endef
# Root Dictionary compilation
define compile_rootdict
  @$(startlog_$(2))mkdir -p $(@D) &&\
  echo ">> Compiling for root dictionary: $< " &&\
  $(VERB_ECHO) $(CXX) -MMD -c $($(1)_CPPFLAGS) $($(1)_CXXFLAGS) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $< -o $@ &&\
  ($(CXX) -MMD -c $($(1)_CPPFLAGS) $($(1)_CXXFLAGS) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $< -o $@ || (rm -f $< && exit 1)) $(endlog_$(2))
  @$(startlog_$(2))[ -f $(basename $@).d ] && sed -e 2d -e 's#^[ ]\\##g' -e 's#LinkDef.o:#LinkDef.cc:#g' -e 's#LinkDef.cc #LinkDef.cc: #g' \
  $(basename $@).d > $<.d &&\
  if [ -f $<.d ] ; then sed 's|$(LOCALTOP)/||' $<.d > $<.d.backup ; mv $<.d.backup $<.d; fi $(endlog_$(2))
endef
# compiling java
define compile_java
  @$(startlog_$(2))mkdir -p $(@D) &&\
  echo ">> Compiling java: $< " &&\
  $(VERB_ECHO) $(JAVAC) -source 1.4 -classpath $(@D):$$CLASSPATH -d $(@D) $< &&\
  $(JAVAC) -source 1.4 -classpath $(@D):$$CLASSPATH -d $(@D) $< &&\
  touch $@ $(endlog_$(2))
endef
# compiling python
define compile_python
  @$(startlog_$(2)) [ -d $(@D) ] || mkdir -p $(@D) ;\
  touch -t $(OLD_TIMESTAMP) $@ &&\
  echo "01:find $(4)/ -name '*_cf[if].pyc' -type f 2>/dev/null | xargs rm -f " > $(call AutoCleanFile,$@,python) &&\
  msg=no;\
  err=0;\
  for mod in `find $(4)/ -name '*_cf[if].py' -type f | sed 's|^$(4)/*||;s|.py$$||'`; do \
    pyc=$(4)/$$mod.pyc ;\
    py=$(4)/$$mod.py ;\
    if [ ! -f $$pyc ] || [ "X`$(call timestamp_cmp,$$py,$$pyc)`" != "X0" ] ;  then \
      [ "X$$msg" = "Xyes" ] || echo ">> Compiling python scripts: $(4)" && msg=yes ;\
      echo ">> Compiling: $$py";\
      if [ "`echo $$mod | grep '/'`X" == "X" ] ; then \
        $(VERB_ECHO) "python -c import $3.$$mod";\
	(python -c "import $3.$$mod" && [ -f $$pyc ] && touch -r $$py $$pyc) || err=1 ;\
      else \
        moddir=`dirname $$mod`; mod=`basename $$mod`;\
        $(VERB_ECHO) "python -c import $$mod";\
        ((cd $(4)/$$moddir && python -c "import $$mod") && [ -f $$pyc ] && touch -r $$py $$pyc) || err=1 ;\
      fi;\
    fi;\
  done $(endlog_$(2))
endef

##############################################################################
# Source Generators Rules
# boost source generation from Pyste
define pyste2boost
  @$(startlog_$(2))mkdir -p $(@D) &&\
  echo  ">> Generating and compiling Boost stub for module $*" 	&& \
  $(VERB_ECHO) python $(PYSTE_EXEC) -D_REENTRANT $($(1)_CPPFLAGS) --out=$@ --module=$* $< &&\
  python $(PYSTE_EXEC) -D_REENTRANT $($(1)_CPPFLAGS) --out=$@ --module=$* $< $(endlog_$(2))
endef  
# PyWrapper Generation
define generate_pywrapper
  @$(startlog_$(2))echo "Generating wrapper code to put the following files in a single module called: $(1)" $(endlog_$(2))
  @exec 5>&1;	\
  ( echo "#include <boost/python.hpp>"; echo;	\
  for c in $($(1)_classnames) ..; do		\
    case $$c in .. ) continue ;; esac ;		\
    echo "  $$c" 1>&5;				\
    echo "extern void init_module_$$c ();";	\
  done;						\
  echo; echo "void init_module_$(1) () {";	\
  for c in $($(1)_classnames) ..; do		\
    case $$c in .. ) continue ;; esac ;		\
    echo "  init_module_$$c ();";		\
  done;						\
  echo "}"; echo;				\
  echo "extern \"C\" void init$(1) () {";	\
  echo 'boost::python::detail::init_module("$(1)",'\
	'init_module_$(1));';			\
  echo "}";					\
  ) > $@.tmp
  @mv $@.tmp $@
endef  
#LCG dictionary generation
define generate_lcgdict
  @$(startlog_$(2))mkdir -p $(@D) &&\
  echo ">> Building LCG reflex dict from header file $4" &&\
  $(VERB_ECHO) $(GENREFLEX) $(4) -s $(3) -o $@ $($(6)_GENREFLEX_ARGS) --gccxmlpath=$(GCCXML_BASE)/bin --capabilities=$(notdir $(5)) -DCMS_DICT_IMPL -D_REENTRANT -DGNU_SOURCE $($(1)_CPPFLAGS) &&\
  ($(GENREFLEX) $(4) -s $(3) -o $@ $($(6)_GENREFLEX_ARGS) --gccxmlpath=$(GCCXML_BASE)/bin --capabilities=$(notdir $(5)) -DCMS_DICT_IMPL -D_REENTRANT -DGNU_SOURCE $($(1)_CPPFLAGS) || (rm -f $@ $(@D)/$(5) && exit 1))$(endlog_$(2))
endef
# ROOt dictionary generation
define generate_rootdict
  @$(startlog_$(2))mkdir -p $(@D) &&\
  echo ">> Building Root dict from header file $< " &&\
  $(VERB_ECHO) $(ROOTCINT) -f $@ -c -p -DGNU_SOURCE $($(1)_CPPFLAGS) $< &&\
  ($(ROOTCINT) -f $@ -c -p -DGNU_SOURCE $($(1)_CPPFLAGS) $< || (rm -f $@ && exit 1)) &&\
  mv $@ $@.base	&&\
  cat $< $@.base > $@ &&\
  rm -f $@.base $(endlog_$(2))
endef
# CodeGen record Generation
define generate_codegen_record
  @$(startlog_$(2))mkdir -p $(@D) &&\
  echo ">> Generating file $(@F) from class descriptor $<" &&\
  $(VERB_ECHO) $($(1)_CODEGENPY) $(1) $($(1)_objdir) $< &&\
  $($(1)_CODEGENPY) $(1) $($(1)_objdir) $< $(endlog_$(2))
endef
# MOC generation
define generate_moc
  @$(startlog_$(2))mkdir -p $(@D) &&\
  echo ">> Running moc for $<" &&\
  $(QTMOC) -o $@ $< $(endlog_$(2))
endef
# Flex Generaton
define generate_lex
  @$(startlog_$(2))mkdir -p $(@D) &&\
  echo "Flex: Generating $@ from $<" &&\
  $(VERB_ECHO) $(LEX) -o$@ -P$(patsubst %lex,%,$*) $< &&\
  ($(LEX) -o$@ -P$(patsubst %lex,%,$*) $< || (rm -f $@ && exit 1))$(endlog_$(2))
endef
define generate_parse
  @$(startlog_$(2))mkdir -p $(@D) &&\
  echo "Bison: Generating $@ from $<" &&\
  $(VERB_ECHO) $(YACC) -p$(patsubst %parse,%,$*) --defines=$(basename $@).h -o$(basename $@).cc $< &&\
  ($(YACC) -p$(patsubst %parse,%,$*) --defines=$(basename $@).h -o$(basename $@).cc $< ||(rm -f $(basename $@).h $(basename $@).cc && exit 1)) &&\
  cd $(WORKINGDIR)/$(3) &&\
  rm -f $*parse.h && ln -s $(1)/$*parse.h $*parse.h $(endlog_$(2))
endef
##############################################################################
# Library linking Rules
# Shared library linking
define link_lib
  @$(startlog_$(2))echo ">> Building shared library $@" &&\
  touch $(WORKINGDIR)/cache/prod/lib$(1) &&\
  $(VERB_ECHO) $(CXX) $($(1)_CXXFLAGS) $(CXXSHAREDFLAGS) $($(1)_objs) -o $@ $(MODULEFLAGS) $($(1)_LDFLAGS) &&\
  ($(CXX) $($(1)_CXXFLAGS) $(CXXSHAREDFLAGS) $($(1)_objs) -o $@ $(MODULEFLAGS) $($(1)_LDFLAGS) || ($(call delete_plugin_build_prod,$(3),$(4)) && exit 1)) &&\
  if [ "X$($(1)_no_lib_copy)" = X ] ; then \
    $(call copy_lib_to_main_productstore,$(3)) ;\
  fi &&\
  $(call check_missing_symbols,$($(1)_libcheck),$(3),$(4)) $(endlog_$(2))
  @$(startlog_$(2))rm -f $@.dep && touch $@.dep &&\
  for dep in $(foreach d,$($(1)_objs:.$(OBJEXT)=.d),$d) ; do \
    if [ -f $$dep ] ; then sed 's|$(LOCALTOP)/||' $$dep >> $@.dep ; fi ; \
  done $(endlog_$(2))
  @tr ' ' '\012' <  $@.dep | sed -e 's/^'\\\\'$$//' -e '/^$$/ d' \
  -e '/:$$/ d' -e 's/$$/ :/' > $@.dep.new
  @sort $@.dep.new | uniq >> $@.dep
  @rm -f $@.dep.new
endef  
# Big Object Files
define big_obj
  @$(startlog_$(2))echo ">> Building big object file $@" &&\
  $(VERB_ECHO) $(LD) $(LD_UNIT) $(LD_UNIT_FLAGS) -o $@ $($(1)_objs) &&\
  ($(LD) $(LD_UNIT) $(LD_UNIT_FLAGS) -o $@ $($(1)_objs) || ($(call delete_build_prod,$(3)) && exit 1)) &&\
  $(call copy_bigobj_to_main_productstore,$(3)) $(endlog_$(2))
endef
#Shared library for Python bindings
define link_pylib
  @$(startlog_$(2))echo ">> Building Python module $($(1)_product)" && \
  touch $(WORKINGDIR)/cache/prod/lib$(1) &&\
  $(VERB_ECHO) $(CXX) $(CXXSHAREDFLAGS) $($(1)_objs) -o $@ $(MODULEFLAGS) $($(1)_CXXSharedLink) &&\
  ($(CXX) $(CXXSHAREDFLAGS) $($(1)_objs) -o $@ $(MODULEFLAGS) $($(1)_CXXSharedLink) || ($(call delete_build_prod,$(3)) && exit 1)) &&\
  $(call copy_lib_to_main_productstore,$(3)) $(endlog_$(2))
  @$(startlog_$(2))rm -f $@.dep && touch $@.dep &&\
  for dep in $(foreach d,$($(1)_objs:.$(OBJEXT)=.d),$d) ; do \
    if [ -f $$dep ] ; then sed 's|$(LOCALTOP)/||' $$dep >> $@.dep ; fi ; \
  done $(endlog_$(2))
  @tr ' ' '\012' <  $@.dep | sed -e 's/^'\\\\'$$//' -e '/^$$/ d' \
  -e '/:$$/ d' -e 's/$$/ :/' > $@.dep.new 
  @sort $@.dep.new | uniq >> $@.dep
  @rm -f $@.dep.new
endef  
#Shared Capabilities library
define link_capabilities
  @$(startlog_$(2))echo ">> ---- Building capability library $@" &&\
  $(VERB_ECHO) $(CXX) $($(1)_CXXFLAGS) $(CXXSHAREDFLAGS) $< -o $@ $(MODULEFLAGS) $($(4)_CDICT_LDFLAGS) &&\
  ($(CXX) $($(1)_CXXFLAGS) $(CXXSHAREDFLAGS) $< -o $@ $(MODULEFLAGS) $($(4)_CDICT_LDFLAGS) || ($(call delete_plugin_build_prod,$(3),$(4)) && exit 1)) &&\
  if [ "X$($(4)_no_lib_copy)" = X ] ; then \
    $(call copy_lib_to_main_productstore,$(3)) ;\
  fi &&\
  $(call check_missing_symbols,$($(1)_libcheck),$(3),$(4)) $(endlog_$(2))
endef

##############################################################################
# Binary/test building Rules
# Binary building 
define build_bin
  @$(startlog_$(2))echo ">> Building binary $(1)" &&\
  $(VERB_ECHO) $(CXX) $($(1)_CXXFLAGS) $(CXXSHAREDOBJECTFLAGS) $($(1)_objs) $($(1)_LDFLAGS) -o $@ &&\
  ($(CXX) $($(1)_CXXFLAGS) $(CXXSHAREDOBJECTFLAGS) $($(1)_objs) $($(1)_LDFLAGS) -o $@  || ($(call delete_build_prod,$(3)) && exit 1)) &&\
  $(call copy_bin_to_main_productstore,$(3)) $(endlog_$(2))
  @$(startlog_$(2))rm -f $@.dep && touch $@.dep &&\
  for dep in $(foreach d,$($(1)_objs:.$(OBJEXT)=.d),$d) ; do \
    if [ -f $$dep ] ; then sed 's|$(LOCALTOP)/||' $$dep >> $@.dep ; fi ; \
  done $(endlog_$(2))
  @tr ' ' '\012' <  $@.dep | sed -e 's/^'\\\\'$$//' -e '/^$$/ d' \
  -e '/:$$/ d' -e 's/$$/ :/' > $@.dep.new 
  @sort $@.dep.new | uniq >> $@.dep
  @rm -f $@.dep.new
endef
# Test executable building
define build_test
  $(call build_bin,$(1),$(2),$(3))
endef  

##############################################################################
# Data download and Copy
# Url download
define download_urls
  @$(startlog_$(2)) mkdir -p $(@D) && touch $@  &&\
  echo ">> Downloading and installing data files from WWW: $<" &&\
  dir=`dirname $< | sed 's|^src/|share/|'` && mkdir -p $$dir   &&\
  (wget -P $(LOCALTOP)/$$dir -a $(LOCALTOP)/$(3)/wwwdownload.log -i $< -N || (rm -f $@ && exit 1)) $(endlog_$(2))
endef  
# All Date dir to share
define copy_datadir
  @$(startlog_$(2))echo ">> Installing data files for $<"	&&\
  mkdir -p $(@D) &&\
  cp -rup $< $(@D) &&\
  for dir in `find $@ -name CVS -type d`; do \
    /bin/rm -rf $$dir ;\
  done &&\
  touch $@ $(endlog_$(2))
endef
define script_copy
  @$(startlog_$(2))mkdir -p $(@D) &&\
  /bin/rm -rf $@ &&\
  cp -rp $< $@	&&\
  echo ">> Copied $(@F)" $(endlog_$(2))
endef
define generate_python_bytecode
  if [ "X$(PYTHON_COMPILE)" != X ] ; then \
    echo ">> Generating python byte-code: $(1)" && \
    python $(PYTHON_COMPILE) -f $(1) >/dev/null 2>&1; \
  else \
    echo "Python tool is not used. So not going to generate byte-code." ; \
  fi
endef
define python_script_copy
  @$(startlog_$(2))if [ ! -d $(LOCALTOP)/$(3) ]; then \
    mkdir -p $(LOCALTOP)/$(3) &&\
    echo "Creating product storage directory: $(LOCALTOP)/$(3)"; 	\
  fi &&\
  rm -rf $($(1)_python_dir) && mkdir -p $($(1)_python_dir) &&\
  echo ">> Copying python/* to $($(1)_python_dir)" &&\
  for name in `ls $($(1)_srcdir) | grep -v "CVS\|BuildFile\|BuildFile.xml"` ; do \
    f=$($(1)_srcdir)/$$name &&\
    if [ -d $$f ] ; then \
      cp -rp $$f $($(1)_python_dir) || continue ;\
    else  \
      [ "X`echo $$f | grep '\.py$$'`" != X ] || continue ; \
      cp -rp $$f $($(1)_python_dir)/ || continue ;\
    fi \
  done &&\
  $(call generate_python_bytecode,$(LOCALTOP)/$($(1)_python_dir)) &&\
  for dir in `find $($(1)_python_dir) -name "*" -type d` ; do \
    if [ ! -f $$dir/__init__.py ] ; then \
      touch $$dir/__init__.py; \
    fi \
  done &&\
  touch $($(1)_python_dir)/__init__.py &&\
  touch $($(1)_python_dir)/../__init__.py $(endlog_$(2))
endef
define python_directory_link
  @$(startlog_$(2))if [ ! -d $(LOCALTOP)/$(3) ]; then \
    mkdir -p $(LOCALTOP)/$(3) &&\
    echo "Creating product storage directory: $(LOCALTOP)/$(3)"; 	\
  fi &&\
  if [ ! -e $($(1)_python_dir) ] ; then \
    subsysdir=`dirname $($(1)_python_dir)` &&\
    mkdir -p $$subsysdir &&\
    rellink=. &&\
    subsysdir1=$$subsysdir &&\
    while [ "$$subsysdir1" != "." ] ; do touch $$subsysdir/__init__.py; subsysdir1=`dirname $$subsysdir1`;  rellink=$$rellink/..; done &&\
    ln -s $$rellink/$(4) $($(1)_python_dir) &&\
    echo ">> Link created: $($(1)_python_dir) -> $($(1)_srcdir)" &&\
    for d in . `ls $($(1)_python_dir)` ; do \
      if [ -d $($(1)_python_dir)/$$d ] ; then \
        if [ ! -f $($(1)_python_dir)/$$d/__init__.py ] ; then \
	  echo "#this file was automatically created by SCRAM" > $($(1)_python_dir)/$$d/__init__.py;\
	fi ;\
      fi ;\
    done ;\
  fi $(endlog_$(2))
endef
define copy_src_scripts
  @$(startlog_$(2))echo "------- copying scripts from $(1) -------" &&\
  for f in $(3); do \
    [ -f $(LOCALTOP)/$(1)/$$f ] || continue ;\
    echo ">> Copying $(LOCALTOP)/$(1)/$$f"	&&\
    cp -p $(LOCALTOP)/$(1)/$$f  $(LOCALTOP)/$(4) || continue ;\
  done $(endlog_$(2))
endef
define src2store_copy
  @$(startlog_$(2)) echo "------- copying files from $(1) -------" &&\
  mkdir -p $(LOCALTOP)/$(4) &&\
  for f in $(3) ; do \
    if [ -d $(LOCALTOP)/$(4)/$$f ] ; then \
      rm -rf $(LOCALTOP)/$(4)/$$f; \
    fi &&\
    cp -rp $(LOCALTOP)/$(1)/$$f $(LOCALTOP)/$(4)/$$f &&\
    echo ">> copied $$f"; \
  done $(endlog_$(2))
endef
define copy_python_products
  @$(startlog_$(2))[ -d $(4) ] || (mkdir -p $(4) && echo ">> $(4) created") &&\
  cp $(3) $(4) $(endlog_$(2))
endef
#############################################################################
# Tesings test executable
define run_test
  @if [ ! -f $(LOCALTOP)/$(3)/testing.log ]; then \
    mkdir -p $(LOCALTOP)/$(3); \
    touch $(LOCALTOP)/$(3)/testing.log; \
    echo "Creating test log file"; \
  fi
  @echo "Package "$(patsubst src/%/test,%,$(3))": Running test $(1)"
  @rm -f $($(1)_objdir)/testing.log; touch $($(1)_objdir)/testing.log
  @echo " " >> $($(1)_objdir)/testing.log
  @echo "===== Test \"$(1)\" ====" >> $($(1)_objdir)/testing.log
  @$(LOCALTOP)/$(2)/$(1) $($(1)_TEST_RUNNER_ARGS) >> $($(1)_objdir)/testing.log 2>&1 || echo "---> test $(1) had ERRORS"
  @echo " " >> $($(1)_objdir)/testing.log
  @echo "^^^^ End Test $(1) ^^^^" >> $($(1)_objdir)/testing.log
  @cat $($(1)_objdir)/testing.log
  @cat $($(1)_objdir)/testing.log >> $(LOCALTOP)/$(3)/testing.log; rm -f $($(1)_objdir)/testing.log
endef

##############################################################################
# Rule Checker rukes
#Preprocessing C source
define rulechecker_preprocess_file_init
  if [ -f $($(1)_srcdir)/../interface/$*.h ] ; then \
    echo "$*.$(RULECHECKER_PREPROCESS_EXT) $< $($(1)_srcdir)/../interface/$*.h *$*.$(RULECHECKER_VIOLATION_EXT)*" >> $($(1)_objdir)/config_FILES_TO_ANALYZE.full ; \
  else \
    echo "$*.$(RULECHECKER_PREPROCESS_EXT) $< $($(1)_srcdir)/$*.h *$*.$(RULECHECKER_VIOLATION_EXT)*" >> $($(1)_objdir)/config_FILES_TO_ANALYZE.full ;\
  fi &&\
  rm -f $@.RULES_IGNORED; touch $@.RULES_IGNORED &&\
  for rule in `echo "$($(1)_RULES_IGNORED)" | tr ' ' '\n' | grep "$*.$(4):" | sed 's|$*.$(4):||' | tr ',' '\n'` ; do \
    echo "$$rule" >> $@.RULES_IGNORED;\
  done &&\
  if [ ! -s $@.RULES_IGNORED ] ; then \
    rm -f $@.RULES_IGNORED; \
  fi &&\
  rm -f $(LOCALTOP)/doc/RuleCheck/$(3)/$(*F).$(RULECHECKER_VIOLATION_EXT) &&\
  rm -f $(LOCALTOP)/doc/RuleCheck/$(3)/$(*F).err &&\
  if [ $(@D)/$(*F).d ] ; then \
    sed 's|.o: |.i: |' $(@D)/$(*F).d > $(@D)/$(*F).id ;\
  fi
endef
#Preprocessing C source
define preprocess_c
  @$(startlog_$(2)) mkdir -p $(@D) &&\
  echo ">> Preprocessing $<" &&\
  $(VERB_ECHO) $(CC)  -E $($(1)_CPPFLAGS) $($(1)_CFLAGS) $(COPTIMISEDFLAGS) $(CSHAREDOBJECTFLAGS) $< -o $@ &&\
  $(CC)  -E $($(1)_CPPFLAGS) $($(1)_CFLAGS) $(COPTIMISEDFLAGS) $(CSHAREDOBJECTFLAGS) $< -o $@ &&\
  $(call rulechecker_preprocess_file_init,$(1),$(2),$(3),$(4)) $(endlog_$(2))
endef
#Preprocessing CXX source
define preprocess_cxx
  @$(startlog_$(2)) mkdir -p $(@D) &&\
  echo ">> Preprocessing $<" &&\
  $(VERB_ECHO) $(CXX) -E $($(1)_CPPFLAGS) $($(1)_CXXFLAGS) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $< -o $@ &&\
  $(CXX) -E $($(1)_CPPFLAGS) $($(1)_CXXFLAGS) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $< -o $@ &&\
  $(call rulechecker_preprocess_file_init,$(1),$(2),$(3),$(4)) $(endlog_$(2))
endef
# Run Rule checker
define run_rule_checker
  @$(startlog_$(2)) cd  $($(1)_objdir) && touch quickExecution &&\
  for file in `cat config_FILES_TO_ANALYZE.full | awk '{print $$1}'`; do \
    line=`grep "^$$file " config_FILES_TO_ANALYZE.full` &&\
    patcharg=`echo $$line | sed 's|*.*||'` &&\
    src_file=`echo $$line | awk '{print $$2}'` &&\
    file_woext=`echo $$file | sed 's|\.$(RULECHECKER_PREPROCESS_EXT)$$||'` &&\
    viol_err_file=$$file_woext.err &&\
    viol_file=$$file_woext.$(RULECHECKER_VIOLATION_EXT) &&\
    echo ">> Patching $$src_file"  &&\
    patch4cms.pl $$patcharg  &&\
    echo "$$line" > config_FILES_TO_ANALYZE  &&\
    rm -f config_RULES_IGNORED  &&\
    if [ -f $$file.RULES_IGNORED ] ; then \
      mv $$file.RULES_IGNORED config_RULES_IGNORED; \
    fi	&&\
    echo ">> Rule checking $$src_file" &&\
    rulechecker_runs_ok="yes"  &&\
    $(JAVA_HOME)/bin/java $$CMS_CODING_RULES > $$viol_err_file 2>&1 || rulechecker_runs_ok="no" &&\
    if [ X$$rulechecker_runs_ok = Xyes ] ; then	rm -f $$viol_err_file; fi &&\
    if [ -f "$$file"i ] ; then rm -f "$$file"i; fi &&\
    if [ -s $$viol_file ] ; then \
      cat $$viol_file; mkdir -p $(LOCALTOP)/doc/RuleCheck/$(3) &&\
      mv $$viol_file $(LOCALTOP)/doc/RuleCheck/$(3) &&\
      echo ">> See rule violations: $(LOCALTOP)/doc/RuleCheck/$(3)/$$viol_file"; \
    else \
      rm -f $$viol_file; echo "   No violation found"; \
    fi &&\
    if [ -s $$viol_err_file ] ; then \
      mkdir -p $(LOCALTOP)/doc/RuleCheck/$(3) &&\
      mv $$viol_err_file $(LOCALTOP)/doc/RuleCheck/$(3); \
    fi ;\
  done &&\
  rm -f config_RULES_IGNORED quickExecution config_FILES_TO_ANALYZE.full config_FILES_TO_ANALYZE &&\
  cd $(LOCALTOP) && touch $@ $(endlog_$(2))
endef
##############################################################################
define bf_update
  @if [ ! -f $@ ] || [ "X$($(1)_BuildFile)" = X ] ; then \
    touch $@;\
  elif [ "X`$(call get_time_stamp,$@)`" != "X`$(call get_time_stamp,$($(1)_BuildFile))`" ] ; then \
      touch $@;\
  fi
endef
define config_update
  @mkdir -p $(@D) ; touch $@ ;\
  if [ "X$($(1)_BuildFile)" != X ] ; then \
    touch -r $($(1)_BuildFile) $(WORKINGDIR)/cache/bf/$(1);\
  fi
endef
define timestamp_cmp
  perl -e "my @s1=stat '$1'; my @s2=stat '$2';"'print $$s1[9]<=>$$s2[9];'
endef
define get_time_stamp
  perl -e 'my @d=stat "$(1)"; print "$$d[9]\n";'
endef
#############################################################################
define SubSystem
.PHONY: $(1) src/$(1) $(2) all_$(2) runtests_$(2)
$(1) src/$(1) $(2) all_$(2): $(subdirs_$(2))
	@echo ">> Subsystem $(1) built"
runtests_$(2): $(addprefix runtests_,$(subdirs_$(2)))
	@:
runpython_$(2): $(addprefix runpython_,$(subdirs_$(2)))
	@:
endef
define EmptyPackage
$(1)_libdeps      := $(prelibdeps) $(addprefix $(WORKINGDIR)/cache/prod/lib,$(sort $($(1)_EX_LIB) $($($u)_EX_UOLIB) $(foreach u,$($(1)_EX_USE),$($u))))
$(1)_CONFIGDEPS := $(CONFIGDEPS) $(sort $(foreach u,$(sort $($(1)_LOC_USE) $($(1)_EX_USE)),$($($(u))_XDEPS) $(if $($($(u))_BuildFile),$($($(u))_BuildFile),$(wildcard .SCRAM/$(SCRAM_ARCH)/timestamps/$(u)))))
ifneq ($$(strip $($(1)_BuildFile)),)
ALL_BUILDFILES += $($(1)_BuildFile)
$($(1)_BuildFile): $$($(1)_CONFIGDEPS)
	@touch $($(1)_BuildFile)
endif
$(WORKINGDIR)/cache/prod/lib$(1): $($(1)_BuildFile) $$($(1)_libdeps)
	@touch $$@
endef
define Package
.PHONY: $(1) src/$(1) $(2) all_$(2) runtests_$(2) msg_$(2)
ifeq ($(strip $(BUILD_LOG)),yes)
logfile_$(2) := $(WORKINGDIR)/cache/log/src/$(1)/build.log
redirectlog_$(2) := >> $(WORKINGDIR)/cache/log/src/$(1)/build.log
else
logfile_$(2) := 
redirectlog_$(2) := 
endif
msg_$(2): $$(logfile_$(2))
	@$(DO_BUILD_LOG) echo ">> Entering Package $(1)" $$(redirectlog_$(2)) &&\
	echo ">> Entering Package $(1)"
$(1) src/$(1) $(2) all_$(2): msg_$(2) $(addprefix all_,$(subdirs_$(2)))
	$$(call outputlog,$(1),$(2))
	@$(DO_BUILD_LOG) echo ">> Leaving Package $(1)"  $$(redirectlog_$(2)) &&\
	$(DO_BUILD_LOG) echo ">> Package $(1) built" $$(redirectlog_$(2)) &&\
	$(DO_BUILD_LOG) cat $(WORKINGDIR)/cache/log/src/$(1)/build.log &&\
	echo ">> Leaving Package $(1)" &&\
	echo ">> Package $(1) built"
ifeq ($$(filter $(2)_test,$(subdirs_$(2))),$(2)_test)
runtests_$(2): $(2) runtests_$(2)_test
	@echo ">> Tests for package $(1) ran."
endif	
ifeq ($$(filter $(2)_python,$(subdirs_$(2))),$(2)_python)
runpython_$(2): runpython_$(2)_python
	@echo ">> Python for package $(1) ran."
endif
endef

define addPlugin
$(2)_pluginname    := $(1)
ALL_$(3)_PLUGINS   += $(1)
$(1)_plugintype    := $(3)
$(1)_no_lib_copy   := $(4)
$(1)_plugindir     := $(5)
$(1)_pluginrefresh := $(6)
$(1)_plugincache   := $(7)
$(1)_pluginprod    := $(5)/$(8)
$(1)_pluginlib     := $($(2)_objdir)/$(MODULE_PREFIX)$(1).$(SHAREDSUFFIX)
all_$(2)           += $(5)/$(8)
$(5)/$(8): $$($(1)_pluginlib) $(WORKINGDIR)/cache/prod/$(6)
	$$(call $(3)_register_plugin,$(1),$(9))
endef
define sealPlugin
$(eval $(call addPlugin,$1,$2,seal,,$3,SealPluginRefresh,.cache,$(1).reg,$1))
endef
define edmPlugin
$(eval $(call addPlugin,$1,$2,edm,yes,$3,EdmPluginRefresh,.edmplugincache,$(1).edmplugin,$1))
endef
define igletPlugin
$(eval $(call addPlugin,$1,$2,iglet,yes,$3,IgPluginRefresh,.iglets,$(2).iglet,$2))
endef

define CXXCompileRule
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.$(2) $($(1)_objdir)/precompile
	$$(call compile_cxx,$(1),$(3))
endef
define CCompileRule
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.$(2) $($(1)_objdir)/precompile
	$$(call compile_c,$(1),$(3))
endef
define F77CompileRule
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.$(2) $$($(1)_objdir)/precompile
	$$(call compile_fortran,$(1),$(3))
endef
define EmptyProduct
.PHONY: $(1) all_$(1) $(2) all_$(2)
$(1) $(2): all_$(1)
	@:
endef

define LogFile
startlog_$(1) = $$(FORCE_BUILD_START)
endlog_$(1)   = $$(FORCE_BUILD_END)
ifeq ($$(strip $$(BUILD_LOG)),yes)
redirectlog_$(1) := >> $(WORKINGDIR)/cache/log/$(2)/$(1)
startlog_$(1) += (
endlog_$(1)   += ) $$(redirectlog_$(1)) 2>&1
logfile_$(1)  := $(WORKINGDIR)/cache/log/$(2)/$(1)
else
logfile_$(1)     := 
redirectlog_$(1) := 
endif
endef

#safename,path,safepath,scriptstore,scripts,binstore
define CommonBinaryHead
$(3)          += all_$(1)
$(eval $(call LogFile,$(1),$(2)))
.PHONY: $(1) all_$(1)
$(1)_objdir := $(WORKINGDIR)/$(2)/$(1)
$(1)_srcdir       := $(LOCALTOP)/$(2)
$(1)_libdeps      := $(prelibdeps) $(addprefix $(WORKINGDIR)/cache/prod/lib,$(sort $($(1)_LOC_LIB) $(foreach u,$($(1)_LOC_USE) $($(1)_EX_USE),$($u) $($($u)_EX_LIB) $($($u)_EX_UOLIB))))
$(1)_files        := $$(filter-out $$($(1)_iglet_file) $($(1)_SKIP_FILES), $$($(1)_files))
$(1)_objs         := $$(addprefix $$($(1)_objdir)/, $$(addsuffix .$(OBJEXT), $$(basename $$($(1)_files))))
ifneq ($(strip $(5)),)
.PHONE: $(1)_install_scripts_rule
$(1)_install_scripts_rule: $(logfile_$(1))
	$$(call copy_src_scripts,$(2),$(1),$(5),$(4))
all_$(1) += $(1)_install_scripts_rule
endif
$(1)_CONFIGDEPS := $(CONFIGDEPS) $(WORKINGDIR)/$(2)/productautocleanup $(sort $(foreach u,$(sort $($(1)_LOC_USE) $($(1)_EX_USE)),$($($(u))_XDEPS) $(if $($($(u))_BuildFile),$($($(u))_BuildFile),$(wildcard .SCRAM/$(SCRAM_ARCH)/timestamps/$(u)))))
ifneq ($$(strip $($(1)_BuildFile)),)
ifeq ($(filter $($(1)_BuildFile),$(ALL_BUILDFILES)),)
ALL_BUILDFILES += $($(1)_BuildFile)
endif
$($(1)_BuildFile):: $$($(1)_CONFIGDEPS)
	@touch $($(1)_BuildFile)
$$($(1)_objdir)/config: $($(1)_BuildFile)
	@$$(call BuildClean,$(2)/$(1),0[0-9],1); mkdir -p $$(@D) ; touch $$@
else
$$($(1)_objdir)/config: $$($(1)_CONFIGDEPS)
	@$$(call BuildClean,$(2)/$(1),0[0-9],1); mkdir -p $$(@D) ; touch $$@
endif
$(1)_config += $$($(1)_objdir)/config
endef

#safename,path,productstore,type,logprodstore,safepath
define CommonBinaryTail
$(eval $($(1)_PRE_INIT_FUNC))
ifneq ($$(strip $($(1)_objs)),)
ALL_$(4)_PRODUCTS += $(1)
$(1):  $($(1)_objdir)/$($(1)_product)
$($(1)_objdir)/$($(1)_product): $($(1)_objdir)/compile $($(1)_libdeps)
ifeq ($(strip $(4)),lib)
	$$(call link_lib,$(1),$(1),$(3),$($(1)_pluginname))
	@$$(startlog_$(1))echo "Leaving library rule at $(patsubst src/%/src,%,$(2))" $(endlog_$(1))
ifeq ($(strip $(BIGLIBS)),yes)
all_$(1) += $($(1)_objdir)/$(1).$(BIGLIB_OBJEXT)
$($(1)_objdir)/$(1).$(BIGLIB_OBJEXT): $($(1)_objdir)/compile
	$$(call big_obj,$(1),$(1),$(patsubst %/lib,%/objs,$(patsubst lib/%,objs/%,$(3))))
endif
endif
ifeq ($(strip $(4)),bin)
	$$(call build_bin,$(1),$(1),$(3))
endif
ifeq ($(strip $(4)),python)
	$$(call link_pylib,$(1),$(1),$(3))
endif
ifeq ($(strip $(4)),test)
	$$(call build_test,$(1),$(1),$(3))
.PHONE: runtests_$(1)
runtests_$(6) += runtests_$(1)
runtests_$(1): all_$(1)
	$$(call run_test,$(1),$(3),$(5))
endif
$(WORKINGDIR)/cache/prod/$(1): $($(1)_objdir)/$($(1)_product)
	@if [ ! -f $$@ ] ; then touch $$@; fi
ifneq ($$(strip $($(1)_product)),)
ifneq ($(wildcard $($(1)_objdir)/$($(1)_product).dep),)
-include $($(1)_objdir)/$($(1)_product).dep
endif
endif
$($(1)_objdir)/precompile: $($(1)_config) $($(1)_precompile) $(logfile_$(1))
	@mkdir -p $$(@D) ; touch $$@
ifeq ($$(strip $(4)),lib)
	@$(startlog_$(1))echo "Entering library rule at $(patsubst src/%/src,%,$(2))" $(endlog_$(1))
endif
$($(1)_objdir)/compile: $($(1)_objdir)/precompile $($(1)_objs) $($(1)_compile)
	@touch $$@
$($(1)_objdir)/link: $($(1)_objdir)/compile $($(1)_objdir)/$($(1)_product) $($(1)_link)
	@touch $$@
all_$(1): $($(1)_objdir)/link $$(all_$(1))
	@:
endif
endef

define FindBuildFile
$(if $(wildcard $(1).xml),$(1).xml,$(1))
endef

define MultipleWarningMsg
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(call $$(multipletools),****WARNING: Multiple products with same name $(1))
$$(call $$(multipletools),             Previous defination: $($(1)))
$$(call $$(multipletools),             Current  defination: $(2))
endif
endef

define ProductWithNoFiles
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(info ****WARNING: Skipped building of $(1) from $$(call FindBuildFile,$(2)/$(SCRAM_BUILDFILE)) because)
ifeq ($(strip $(3)),)
$$(info $$(space)             there are no files mentioned in the this Buildfile)
else
$$(info $$(space)             \"$(3)\" does not match any file under $(2) directory)
endif
endif
endef

define UseError
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(call $$(wrongtool),****WARNING: Invalid tool $(1). Please fix $$(call FindBuildFile,$$(subst tmp/slc4_ia32_gcc345/cache/bf/,,$2)) file.)
endif
endef

#safename,path,safepath,scriptstore,scripts,productstore,fileext,type,logprodstore
define Binary
$(eval $(call CommonBinaryHead,$(1),$(2),$(3),$(4),$(5)))
ALL_BINARIES += $(1)
$(1)_product := $(1)
$$(eval $$(call CommonBinaryTail,$(1),$(2),$(6),$(8),$(9),$(3)))
$(foreach ext,$(filter $(CXXSRC_FILES_SUFFIXES),$(7)),$(eval $(call CXXCompileRule,$(1),$(ext),$(1))))
$(foreach ext,$(filter $(CSRC_FILES_SUFFIXES),$(7)),$(eval $(call CCompileRule,$(1),$(ext),$(1))))
endef

#safename,path,safepath,scriptstore,scripts,libstore,fileext,logprodstore
define Library
$(eval $(call LibraryHead,$(1),$(2),$(3),$(4),$(5)))
$(eval $(call LibraryTail,$(1),$(2),$(6),$(7),$(8)))
endef

#safename,path,safepath,scriptstore,scripts
define LibraryHead
$(eval $(call CommonBinaryHead,$(1),$(2),$(3),$(4),$(5)))
$(1)_product      := $(MODULE_PREFIX)$(1).$(SHAREDSUFFIX)
endef

#safename,path,libstore,fileext,logprodstore
define LibraryTail
$(eval $(call CommonBinaryTail,$(1),$(2),$(3),lib,$(5)))
ifneq ($$(strip $$($(1)_objs)),)
ALL_LIBRARIES += $(1)
$(WORKINGDIR)/cache/prod/lib$(1): $($(1)_objdir)/$($(1)_product)
	@:
$(foreach ext,$(filter $(CXXSRC_FILES_SUFFIXES),$(4)),    $(eval $(call CXXCompileRule,$(1),$(ext),$(1))))
$(foreach ext,$(filter $(CSRC_FILES_SUFFIXES),$(4)),      $(eval $(call CCompileRule,$(1),$(ext),$(1))))
$(foreach ext,$(filter $(FORTRANSRC_FILES_SUFFIXES),$(4)),$(eval $(call F77CompileRule,$(1),$(ext),$(1))))
else
$(1) all_$(1): $$(all_$(1))
	@:
endif
endef

define AddExtraPythonProdRule
$(if $(2),$(eval $(call ExtraPythonProd,$(1),$(firstword $(2)),$(firstword $(3))))$(eval $(call AddExtraPythonProdRule,$(1),$(wordlist 2,100,$(2)),$(wordlist 2,100,$(3)))),)
endef

define ExtraPythonProd
all_$(1)_extra_python_prod += $(3)/$(2)
$(3)/$(2): $(2) $(1)_copy_python_scripts $($(1)_CONFIGDEPS)
	@echo ">> Copying python products \"$(2)\" => $(3)"
	$$(call copy_python_products,$(1),$(logfile_$(1)),$(2),$(3))
endef

#safename,path,safepath,hasscripts,symlinkpython,pythonstore,xprodfiles,xproddirs
define PythonProductHead
$(3)          += all_$(1)
.PHONY: $(1) all_$(1) $(1)_copy_python_scripts
$(eval $(call LogFile,$(1),$(2)))
$(1)_objdir       := $(WORKINGDIR)/$(2)/$(1)
$(1)_python_dir := $(addprefix $(6)/,$(patsubst $(SCRAM_SOURCEDIR)/%/python,%,$(2)))
$(1)_CONFIGDEPS := $(CONFIGDEPS) $(sort $(foreach u,$(sort $($(1)_LOC_USE) $($(1)_EX_USE)),$($($(u))_XDEPS) $(if $($($(u))_BuildFile),$($($(u))_BuildFile),$(wildcard .SCRAM/$(SCRAM_ARCH)/timestamps/$(u)))))
ifneq ($$(strip $($(1)_BuildFile)),)
ALL_BUILDFILES += $($(1)_BuildFile)
$($(1)_BuildFile): $$($(1)_CONFIGDEPS)
	@touch $($(1)_BuildFile)
$$($(1)_objdir)/config: $($(1)_BuildFile)
	@$$(call BuildClean,$(2)/$(1),0[0-9],1); mkdir -p $$(@D) ; touch $$@
else
$$($(1)_objdir)/config: $$($(1)_CONFIGDEPS)
	@$$(call BuildClean,$(2)/$(1),0[0-9],1); mkdir -p $$(@D) ; touch $$@
endif
$(1)_config += $$($(1)_objdir)/config
all_$(1) += $(1)_copy_python_scripts
ifeq ($(strip $(4)),1)
ifeq ($$(strip $(5)),1)
ifeq ($$(strip $(COMPILE_PYTHON_SCRIPTS)),yes)
$$($(1)_objdir)/cmssw_python_modules: FORCE_TARGET $(logfile_$(1)) $(COMMON_WORKINGDIR)/python_symlinks
	$$(call compile_python,$1,$1,$(subst /,.,$(patsubst $(SCRAM_SOURCEDIR)/%/python,%,$(2))),$(2))
$(1)_copy_python_scripts: $$($(1)_objdir)/cmssw_python_modules
else
$(1)_copy_python_scripts: $(logfile_$(1)) $(COMMON_WORKINGDIR)/python_symlinks
endif
	@:
else
$(1)_copy_python_scripts: $(logfile_$(1))
	$$(call python_script_copy,$(1),$(logfile_$(1)),$(6))
endif
else
$(1)_copy_python_scripts: $(logfile_$(1))
	@echo "No source files to compile. Nothing to be done for Python modules at $(2)."
endif
runpython_$(3): $(1)_copy_python_scripts
	@:
ifneq ($(strip $(7)),)
.PHONY: $(1)_extra_python_prod
all_$(1) += $(all_$(1)_extra_python_prod)
$(eval $(call AddExtraPythonProdRule,$(1),$(7),$(8)))
all_$(1) += $(all_$(1)_extra_python_prod)
endif
$(1)_srcdir       := $(LOCALTOP)/$(2)
$(1)_files        := $$(notdir $$(wildcard $$(foreach dir,$$($(1)_srcdir),$$(foreach ext,$(CXXSRC_FILES_SUFFIXES),$$(dir)/*.$$(ext)))))
$(1)_files        += $$(patsubst %.pyste,%_boost.cc,$$(notdir $$(wildcard $$($(1)_srcdir)/*.pyste)))
$(1)_files        := $$(filter-out $($(1)_SKIP_FILES),$$($(1)_files))
endef

define PythonProductFlags
$(1)_files        += $($(1)_objdir)/$(1)_PyWrapper.cc
$(1)_objs         := $$(addprefix $($(1)_objdir)/, $$(addsuffix .$(OBJEXT), $$(basename $$(notdir $$($(1)_files)))))
$(1)_PY_CXXFLAGS   = $$(filter-out -pedantic-errors -ansi, $$($(1)_CXXFLAGS))
$(1)_libdeps      := $(prelibdeps) $(addprefix $(WORKINGDIR)/cache/prod/lib,$(sort $($(1)_LOC_LIB) $(foreach u,$($(1)_LOC_USE),$($u) $($($u)_EX_LIB) $($($u)_EX_UOLIB))))
$(1)_objs         := $$(addprefix $($(1)_objdir)/, $$(addsuffix .$(OBJEXT), $$(basename $$(notdir $$($(1)_files)))))
$(1)_classnames   := $$(patsubst %_boost,%,$$(filter %_boost,$$(basename $$(notdir $$($(1)_files)))))
$(1)_CXXSharedLink = -rdynamic $$($(1)_LDFLAGS)
endef

#safename,path,productstore,logprodstore
define PythonProductTail
$(1)_product := $(1).$(SHAREDSUFFIX)
$$(eval $$(call CommonBinaryTail,$(1),$(2),$(3),python,$(4)))
$(foreach ext,$(CXXSRC_FILES_SUFFIXES),$(eval $(call CXXCompileRule,$(1),$(ext),$(1))))
.PRECIOUS: $($(1)_objdir)/%_boost.cc
$($(1)_objdir)/%_boost.cc: $($(1)_srcdir)/%.pyste $($(1)_config)
	$$(call pyste2boost,$(1),$(1))
$($(1)_objdir)/%_boost.o: $($(1)_srcdir)/%_boost.cc $($(1)_config)
	$$(call compile_boost,$(1),$(1))
$($(1)_objdir)/%_boost.o: $($(1)_objdir)/%_boost.cc
	$$(call compile_boost,$(1),$(1))
$($(1)_objdir)/$(1)_PyWrapper.o: $($(1)_objdir)/$(1)_PyWrapper.cc
	$$(call compile_pywrapper,$(1),$(1))
$($(1)_objdir)/$(1)_PyWrapper.cc: $($(1)_config)
	$$(call generate_pywrapper,$(1),$(1))
endef

#safename,path,safepath,hasscripts,symlinkpython,pythonstore,libstore,xprodfiles,xproddirs,logprodstore
define PythonProduct
$(eval $(call PythonProductHead,$(1),$(2),$(3),$(4),$(5),$(6),$(8),$(9)))
ifneq ($$(strip $$($(1)_files)),)
ifneq ($$(strip $$($(1)_BuildFile)),)
ifneq ($$(strip $$(filter boost_python,$($(1)_LOC_USE))),)
$$(eval $$(call PythonProductFlags,$(1)))
$$(eval $$(call PythonProductTail,$(1),$(2),$(7),$(10)))
else
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(info ****WARNING: Skipped building product $(1).$(SHAREDSUFFIX) due to missing boost_python tool selecting in $(2)/$(SCRAM_BUILDFILE))
endif
endif
else
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(info ****WARNING: Skipped building product $(1).$(SHAREDSUFFIX) due to missing $(2)/$(SCRAM_BUILDFILE))
endif
endif
endif
ifeq ($$(strip $$($(1)_product)),)
$(1) all_$(1): $(all_$(1))
	@:
endif
endef

#safepath,datapath,datacopy,urldownload,downloadurls
define DataInstall
ifneq ($(strip $(3)$(4)),00)
$(eval $(call LogFile,$(1),$(2)))
$(1)_install_path   := $(addprefix share/,$(patsubst src/%,%,$(2)))
$(1)_data_copy_rule := $$($(1)_install_path)
ifeq ($(strip $(3)),1)
$$($(1)_install_path): $(2) $(logfile_$(1))
	$$(call copy_datadir,$(1),$(1))
else
$$($(1)_install_path):
	@mkdir -p $$@
endif
ifeq ($(strip $(4)),1)
$$(eval $$(call AddDownloadUrl,$(1),$(5)))
endif
endif
endef

define AddDownloadUrl
$(if $(2),$(eval $(call DownloadUrlRule,$(1),$(firstword $(2))))$(eval $(call AddDownloadUrl,$(1),$(wordlist 2,100,$(2)))),)
endef

define DownloadUrlRule
$(1)_data_copy_rule += $(COMMON_WORKINGDIR)/$(2)
$(COMMON_WORKINGDIR)/$(2): $(2) $($(1)_install_path) $(logfile_$(1))
	$$(call download_urls,$(1),$(1),$(SCRAMSTORENAME_LOGS))
endef

define Src2StoreCopy
.PHONY: $(1) all_$(1)
$(1)_files := $(filter-out CVS $(SCRAM_BUILDFILE) $(SCRAM_BUILDFILE).xml $($(1)_SKIP_FILES), $($(1)_files))
$(1): all_$(1)
	@:
ifneq ($$(strip $$($(1)_files)),)
$(eval $(call LogFile,$(1),$(2)))
$(1)_installdir := $(3)
all_$(1): $(logfile_$(1))
	@$$(call clean_files,$($(1)_SKIP_FILES),$$($(1)_installdir))
	$$(call src2store_copy,$(2),$(1),$$($(1)_files),$$($(1)_installdir))
endif
endef

#safename,path,javastore,xprodfiles,xproddirs
define JavaProductHead
.PHONY: $(1) all_$(1)
$(eval $(call LogFile,$(1),$(2)))
$(1)_objdir := $(WORKINGDIR)/$(2)
$(1)_javadir := $(LOCALTOP)/$(2)
$(1)_files1 := $(filter-out $($(1)_SKIP_FILES), $($(1)_FILE_COMPILATION_ORDER))
$(1)_files2 := $$(filter-out $($(1)_SKIP_FILES),$$(notdir $$(wildcard $$(foreach dir,$$($(1)_javadir),$$(dir)/*.java))))
$(1)_files  := $$($(1)_files1) $$($(1)_files2)
ifneq ($$(strip $$($(1)_files)),)
$(1)_workdir    := $$($(1)_objdir)/$(1)
$(1)_workfiles1 := $$(addprefix $$($(1)_workdir)/, $$(addsuffix .done, $$(basename $$(notdir $$($(1)_files1)))))
$(1)_workfiles2 := $$(addprefix $$($(1)_workdir)/, $$(addsuffix .done, $$(basename $$(notdir $$($(1)_files2)))))
.NOTPARALLEL: $$($(1)_workfiles1)
$(1)_precompile += $$($(1)_workfiles1)
$(1)_compile    += $$($(1)_workfiles2)
$(1)_CONFIGDEPS := $(CONFIGDEPS)
ifneq ($$(strip $($(1)_BuildFile)),)
ALL_BUILDFILES += $($(1)_BuildFile)
$($(1)_BuildFile): $$($(1)_CONFIGDEPS)
	@touch $($(1)_BuildFile)
$$($(1)_objdir)/config: $($(1)_BuildFile)
	@$$(call BuildClean,$(2),0[0-9],1); mkdir -p $$(@D) ; touch $$@
else
$$($(1)_objdir)/config: $$($(1)_CONFIGDEPS)
	@$$(call BuildClean,$(2),0[0-9],1); mkdir -p $$(@D) ; touch $$@
endif
$(1)_config += $$($(1)_objdir)/config
else
all_$(1) $(1):
	@:
endif
endef

define JavaProductTail
ifneq ($$(strip $($(1)_workdir)),)
$($(1)_objdir)/precompile: $($(1)_config) $($(1)_precompile) $(logfile_$(1))
	@mkdir -p $$(@D) ; touch $$@
$($(1)_objdir)/compile: $($(1)_objdir)/precompile $($(1)_objs) $($(1)_compile)
	@touch $$@
$($(1)_objdir)/link: $($(1)_objdir)/compile $($(1)_link)
	@$$(call copy_java_to_java_productstore,$(1),$(1),$(3))
	@touch $$@
all_$(1) $(1): $($(1)_objdir)/link $(all_$(1))
	@:
$($(1)_workdir)/%.done: $($(1)_javadir)/%.java $($(1)_config) $(logfile_$(1))
	$$(call compile_java,$(1),$(1))
endif
endef

define JavaProduct
$(eval $(call JavaProductHead,$(1),$(2),$(3)))
$(eval $(call JavaProductTail,$(1),$(2),$(3)))
endef

define CommonDataRules
.PHONY: $(1) all_$(1)
$(1) all_$(1): $($(1)_data_copy_rule)
endef

define CommonProductRules
.PHONY: $(1) all_$(1)
ifeq ($(strip $(3)),TEST)
.PHONY: runtests_$(1)
$(1) += $($(1)_data_copy_rule)
runtests_$(1): $(1) $(runtests_$(1))
	@:
endif
$(1) all_$(1): $($(1))
	@:
endef

define AddMOC
$(1)_LOC_FLAGS_CPPFLAGS     += -I$($(1)_objdir)/moc
$(1)_FILE_MOC	  := $(foreach suffix,h cc cpp cxx,$(patsubst %.$(suffix),%_$(suffix)_moc.cc,$(filter %.$(suffix),$(2))))
$(1)_FILE_MOC_SRC := $$(filter %_cc_moc.cc %_cpp_moc.cc %_cxx_moc.cc, $$($(1)_FILE_MOC))
$(1)_FILE_MOC_INC := $(filter-out $$($(1)_FILE_MOC_SRC),$$($(1)_FILE_MOC))
$(1)_files        += $$($(1)_FILE_MOC_INC)
$(1)_objs         += $$(addprefix $($(1)_objdir)/moc/, $$(addsuffix .$(OBJEXT), $$(basename $$(notdir $$($(1)_FILE_MOC_INC)))))
$(1)_precompile   += $($(1)_objdir)/moc/run_moc
$($(1)_objdir)/moc/run_moc: $$(addprefix $($(1)_objdir)/moc/, $$($(1)_FILE_MOC))
	@[ -f $$@ ] || touch $$@
$($(1)_objdir)/moc/%.$(OBJEXT):  $($(1)_objdir)/moc/%.cc
	$$(call compile_cxx,$(1),$(1))
$($(1)_objdir)/moc/%_h_moc.cc:   $(3)/%.h   $($(1)_config)
	$$(call generate_moc,$(1),$(1))
$($(1)_objdir)/moc/%_h_moc.cc:   $(4)/%.h   $($(1)_config)
	$$(call generate_moc,$(1),$(1))
$($(1)_objdir)/moc/%_cc_moc.cc:  $(4)/%.cc  $($(1)_config)
	$$(call generate_moc,$(1),$(1))
$($(1)_objdir)/moc/%_cpp_moc.cc: $(4)/%.cpp $($(1)_config)
	$$(call generate_moc,$(1),$(1))
$($(1)_objdir)/moc/%_cxx_moc.cc: $(4)/%.cxx $($(1)_config)
	$$(call generate_moc,$(1),$(1))
endef

#safename,igletfile,prodstore
define Iglet
$(1)_ExtraIglet_objs        := $(addprefix $($(1)_objdir)/, $(addsuffix .$(OBJEXT), $(basename $(2))))
$(1)_ExtraIglet_libcheck    := $($(1)_libcheck)
$(1)_ExtraIglet_CXXFLAGS     = $$($(1)_CXXFLAGS)
$(1)_ExtraIglet_LDFLAGS      = $$($(1)_LDFLAGS)
$(1)_ExtraIglet_libdeps     := $($(1)_libdeps)
ifeq ($(strip $($(1)_objs)),)
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.cc $($(1)_config) $(logfile_$(1))
	$$(call compile_cxx,$(1),$(1))
else
$(1)_ExtraIglet_LDFLAGS      = $$($(1)_LDFLAGS) -l$(1)
$(1)_ExtraIglet_libdeps     += $(WORKINGDIR)/cache/prod/lib$(1)
endif
$($(1)_ExtraIglet_pluginlib): $$($(1)_ExtraIglet_objs) $$($(1)_ExtraIglet_libdeps)
	$$(call link_lib,$(1)_ExtraIglet,$(1),$(3),$(1)_ExtraIglet)
ifneq ($(wildcard $($(1)_ExtraIglet_pluginlib).dep),)
-include $($(1)_ExtraIglet_pluginlib).dep
endif
endef

#safename,path,*LinkDef.h files
define RootDict
$(1)_LinkDef_files          := $(addprefix $($(1)_objdir)/,$(patsubst %.h,%.cc,$(3)))
$(1)_LOC_FLAGS_CPPFLAGS     += -I$(LOCALTOP)/$(2)
$(1)_files                  += $$($(1)_LinkDef_files)
$(1)_objs                   += $(addprefix $($(1)_objdir)/,$(patsubst %.h,%.$(OBJEXT),$(3)))
.PRECIOUS: $$($(1)_LinkDef_files)
$($(1)_objdir)/%.cc: $($(1)_srcdir)/%.h $($(1)_config)
	$$(call generate_rootdict,$(1),$(1))
$($(1)_objdir)/%.$(OBJEXT): $($(1)_objdir)/%.cc
	$$(call compile_rootdict,$(1),$(1))
ifneq ($$(wildcard $($(1)_objdir)/*LinkDef.cc.d),)
-include $$(wildcard $($(1)_objdir)/*LinkDef.cc.d)
endif
endef


#safename,prodpath
define RootMap
$($(1)_objdir)/$(1).rootmap: $($(1)_objdir)/$(MODULE_PREFIX)$(1).$(SHAREDSUFFIX)
	@$(startlog_$(1))echo ">> Generating RootMap file: $$(@F)" &&\
	cd $$(<D); genmap -i $$(<F) -o $$(@F) $(endlog_$(1))
$(2)/$(1).rootmap: $($(1)_objdir)/$(1).rootmap
	@echo "01:rm -f $$@" > $$(call AutoCleanFile,$$<,prod)
	@mkdir -p $$(@D); cp $$< $$@
all_$(1) += $(2)/$(1).rootmap
endef

#safename,libname,prodpath
define LcgDictRootMap
$(2)_GENREFLEX_ARGS += --rootmap=$(2).rootmap --rootmap-lib=$(MODULE_PREFIX)$(2).$(SHAREDSUFFIX)
$($(1)_objdir)/$(2).rootmap: $($(1)_objdir)/$(MODULE_PREFIX)$(2).$(SHAREDSUFFIX)
	@touch $$@
$(3)/$(2).rootmap: $($(1)_objdir)/$(2).rootmap
	@echo "01:rm -f $$@" > $$(call AutoCleanFile,$$<,prod)
	@mkdir -p $$(@D); cp $$< $$@
all_$(1) += $(3)/$(2).rootmap
endef

#safename,rootmap,headers,hfiles,defxmlfiles,prodstore,genreflexargs
define LCGDict
$(1)Capabilities_CDICT_LDFLAGS   = $$($(1)_LDFLAGS) -l$(1)
$(1)Capabilities_GENREFLEX_ARGS := $(7)
$(eval $(call AddLCGDictRule,$(1),$(4),$(5),$(1)Capabilities,a/))
ifeq ($(strip $(2)),1)
$$(eval $$(call LcgDictRootMap,$1,$(1)Capabilities,$6))
endif
all_$(1)       += $($(1)_objdir)/$(MODULE_PREFIX)$(1)Capabilities.$(SHAREDSUFFIX)
$($(1)_objdir)/$(MODULE_PREFIX)$(1)Capabilities.$(SHAREDSUFFIX): $$($(1)Capabilities_ids) $(WORKINGDIR)/cache/prod/lib$(1)
	$$(call link_capabilities,$(1),$(1),$(6),$(1)Capabilities)
endef

define AddLCGDictRule
$(if $(2),$(eval rflx_name:=$(rflx_name)x)$(eval $(call LCGDictRule,$(1),$(5)$(rflx_name),$(firstword $(2)),$(firstword $(3)),$(4)))$(eval $$(call AddLCGDictRule,$(1),$(wordlist 2,100,$(2)),$(wordlist 2,100,$(3)),$(4),$(5)))$(eval rflx_name:=),)
endef

define LCGDictRule
$(1)_files  += $($(1)_objdir)/$(2)r.cc
$(1)_objs   += $($(1)_objdir)/$(2)r.$(OBJEXT)
$(5)_ids    += $($(1)_objdir)/$(2)i.$(OBJEXT)
$($(1)_objdir)/$(2).h: $(3) $($(1)_config)
	@mkdir -p $$(@D); grep '^ *# *include' $(3) > $$@ || touch $$@
$($(1)_objdir)/$(2)r.cc: $(4) $($(1)_objdir)/$(2).h
	$$(call generate_lcgdict,$(1),$(1),$(4),$(3),$(2)i.cc,$(5))
	@sed -i -e "s|$(3)|$(LOCALTOP)/$($(1)_objdir)/$(2).h|;s|operator_|op_|g;s|method_|me_|g;s|constructor_|ct_|g;s|destructor_|de_|g" $$@
$($(1)_objdir)/$(2)r.$(OBJEXT): $($(1)_objdir)/$(2)r.cc
	$$(call compile_lcgdict,$(1),$(1),$(2)r)
$($(1)_objdir)/$(2)i.cc: $($(1)_objdir)/$(2)r.$(OBJEXT)
	@[ -f $$< ] || rm -f $$@
$($(1)_objdir)/$(2)i.$(OBJEXT): $($(1)_objdir)/$(2)i.cc
	$$(call compile_cxx,$(1),$(1))
ifneq ($$(wildcard $($(1)_objdir)/$(2)r.cc.d),)
-include $($(1)_objdir)/$(2)r.cc.d
endif
endef

#safename,path,lexyacc,parseyacc,
define LexYACC
$(1)_lex_files     :=  $(3)
$(1)_yacc_files    :=  $(4)
$(1)_generated_hdr := $$(addprefix $($(1)_objdir)/, $$(addsuffix .h,  $$(basename $$(notdir $$($(1)_yacc_files)))))
$(1)_generated_src := $$(addprefix $($(1)_objdir)/, $$(addsuffix .cc, $$(basename $$(notdir $$($(1)_lex_files)))))
$(1)_generated_src += $$(addprefix $($(1)_objdir)/, $$(addsuffix .cc, $$(basename $$(notdir $$($(1)_yacc_files)))))
ifneq ($$(strip $$($(1)_generated_src)),)
$(1)_LOC_FLAGS_CPPFLAGS  += -I$(LOCALTOP)/$(WORKINGDIR)/src
endif
$(1)_objs          += $$(patsubst %.cc,%.$(OBJEXT),$$($(1)_generated_src))
$(1)_precompile    += $$($(1)_generated_src) $$($(1)_generated_hdr)
.PRECIOUS: $$($(1)_generated_src) $$($(1)_generated_hdr)
$($(1)_objdir)/%lex.cc: $($(1)_srcdir)/%lex.l $($(1)_config)
	$$(call generate_lex,$(1),$(1))
$($(1)_objdir)/%parse.cc $($(1)_objdir)/%parse.h: $($(1)_srcdir)/%parse.y $($(1)_config)
	$$(call generate_parse,$(1),$(1),$(2))
$($(1)_objdir)/%.$(OBJEXT): $($(1)_objdir)/%.cc $($(1)_objdir)/precompile
	$$(call compile_cxx,$(1),$(1))
endef

#safename,path,CODEGENPATH
define CodeGen
$(1)_CODEGENPY            := python $(3)/bin/codegen.py
$(1)_CODEGENTEMPLATES     := $(3)/templates
$(1)_codegen_object_names := $(foreach file,$(wildcard $(foreach dir,$($(1)_srcdir),$(dir)/*.desc.xml)),$(notdir $(patsubst %.desc.xml,%,$(file))))
$(1)_codegen_src := $$(addprefix $($(1)_objdir)/,$(foreach objname,$$($(1)_codegen_object_names), \
			$$(foreach suffix,.cpp .reg.cpp _T_Context.cpp,$$(objname)$$(suffix))))
$(1)_codegen_hdr := $$(addprefix $($(1)_objdir)/, $$(foreach objname,$$($(1)_codegen_object_names), \
			$$(foreach suffix,.h Record.h,$$(objname)$$(suffix))))
$(1)_codegen_rtvr_src :=$(addprefix $($(1)_objdir)/,$(1)Retriever.cpp)
$(1)_codegen_rtvr_hdr :=$(addprefix $($(1)_objdir)/,$(1)Retriever.h)
ifneq ($$(strip $$($(1)_codegen_src)),)
$(1)_LOC_FLAGS_CPPFLAGS  += -I$(LOCALTOP)/$(WORKINGDIR)/src
endif
ifneq ($$(strip $$($(1)_codegen_rtvr_src)),)
$(1)_LOC_FLAGS_CPPFLAGS  += -I$(LOCALTOP)/$(WORKINGDIR)/src
endif
$(1)_objs       += $$(patsubst %.cpp, %.$(OBJEXT), $$($(1)_codegen_src))
$(1)_objs       += $$(patsubst %.cpp, %.$(OBJEXT), $$($(1)_codegen_rtvr_src))
$(1)_precompile += $$($(1)_codegen_src) $$($(1)_codegen_hdr)
$(1)_precompile += $$($(1)_codegen_rtvr_src) $$($(1)_codegen_rtvr_hdr)
.PRECIOUS: $$($(1)_codegen_src) $$($(1)_codegen_hdr)
$($(1)_objdir)/%.h $($(1)_objdir)/%Record.h $($(1)_objdir)/%.cpp $($(1)_objdir)/%.reg.cpp $($(1)_objdir)/%_T_Context.cpp: $($(1)_srcdir)/%.desc.xml $($(1)_config)
	$$(call generate_codegen_record,$(1),$(1))
$($(1)_objdir)/$(1)Retriever.$(OBJEXT): $($(1)_objdir)/$(1)Retriever.cpp
	$$(call compile_cxx,$(1),$(1))
$($(1)_objdir)/$(1)Retriever.cpp $($(1)_objdir)/$(1)Retriever.h: $$($(1)_codegen_hdr)
	@:
$($(1)_objdir)/%.reg.$(OBJEXT): $($(1)_objdir)/%.reg.cpp $($(1)_objdir)/precompile
	$$(call compile_cxx,$(1),$(1))
$($(1)_objdir)/%_T_Context.$(OBJEXT): $($(1)_objdir)/%_T_Context.cpp $($(1)_objdir)/precompile
	$$(call compile_cxx,$(1),$(1))
$($(1)_objdir)/%.$(OBJEXT): $($(1)_objdir)/%.cpp $($(1)_objdir)/precompile
	$$(call compile_cxx,$(1),$(1))
endef
##############################################################################
define SetTargetType
ifneq ($(strip $(filter biglib,$(MAKECMDGOALS))),)
  BIGLIBS:=yes
endif
ifeq ($(strip $(MAKECMDGOALS)),outputlog)
  FAST :=yes
  XFAST:=yes
  UFAST:=yes
endif
ifeq ($(strip $(MAKECMDGOALS)),clean)
  ONLYECHOTARGETS:=yes
  FAST :=yes
  XFAST:=yes
  UFAST:=yes
else
ifeq ($(strip $(filter-out echo_% clean_% fast xfast ufast biglib outputlog,$(MAKECMDGOALS))),)
  ONLYECHOTARGETS:=yes
  ifneq ($(strip $(filter ufast,$(MAKECMDGOALS))),)
    FAST :=yes
    XFAST:=yes
    UFAST:=yes
  else
    ifneq ($(strip $(filter xfast,$(MAKECMDGOALS))),)
      FAST :=yes
      XFAST:=yes
    else
      ifneq ($(strip $(filter fast,$(MAKECMDGOALS))),)
        FAST :=yes
      endif
    endif
  endif
endif
endif
endef
define UpdateMakeGoalTypes
$(if $(strip $(MAKECMDGOALS)),$(eval $(call SetTargetType)),)
endef
define GetEchoVariable
$(if $(strip $(filter echo_%,$(1))),$(patsubst echo_%,%,$(1)),)
endef
$(eval $(call UpdateMakeGoalTypes))
##############################################################################
.PHONY: FORCE_TARGET ToolUpdated_% ToolUpdated ExternalLinks
FORCE_TARGET:
	@:
$(WORKINGDIR)/cache/prod/%:
	@touch $@
$(WORKINGDIR)/cache/log/%: FORCE_TARGET
	@if [ -f $@ ] ; then  \
	  rm -f $@ ;\
	else \
	  [ -d $(@D) ] || mkdir -p $(@D) ;\
	fi
	@touch -t $(OLD_TIMESTAMP) $@
ToolUpdated_%: ToolUpdated
ExternalLinks ToolUpdated:
	@$(LOCALTOP)/$(SCRAM_CONFIGDIR)/SCRAM/linkexternal.pl --arch $(SCRAM_ARCH)
$(WORKINGDIR)/cache/xlibs: $(WORKINGDIR)/cache/xlibs.backup
	@touch -t $(OLD_TIMESTAMP) $@
$(WORKINGDIR)/cache/xlibs.backup: $(ToolTimeStamps)
	@$(LOCALTOP)/$(SCRAM_CONFIGDIR)/SCRAM/linkexternal.pl --arch $(SCRAM_ARCH);\
	touch $@
######################################################################
$(eval curtop:=$(shell echo $$LOCALTOP))
ifneq ($(curtop),$(SCRAM_INIT_LOCALTOP))
  PROJECT_RENAME_TARGET:=
  ifeq ($(strip $(MAKECMDGOALS)),ProjectRename)
    PROJECT_RENAME_TARGET:=yes
  else
    ifeq ($(strip $(MAKECMDGOALS)),projectrename)
      PROJECT_RENAME_TARGET:=yes
    else
      ifeq ($(strip $(MAKECMDGOALS)),PROJECTRENAME)
        PROJECT_RENAME_TARGET:=yes
      endif
    endif
  endif
  ifneq ($(PROJECT_RENAME_TARGET),yes)
    $(eval dummyfile:=localtopchecking.file.$(shell date +%s.%N 2>/dev/null))
    $(eval xxtmp:=$(shell touch $(SCRAM_INIT_LOCALTOP)/$(dummyfile) 2> /dev/null))
    ifeq ($(strip $(wildcard $(curtop)/$(dummyfile))),)
      $(eval xxtmp:=$(shell rm -f $(SCRAM_INIT_LOCALTOP)/$(dummyfile)))
      $(info **** ERROR: You have moved/renamed this project area "$(curtop)" from "$(SCRAM_INIT_LOCALTOP)")
      $(error Please first run \"scramv1 b ProjectRename\")
    endif
    $(eval xxtmp:=$(shell rm -f $(SCRAM_INIT_LOCALTOP)/$(dummyfile)))
  endif
endif

.PHONY: projectrename ProjectRename PROJECTRENAME
ProjectRename projectrename PROJECTRENAME:
	@if [ -f ./$(SCRAM_CONFIGDIR)/SCRAM/projectAreaRename.pl ] ; then \
	  ./$(SCRAM_CONFIGDIR)/SCRAM/projectAreaRename.pl $(SCRAM_INIT_LOCALTOP) $(curtop) $(SCRAM_ARCH); \
	  echo "Done: $@"; \
	fi
######################################################################
#Common Rules
.PHONY: all project project_all all_$(SCRAM_SOURCEDIR)
all: all_$(TARGETDIR) ProjectPluginRefresh
	@:
project project_all all_$(SCRAM_SOURCEDIR): $(SCRAM_SOURCEDIR) ProjectPluginRefresh
	@:

.PHONY: python help runtests clean distclean cache_clean project_clean clean_$(SCRAM_SOURCEDIR) project_help help_$(SCRAM_SOURCEDIR)
help: help_$(TARGETDIR)
clean: clean_$(TARGETDIR)
runtests: runtests_$(TARGETDIR)
python: runpython_$(TARGETDIR)

project_clean clean_$(SCRAM_SOURCEDIR) vclean cache_clean distclean:
	@echo "Cleaning ProductStore directories:"
	/bin/rm -rf $(ALL_PRODUCT_STORES)
	@echo "Resetting project cache:"; mkdir -p .SCRAM/$(SCRAM_ARCH)
	@touch .SCRAM/$(SCRAM_ARCH)/ProjectCache.db.gz
	/bin/rm -f .SCRAM/$(SCRAM_ARCH)/ProjectCache.db*
	@touch .SCRAM/$(SCRAM_ARCH)/DirCache.db.gz
	/bin/rm -f .SCRAM/$(SCRAM_ARCH)/DirCache.db*
	@touch .SCRAM/$(SCRAM_ARCH)/RuntimeCache.db.gz
	/bin/rm -f .SCRAM/$(SCRAM_ARCH)/RuntimeCache.db*
	/bin/rm -rf .SCRAM/$(SCRAM_ARCH)/MakeData
	@if [ "X$(COMPILE_PYTHON_SCRIPTS)" = "Xyes" ] && [ "X$(ALL_PYTHON_DIRS)" != "X" ] ; then \
	  echo "Cleaning up the compiled .pyc files in the $(SCRAM_SOURCEDIR) directory.";\
	  for d in $(ALL_PYTHON_DIRS) ; do \
	    $(call BuildClean,$(SCRAM_SOURCEDIR)/$$d,,no);\
	  done;\
	fi
	/bin/rm -rf $(SCRAM_INTwork)

project_help help_$(SCRAM_SOURCEDIR):
	@echo "------------ Help for Project-level Builds ------------"
	@echo ""
	@echo "clean:"
	@echo "     Clean the local working directory only."
	@echo ""
	@echo "python:"
	@echo "     To just build python i.e. creating sym-links and compiling python modules."
	@echo ""
	@echo "prebuild:"
	@echo "     Execute pre-build target for the project."
	@echo ""
	@echo "postbuild:"
	@echo "     Execute the post-build target for the project."
	@echo ""
	@echo "rulechecker:"
	@echo "     Run the rulechecker to look for code style violations."
	@echo ""
	@echo "release-test:"
	@echo "     Run the integration test suite"
	@echo ""
	@echo "runtests:"
	@echo "     Build and run all tests for the project, or package-level tests only."
	@echo "     (Depends on the location where \"scram b runtests\" is run)."
	@echo ""

.PHONY: release release-build release-reset release-check release-test release-doc release-docs release-freeze rulechecker

release: release-reset release-build postbuild

release-build: project_all

release-reset: distclean

release-check: release-test

release-test: integration-test

release-docs release-doc: doc

release-freeze: release-check
	@echo "Cleaning up and protecting directories:"
	@cd $(LOCALTOP); \
	rm -fr $(SCRAM_INTwork)/$(SCRAM_SOURCEDIR) ; \
	rm -fr $(SCRAM_INTwork)/cache ; \
	find . -type f -print | xargs chmod a-w; \
	find . -type d -print | xargs chmod 555

rulechecker:
	@echo "Sorry, \"$@\" target is no more available. To run RuleChecker please do either"
	@echo "  For csh/tcst:"
	@echo "    env CMS_RULECHECKER=1 scramv1 b"
	@echo "  OR For bash/sh:"
	@echo "    CMS_RULECHECKER=1 scramv1 b"
###############################################################################
ifdef SCRAM_NOLOADCHECK
SHARED_LIB_LOAD_CHECK :=
endif
PLUGIN_REFRESH_CMDS :=
###############################################################################
-include $(TOOLS_MKDIR).mk
-include $(PUB_DIRCACHE_MKDIR)/src.mk
-include $(PUB_DIRCACHE_MKDIR)/DirCache.mk
-include $(DIRCACHE_MKDIR)/ExtraBuilsRules/*.mk
-include $(DIRCACHE_MKDIR)/DirCache.mk
-include $(TOOLS_MKDIR)/SCRAMBased/all.mk
-include $(DIRCACHE_MKDIR)/RmvDirCache.mk
####### Clean up the directories which were already build but now have been removed from src area ######
ifneq ($(strip $(REMOVED_DIRS)),)
$(shell echo "" > $(WORKINGDIR)/.AUTOCLEAN)
$(foreach d,$(sort $(REMOVED_DIRS)),$(if $(wildcard $(WORKINGDIR)/$(d)),$(eval xx:=$(shell find $(WORKINGDIR)/$(d) -name "AUTOCLEAN.*.clean" -type f | xargs cat | grep "^0[0-9]:" | sed "s|^0[0-9]:||" |sort | uniq >> $(WORKINGDIR)/.AUTOCLEAN)$(info Cleaning up removed directory:$(d))$(shell rm -rf $(WORKINGDIR)/$(d))),))
$(foreach d,$(REMOVED_DIRS),$(if $(wildcard $(WORKINGDIR)/cache/bf/$(d)/$(SCRAM_BUILDFILE)),$(shell touch $(SCRAM_INTwork)/cache/bf/$(d)/$(SCRAM_BUILDFILE)),))
$(shell sh $(WORKINGDIR)/.AUTOCLEAN; rm -rf $(DIRCACHE_MKDIR)/RmvDirCache.mk $(DIRCACHE_MKDIR)/RmvDirCache; mkdir -p $(DIRCACHE_MKDIR)/RmvDirCache; touch $(DIRCACHE_MKDIR)/RmvDirCache.mk)
endif
####### Update Tools and Prods rules ##############
ifeq ($(strip $(UFAST)),)
$(foreach x,$(ALL_TOOLS),$(eval $($(x)_INIT_FUNC)))
$(foreach x,$(ALL_TOOLS),$(foreach err,$($(x)_USE_ERR),$(eval $(call UseError,$(err),$(x)))))
ifeq ($(strip $(XFAST)),)
$(foreach x,$(ALL_EXTERNAL_PRODS),$(eval $(call ProductCommonVarsExternal,$(x)))$(eval $($(x)_INIT_FUNC)))
$(foreach x,$(ALL_PRODS),$(eval $(call ProductCommonVars,$(x),,,$($(x)_BuildFile))))
ifeq ($(strip $(FAST)),)
$(info >> Local Products Rules ..... started)
$(foreach x,$(ALL_PRODS),$(eval $($(x)_INIT_FUNC)))
$(info >> Local Products Rules ..... done)
endif
$(foreach bf,$(ALL_BUILDFILES),$(foreach err,$(sort $($(bf)_USE_ERR)),$(eval $(call UseError,$(err),$(bf)))))
$(foreach x,$(ALL_COMMONRULES),$(eval $($(x)_INIT_FUNC)))
endif
####### Update Subsystems and Packages rules ##############
$(foreach dir,$(ALL_SUBSYSTEMS),$(eval $(call SubSystem,$(dir),src_$(subst /,_,$(dir)))))
$(foreach dir,$(ALL_PACKAGES),$(eval $(call Package,$(dir),src_$(subst /,_,$(dir)))))
endif
###########################################################
PHONY: $(SCRAM_SOURCEDIR) prebuild postbuild runtests_$(SCRAM_SOURCEDIR) runpython_$(SCRAM_SOURCEDIR)
$(SCRAM_SOURCEDIR): prebuild $($(SCRAM_SOURCEDIR)) $(subdirs_$(SCRAM_SOURCEDIR))
	@:
prebuild: $(prebuild)
	@echo ">> Building $(SCRAM_PROJECTNAME) version $(SCRAM_PROJECTVERSION) ----"; \
	[ -d $(LOCALTOP)/logs/$(SCRAM_ARCH) ] || mkdir -p $(LOCALTOP)/logs/$(SCRAM_ARCH)
postbuild: $(postbuild) release-check
	@echo "Release $(SCRAM_PROJECTNAME) version $(SCRAM_PROJECTVERSION) build finished at `date`"
runpython_$(SCRAM_SOURCEDIR): $(addprefix runpython_, $(subdirs_$(SCRAM_SOURCEDIR)))
	@echo ">> Python completed for $(SCRAM_PROJECTNAME) $(SCRAM_PROJECTVERSION)"
runtests_$(SCRAM_SOURCEDIR): $(addprefix runtests_, $(subdirs_$(SCRAM_SOURCEDIR)))
	@echo ">> Test sequence completed for $(SCRAM_PROJECTNAME) $(SCRAM_PROJECTVERSION)"
###########################################################

.PHONY: all_% clean_% help_% runtests_% runpython_% ufast xfast fast %_USED_BY %_USES echo_% outputlog
.PHONY: help_%_python help_%_src help_%_plugins help_%_bin help_%_test help_$(SCRAM_SOURCEDIR)_%
help_%_python:
	@echo "Running \"scram build\" here will run rules for pythin i.e. creates sym-links and compiles python modules"
help_%_src:
	@echo "Running \"scram build\" here normally build a shared library."
help_%_plugins:
	@echo "Running \"scram build\" here normally build EDM-plugins."
help_%_bin:
	@echo "Running \"scram build\" here normally build public executables and shared libs (if any)."
help_%_test:
	@echo "Running \"scram build\" here normally build test executables and shared libs (if any)."
help_$(SCRAM_SOURCEDIR)_%:
	@echo "Doing \"scram build\" here will build every thing exist under this directory."
all_% runtests_% help_% runpython_%:
	@if [ "X$(TARGETDIR)" = "X$*" ] ; then \
	  echo ">> Nothing to be done for $(THISDIR)";\
	fi
clean_%:
	@if [ "X$($*_objdir)" != "X" ] ; then \
	  dir=`echo $($*_objdir) | grep '^$(WORKINGDIR)/' | sed 's|^$(WORKINGDIR)/||'`;\
	  if [ "X$$dir" != "X" ] ; then \
	    if [ -d $(WORKINGDIR)/$$dir ] ; then \
	      echo "Cleaning up $$dir"; $(call BuildClean,$$dir) ; exit 0;\
	    fi;\
	  fi;\
	elif [ "$(TARGETDIR)" == "$*" ] ; then \
	  echo "Cleaning up $(THISDIR)"; $(call BuildClean,$(THISDIR));\
	else \
	  echo "***WARNING: Unknown product $*. Failed to cleanup.";\
	fi
ufast xfast fast:
	@:
%_USED_BY:
	@var=$(call GetEchoVariable,$@);\
	if [ "X$$var" != "X" ] ; then \
	  $(SCRAM_CONFIGDIR)/SCRAM/projectInfo.pl $(LOCALTOP) USED_BY $(patsubst %_USED_BY,%,$(call GetEchoVariable,$@)) $(SCRAM_ARCH);\
	fi
%_USES:
	@var=$(call GetEchoVariable,$@);\
	if [ "X$$var" != "X" ] ; then \
	  $(SCRAM_CONFIGDIR)/SCRAM/projectInfo.pl $(LOCALTOP) USES $(patsubst %_USES,%,$(call GetEchoVariable,$@)) $(SCRAM_ARCH);\
	fi
%_ORIGIN:
	@var=$(call GetEchoVariable,$@);\
	if [ "X$$var" != "X" ] ; then \
	  $(SCRAM_CONFIGDIR)/SCRAM/projectInfo.pl $(LOCALTOP) ORIGIN $(patsubst %_ORIGIN,%,$(call GetEchoVariable,$@)) $(SCRAM_ARCH);\
	fi
echo_%:
	@echo "$* = $(subst ",\",$($*))"
$(COMMON_WORKINGDIR)/python_symlinks: FORCE_TARGET
	@echo ">> Updating python symlinks."
	@for d in $(ALL_PYTHON_DIRS); do \
	  p=`dirname python/$$d`;\
	  if [ ! -e $$p ] ; then \
	    s=`dirname $$p`;\
	    mkdir -p $$s;\
	    r=.. ;\
	    s1=$$s ;\
	    while [ "$$s1" != "python" ] ; do \
	      if [ "X$(RELEASETOP)" = "X" ] ; then \
		echo "import os" > $$s1/__init__.py;\
		echo "localrt=os.getenv('LOCALRT', None)" >> $$s1/__init__.py;\
		echo "if localrt != None:" >> $$s1/__init__.py;\
	        echo "  __path__.insert(0,localrt+'/$$s1')" >> $$s1/__init__.py;\
	      else \
		echo "__path__.append('$(RELEASETOP)/$$s1')" > $$s1/__init__.py;\
	      fi;\
	      s1=`dirname $$s1`;\
	      r=$$r/..;\
	    done ;\
	    touch $$s1/__init__.py;\
	    ln -s $$r/$(SCRAM_SOURCEDIR)/$$d $$p ;\
	    echo "   python/$$d -> $(SCRAM_SOURCEDIR)/$$d" ;\
	  fi;\
	done
	@for d in $(ALL_PYTHON_DIRS); do \
	  for dir in `find $(SCRAM_SOURCEDIR)/$$d -name "*" -type d | grep -v '/CVS$$\|/CVS/'`; do \
	    if [ ! -f $$dir/__init__.py ] ; then \
	      echo "#Automatically created by SCRAM" > $$dir/__init__.py;\
	      [ -d $(WORKINGDIR)/$$dir ] || mkdir -p $(WORKINGDIR)/$$dir ;\
	      cf=$(call AutoCleanFile,$(WORKINGDIR)/$$dir/__init__.py,python) ;\
	      echo "01:rm -f $$dir/__init__.py $$dir/__init__.pyc" > $$cf;\
	    fi;\
	  done;\
	done
	@for l in `find python -name "*" -type l`; do \
	  if [ ! -f $$l/__init__.py ] ; then rm -f $$l; fi;\
	done
	@[ -f $@ ] || (mkdir -p $(@D) ; touch -t $(OLD_TIMESTAMP) $@)
$(WORKINGDIR)/%/productautocleanup: FORCE_TARGET
	@for dir in $(foreach x,$(patsubst productautocleanup,,$(notdir $(patsubst %/,%,$(dir $(wildcard $(@D)/*/AUTOCLEAN.*.clean))))),$(if $(findstring all_$x,$($(subst /,_,$*))),,$x)) ; do \
	  $(call BuildClean,$*/$$dir,0[0-9]);\
	done
	@[ -d $(@D) ] || mkdir -p $(@D) &&\
	touch -t $(OLD_TIMESTAMP) $@
biglib: $(if $(strip $(filter-out biglib,$(MAKECMDGOALS))),$(filter-out biglib,$(MAKECMDGOALS)),all)
	@:
outputlog:
	$(eval DO_BUILD_LOG:=)
	@$(call outputlog,,,)
runtime:
	@echo ">> Runtime environment:"; env
%:
	@echo TARGET:$@
	@var=$(call GetEchoVariable,$@);\
	if [ "X$$var" != "X" ] ; then \
	  echo "$$var = $(subst ",\",$($(patsubst echo_%,%,$@)))";\
	fi
