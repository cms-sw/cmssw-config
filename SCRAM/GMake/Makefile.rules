TARGETDIR:= $(subst /,_,$(THISDIR))
.DEFAULT_GOAL := all
##############################################################################
multipletools := info
wrongtool := info
comma:= ,
empty:= 
colon:= :
path_seperator := :
space:= $(epmty) $(empty)
prebuild       := 
postbuild      :=
prelibdeps     :=
prebindeps     :=
ALL_SCRAM_PROJECTS :=
ALL_SUBSYSTEMS     :=
ALL_PACKAGES       :=
ALL_PYTHON_DIRS    :=
ALL_EMPTY_PACKAGES :=
ALL_BUILDFILES     :=
ALL_TOOLS          :=
ALL_PRODS          :=
SKIP_UNITTESTS     := $(patsubst skiptest_%,%,$(filter skiptest_%,$(MAKECMDGOALS)))
FAST:=
XFAST:=
UFAST:=
ONLYECHOTARGETS:=
OBJEXT:=o
MODULE_PREFIX:=lib
COMMON_WORKINGDIR := $(SCRAM_TMP)/common
WORKINGDIR := $(SCRAM_INTwork)
YACC                        := bison
LEX                         := flex
LATEX                       := latex
DVISUFFIX                   := dvi
PSSUFFIX                    := ps
PDFSUFFIX                   := pdf
PS2PDF                      := ps2pdf
DVIPS                       := dvips
LD                          := ld
ifndef LD_UNIT
ifeq ($(findstring ia32,$(subst _, ,$(SCRAM_ARCH))),ia32)
LD_UNIT                     := -r -m elf_i386
else
LD_UNIT                     := -r -m elf_x86_64
endif
endif
LD_UNIT_FLAGS               := -z muldefs
BIGLIB_OBJEXT               := obj
OLD_TIMESTAMP               := 198001010100
NON_XML_BUILDFILE           := 
ALL_PYTHON_COMPILE          := 
UPDATE_CLASSVERSION         :=
ALL_CLASS_VERSION_RULES     :=
###################################
CMDS_COMPILERS_MAP          := CXX:g++ CC:gcc FC:g77
ALL_CMDS                    := sh awk cat chmod cp dirname echo find g++ g77 gcc grep ln ls mkdir mv perl python rm sed sort touch tr uname uniq xargs
SHELL                       := /bin/sh
BASECMD_which               := which
###################################
SetLocalCMDs    = $(if $($1),$(eval CMD_$2:=$($1)),)
SetCompilerCMDs = $(if $($1),,$(eval $1:=$(CMD_$2)))
ShellCMDs       = $(if $(CMD_$1),,$(eval CMD_$1:=$(eval x:=$(strip $(firstword $(shell $(BASECMD_which) $1 2>&1))))$(if $(wildcard $x),$x,$1)))
###################################
$(eval $(call ShellCMDs,which))
BASECMD_which := $(CMD_which)
$(foreach c,$(CMDS_COMPILERS_MAP),$(eval $$(call SetLocalCMDs,$(subst :,$(comma),$c))))
$(foreach c,$(ALL_CMDS)         ,$(eval $(call ShellCMDs,$c)))
$(foreach c,$(CMDS_COMPILERS_MAP),$(eval $$(call SetCompilerCMDs,$(subst :,$(comma),$c))))
###################################
UNAME                       := $(CMD_uname)
ifndef CXX_MMD
CXX_MMD:=-MMD
endif
ifndef C_MMD
C_MMD:=-MMD
endif
ifndef F77_MMD
F77_MMD:=-MMD
endif
###################################
OS_LDLIB_PATH := LD_LIBRARY_PATH
ifndef SHAREDSUFFIX
ifeq ($(filter-out osx%,$(SCRAM_ARCH)),)
SHAREDSUFFIX                := dylib
OS_LDLIB_PATH               := DYLD_FALLBACK_LIBRARY_PATH
else
SHAREDSUFFIX                := so
endif
endif
ifndef MODULEFLAGS
ifeq ($(filter-out slc%,$(SCRAM_ARCH)),)
MODULEFLAGS                 := -shared
endif
endif
MODULE_SUFFIX               := $(SHAREDSUFFIX)
SHARED_LIB_LOAD_CHECK       := 
##############################################################################
ifndef SCRAMSTORENAME_LIB
SCRAMSTORENAME_LIB:=lib
endif
ifeq ($(strip $(SCRAM_SOURCEDIR)),)
SCRAM_SOURCEDIR:=src
endif

ifneq ($(strip $(PYTHON_BASE)),)
CMD_python := $(PYTHON_BASE)/bin/python
endif

ifneq ($(wildcard $(WORKINGDIR)/cache/bf/$(SCRAM_CONFIGDIR)/$(SCRAM_BUILDFILE)),)
CONFIGDEPS += $(WORKINGDIR)/cache/bf/$(SCRAM_CONFIGDIR)/$(SCRAM_BUILDFILE)
endif
CONFIGDEPS += $(WORKINGDIR)/cache/xlibs

ifndef SCRAM_BUILDVERBOSE
VERB:=@
VERB_ECHO:=:
else
VERB:=
VERB_ECHO:=echo
endif

ifeq ($(strip $(BUILD_LOG)),yes)
DO_BUILD_LOG:=
else
DO_BUILD_LOG:=:
endif

ifneq ($(findstring k,$(firstword  $(MAKEFLAGS))),)
FORCE_BUILD_START = (
FORCE_BUILD_END = ) || ($(CMD_echo) gmake: \*\*\* [$@] Error $$? ; exit 0)
else
ifeq ($(strip $(BUILD_LOG)),yes)
FORCE_BUILD_START = (
FORCE_BUILD_END = ) || (exitcode=$$?; $(CMD_echo) gmake: \*\*\* [$@] Error $$exitcode ; exit $$exitcode)
else
FORCE_BUILD_START =
FORCE_BUILD_END =
endif
endif

$(SCRAM_SOURCEDIR) :=

##############################################################################
##############################################################################
define set_cached_var_func_arg_
cached_var_func_arg$(cached_var_func_arg_count_$(1))_$(1) := $(2)
cached_var_func_arg_count_$(1) := $(cached_var_func_arg_count_$(1))1
endef
define set_cached_var_
cached_var_func_arg_count_$(1) := 
$(foreach arg,$(subst $(comma),$(space),$(cached_var_function_$(1))),$(eval $(call set_cached_var_func_arg_,$(1),$(arg))))
cached_var_$(1) := $(call $(cached_var_func_arg_$(1)),$(cached_var_func_arg1_$(1)),$(cached_var_func_arg11_$(1)),$(cached_var_func_arg111_$(1)),$(cached_var_func_arg1111_$(1)),$(cached_var_func_arg11111_$(1)))
endef
define get_cached_var_
$(if $(subst undefined,,$(origin cached_var_$(1))),$(cached_var_$(1)),$(eval $(call set_cached_var_,$(1)))$(cached_var_$(1)))
endef
define get_uniq_cached_var_
$(if $(subst undefined,,$(origin cached_var_$(1))),$(cached_var_$(1)),$(eval $(call set_cached_var_,$(1)))$(eval cached_var_$(1):=$(call Uniq,$(cached_var_$(1))))$(cached_var_$(1)))
endef
##############################################################################
define GetTimeStamp
$(CMD_perl) -e '@d=stat "$(1)"; print "$$d[9]\n";'
endef
define Uniq
$(eval uniq_string_:=)$(strip $(foreach v,$(1),$(if $(filter $(v),$(uniq_string_)),,$(eval uniq_string_+=$(v))))$(uniq_string_))
endef
define AddCachedVariable
cached_var_function_$(1)  := $(subst $(colon),$(comma),$(2))
ifeq ($$(strip $(3)),)
$(1) = $$(call get_cached_var_,$(1))
else
$(1) = $$(call get_uniq_cached_var_,$(1))
endif
endef
define GetVariable
$($(1))
endef
define AdjustFlags
$(foreach f,$3,$(filter-out $(strip $(foreach t,$2,$(REM_$t_$f)) $(REM_$f)),$($1_$f)) $(foreach t,$2,$($t_$f)))
endef
define ToolCXXFlags
$(filter-out $(USER_REM_CXXFLAGS),$(CXXFLAGS)) $($(1)_LOC_FLAGS_CXXFLAGS_ALL) $(USER_CXXFLAGS)
endef
define ToolFFlags
$(filter-out $(USER_REM_FFLAGS),$(FFLAGS)) $($(1)_LOC_FLAGS_FFLAGS_ALL) $(USER_FFLAGS)
endef
define ToolCFlags
$(filter-out $(USER_REM_CFLAGS),$(CFLAGS)) $($(1)_LOC_FLAGS_CFLAGS_ALL) $(USER_CFLAGS)
endef
define ToolCPPFlags
$(filter-out $(USER_REM_CPPFLAGS),$(CPPFLAGS)) $(filter-out $(USER_REM_CPPDEFINES),$(CPPDEFINES)) $($(1)_LOC_FLAGS_CPPDEFINES_ALL) $($(1)_LOC_FLAGS_CPPFLAGS_ALL) $(USER_CPPFLAGS) $(USER_CPPDEFINE) $(addprefix -I,$(INCLUDE)) $(addprefix -I,$($(1)_LOC_INCLUDE_ALL))
endef
define ToolLDFlags
$(USER_LDFLAGS) $(filter-out $(USER_REM_LDFLAGS),$(LDFLAGS)) $(addprefix -L,$(LIBDIR) $(filter-out $(LIBDIR),$(filter $(LOCALTOP)/%,$($(1)_LOC_FLAGS_LIBDIR_ALL)))) $(addprefix -l,$(LIB)) $(addprefix -l,$($(1)_LOC_LIB_ALL)) $($(1)_LOC_FLAGS_LDFLAGS_ALL)
endef
define ScramOrderedTools
$(if $(strip $(SCRAM_PROJECTS)),$(warning Calculationg ScramOrderedTools)$(shell $(CMD_echo) $(foreach t,$(SCRAM_PROJECTS),$($(t)_ORDER):$(t)) | $(CMD_tr) ' ' '\n' | $(CMD_sort) -r | $(CMD_sed) 's|.*:||'),$(warning Calculationg ScramOrderedTools))
endef
define CalculateToolOrder
$(if $(strip $($(1)_LOC_USE)),$(shell $(CMD_perl) \-e '@z=($(2) $(foreach dep,$(foreach d,$($(1)_LOC_USE),$($d)),$(comma)$($(dep)_ORDER))); @z=sort {$$a <=> $$b} @z;$$x=$$z[0];$$x--;print "$$x";'),$(2))
endef
define FindToolDependency
$(sort $(foreach dep,$(foreach d,$($(1)_$(2)_USE),$($d)),$(dep) $($(dep)_EX_USE_ALL)))
endef
define FindUOLibDependency
$(sort $(foreach d,$($(1)_LOC_USE) $($(1)_EX_USE),$($($d)_EX_LIB) $($($d)_EX_UOLIB)))
endef
define FindToolDepVariable
$($(1)_$(3)_$(2)) $(foreach var,$(sort $(foreach dep,$($(1)_$(3)_USE_ALL),$($(dep)_ORDER):$(strip $(subst $(space),$(colon),$($(dep)_EX_$(2)))))),$(wordlist 2,99999,$(subst $(colon),$(space),$(var))))
endef
define ProductCommonVars
ifeq ($$(strip $(3)),)
$$(eval $$(call AddCachedVariable,$(1)_ORDER,CalculateToolOrder:$(1):$(if $(strip $(2)),$(strip $(2)),99999),))
else
$(1)_ORDER:=$(3)
endif
$$(foreach scope,EX LOC,$$(foreach type,INCLUDE LIB LIBDIR FLAGS_CPPDEFINES FLAGS_CPPFLAGS FLAGS_CXXFLAGS FLAGS_LDFLAGS FLAGS_CFLAGS FLAGS_FFLAGS,$$(eval $$(call AddCachedVariable,$(1)_$$(scope)_$$(type)_ALL,FindToolDepVariable:$(1):$$(type):$$(scope),1))))
$$(foreach scope,EX LOC,$$(eval $$(call AddCachedVariable,$(1)_$$(scope)_USE_ALL,FindToolDependency:$(1):$$(scope),)))
$$(eval $$(call AddCachedVariable,$(1)_CXXFLAGS,ToolCXXFlags:$(1),))
$$(eval $$(call AddCachedVariable,$(1)_CPPFLAGS,ToolCPPFlags:$(1),))
$$(eval $$(call AddCachedVariable,$(1)_FFLAGS,ToolFFlags:$(1),))
$$(eval $$(call AddCachedVariable,$(1)_CFLAGS,ToolCFlags:$(1),))
$$(eval $$(call AddCachedVariable,$(1)_LDFLAGS,ToolLDFlags:$(1),))
$(foreach err,$(foreach use,$(sort $($(1)_LOC_USE) $($(1)_EX_USE)),$(if $($(use)),,$(use))),$(eval $(4)_USE_ERR+=$(err)))
endef
define ProductCommonVarsExternal
ifneq ($$(strip $$($(1)_BuildFile)),)
$$(eval $$(call AddCachedVariable,$(1)_ORDER,CalculateToolOrder:$(1):99999,))
$$(foreach type,INCLUDE LIB,$$(eval $$(call AddCachedVariable,$(1)_EX_$$(type)_ALL,FindToolDepVariable:$(1):$$(type):EX,1)))
$$(eval $$(call AddCachedVariable,$(1)_EX_USE_ALL,FindToolDependency:$(1):EX,))
$$(eval $$(call AddCachedVariable,$(1)_EX_UOLIB,FindUOLibDependency:$(1):,))
else
$(1)_ORDER:=99999
endif
endef
define outputlog
  @if [ -d $(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR)/$(1) ] ; then \
    $(DO_BUILD_LOG) for f in `$(CMD_find) $(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR)/$(1) -name "*" -type f | $(CMD_grep) -v  '/build\.log$$'` ; $(DO_BUILD_LOG) do $(DO_BUILD_LOG) $(CMD_cat) $$f $(redirectlog_$(2)) ; $(DO_BUILD_LOG) $(CMD_rm) -f $$f;  $(DO_BUILD_LOG) done ;\
  fi
endef
define outputLogFile
  @if [ "X$1" != "X" ] ; then \
    $(CMD_cat) $1;\
    dir=`$(CMD_dirname) $1`;\
    while [ ! -f "$$dir/build.log" ] && [ "$$dir" != "$(WORKINGDIR)/cache/log/$(SCRAM_SOURCEDIR)" ] ; do \
      dir=`$(CMD_dirname) $$dir`;\
    done ;\
    [ -f "$$dir/build.log" ] && $(CMD_cat) $1 >> $$dir/build.log ;\
    $(CMD_rm) -f $1;\
  fi
endef
define checklibs
  $(eval xliberr:=)$(foreach x,$($(1)_LOC_LIB),$(if $(strip $(filter-out $($(1)_PACKAGE),$($(x)_PACKAGE))),$(eval xliberr+=$x:$($(x)_PACKAGE)),)) \
  if [ "X$(xliberr)" != "X" ] ; then \
    $(CMD_echo) "****ERROR: Skipping build of $1 generated from $($(1)_PACKAGE) as it is explicitly linking following library/libraries." ;\
    for x in $(xliberr) ; do $(CMD_echo) "    -> $$x" | $(CMD_sed) 's|:self/| from |';  done;\
    false;\
  fi
endef
##############################################################################
define BuildClean
  if [ "X$(1)" != "X" ] ; then \
    if [ -d $(WORKINGDIR)/$(1) ] ; then \
      regexp=$2; \
      if [ "X$$regexp" == "X" ] ; then regexp='[0-9][0-9]'; fi ;\
      $(CMD_find) $(WORKINGDIR)/$(1) -name "AUTOCLEAN.*.clean" -type f | $(CMD_xargs) $(CMD_cat) | $(CMD_grep) "^$$regexp:" | $(CMD_sort) | $(CMD_uniq) | $(CMD_sed) "s|^$$regexp:||" > $(WORKINGDIR)/$(1)/.AUTOCLEAN ; \
      if [ "X$3" == "X" ] ; then $(CMD_cat) $(WORKINGDIR)/$(1)/.AUTOCLEAN; fi;\
      $(CMD_sh) $(WORKINGDIR)/$(1)/.AUTOCLEAN;\
      $(CMD_rm) -rf $(WORKINGDIR)/$(1); \
    fi;\
  fi
endef

define AutoCleanFile
$(dir $(1))/AUTOCLEAN.$(notdir $(1)).$(2).clean
endef
##############################################################################
# Macros for pre/post build steps:
define copy_build_product
  if [ ! -d $(LOCALTOP)/$(1) ]; then 	\
    $(CMD_mkdir) -p $(LOCALTOP)/$(1)	&&\
    $(CMD_echo) "Creating product storage directory: $(LOCALTOP)/$(1)"; \
  fi &&\
  $(CMD_echo) "Copying $@ to productstore area:" &&\
  $(CMD_echo) "01:$(CMD_rm) -f $(1)/$(@F)" > $(call AutoCleanFile,$@,prod) &&\
  $(CMD_cp) $@ $(LOCALTOP)/$(1) || ($(CMD_rm) -f $@ && $(CMD_echo) ">> Deleted: $@" && exit 1)
endef

define copy_lib_to_main_productstore
  $(call install_name_tool,$(@F),$@) && $(call copy_build_product,$(1))
endef

define copy_bigobj_to_main_productstore
  $(call copy_build_product,$(1))
endef

define copy_bin_to_main_productstore
  $(call copy_build_product,$(1))
endef

define copy_test_to_main_productstore
  $(call copy_build_product,$(1))
endef

define copy_py_to_main_productstore
  $(call copy_build_product,$(1))
endef

define delete_build_prod 
  $(CMD_rm) -f $@ $(LOCALTOP)/$(1)/$(@F)
endef

define delete_plugin_build_prod 
  $(call delete_build_prod,$(1)) &&\
  if [ "X$(2)" != X ] ; then \
    if [ -f $($(2)_pluginprod) ] ; then \
      $(CMD_touch) $(LOCALTOP)/$(SCRAM_INTwork)/cache/$($(2)_plugintype)_$($(2)_pluginrefresh) &&\
      $(CMD_rm) -f $(LOCALTOP)/$($(2)_pluginprod) ;\
    fi ;\
  fi
endef

define	clean_path
  @if [ -d $(LOCALTOP)/$(1) ] ; then \
    $(CMD_echo) "Cleaning local working directory:$(1)"; \
    $(CMD_rm) -rf $(LOCALTOP)/$(1) ; \
  fi
endef

define clean_prod
  @if [ -f $(LOCALTOP)/$(1) ] ; then \
    $(CMD_echo) "Cleaning product: $(1)" ; \
    $(CMD_rm) -f $(LOCALTOP)/$(1); \
  fi    
endef

define clean_src_scripts
  @$(call clean_files,$(1),$(2))
endef

define clean_files
  for f in $(1); do \
    $(CMD_rm) -rf $(LOCALTOP)/$(2)/$$f;	\
  done
endef

define edm_plugin_clean
  $(call clean_prod,$($(1)_plugindir)/plugin$(1).$(SHAREDSUFFIX))
  $(call clean_prod,$($(1)_pluginprod))
endef

define rivet_plugin_clean
  $(call clean_prod,$($(1)_pluginprod))
endef

define do_plugin_refresh
endef
#############################################################################
##############################################################################
define check_module_load
  if [ "X$(SHARED_LIB_LOAD_CHECK)" != X ] ; then \
    if [ "X$(1)" = X ] ; then \
      $(CMD_echo) "@@@@ Checking shared library load: $(@F)"	&&\
      ($(SHARED_LIB_LOAD_CHECK) $@ || ($(call delete_plugin_build_prod,$(2),$(3)) && exit 1)) &&\
      $(CMD_echo) "@@@@ ----> OK, shared library loaded successfully: $(@F)" ; \
    else \
      $(CMD_echo) "@@@@ Shared library loading was SKIPPED due to NO_LIB_CHECKING flag in BuildFile: $(@F)"; \
    fi ;\
  else \
    $(CMD_echo) "@@@@ Shared library loading was SKIPPED due to SCRAM_NOLOADCHECK: $(@F)" ;\
  fi
endef

ifeq ($(filter-out osx%,$(SCRAM_ARCH)),)
  define install_name_tool
    install_name_tool -id $1 $2
  endef
else
  define install_name_tool
    true
  endef
endif

ifndef SCRAM_NOEDMWRITECONFIG
define edm_write_config
  $(CMD_rm) -rf $(<D)/edm_write_config && $(CMD_mkdir) -p $(<D)/edm_write_config &&\
  $(CMD_echo) "@@@@ Running $(EDM_WRITE_CONFIG) for $(1)" &&\
  (cd $(<D)/edm_write_config && $(EDM_WRITE_CONFIG) -p $(LOCALTOP)/$<) &&\
  for file in `$(CMD_ls) $(<D)/edm_write_config`; do \
    ([ -d $(SCRAMSTORENAME_CFIPYTHON)/$($(1)_package) ] || $(CMD_mkdir) -p $(SCRAMSTORENAME_CFIPYTHON)/$($(1)_package)) ;\
    $(CMD_cp) -f $(<D)/edm_write_config/$$file $(SCRAMSTORENAME_CFIPYTHON)/$($(1)_package) ;\
    $(CMD_echo) "01:$(CMD_rm) -f $(SCRAMSTORENAME_CFIPYTHON)/$($(1)_package)/$$file" >> $(call AutoCleanFile,$<,edm) ;\
  done
endef
else
define edm_write_config
  $(CMD_echo) "@@@@ Skipping $(EDM_WRITE_CONFIG) for $(1) due to SCRAM_NOEDMWRITECONFIG"
endef
endif

define rivet_register_plugin
  @$(startlog_$(2)) if [ -f $< ] ; then \
    [ -d $(@D) ] || $(CMD_mkdir) -p $(@D) &&\
    $(call install_name_tool,$(@F),$<) &&\
    $(CMD_cp) -f $< $@ &&\
    $(CMD_echo) "01:$(CMD_rm) -f $@"               > $(call AutoCleanFile,$<,rivet) &&\
    echo "--- Registered Rivet Plugin: $(1)"; \
  else \
    rm -f $@ ;\
  fi $(endlog_$(2))
endef

define edm_register_plugin
  @$(startlog_$(2)) $(CMD_touch) $(LOCALTOP)/$(SCRAM_INTwork)/cache/edm_$($(1)_pluginrefresh) &&\
  if [ -f $< ] ; then \
    [ -d $(@D) ] || $(CMD_mkdir) -p $(@D) &&\
    ($(call edm_write_config,$(1)) || ($(CMD_rm) -f $< && exit 1)) &&\
    plugin=$(patsubst lib%,plugin%,$(<F)) &&\
    $(CMD_echo) "module $$plugin" > $(<D)/$(@F) &&\
    (($(CMD_cp) -f $< $(@D)/$$plugin && $(call install_name_tool,$(patsubst lib%,plugin%,$(<F)),$(@D)/$(patsubst lib%,plugin%,$(<F)))) || ($(CMD_rm) -f $< $(<D)/$$plugin && exit 1)) &&\
    $(CMD_cp) -f $(<D)/$(@F) $@ &&\
    $(CMD_echo) "01:$(CMD_rm) -f $(@D)/$$plugin $@" > $(call AutoCleanFile,$<,edm) &&\
    $(CMD_echo) "90:EdmPluginRefresh $(@D)" >> $(call AutoCleanFile,$<,edm) &&\
    $(CMD_echo) "--- Registered EDM Plugin: $(1)"; \
  else \
    $(CMD_rm) -f $@ $(@D)/$(patsubst lib%,plugin%,$(<F)) ;\
  fi $(endlog_$(2))
endef
##############################################################################
##############################################################################
#Compilation Rules
define compile_cxx_common
  @$(startlog_$(2)) [ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Compiling $(4) $< " &&\
  $(VERB_ECHO) $(CXX) $(CXX_MMD) -c $(3) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $< -o $@ &&\
  (             $(CXX) $(CXX_MMD) -c $(3) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $< -o $@ $(5) $(endlog_$(2)))
endef
define compile_c_common
  @$(startlog_$(2)) [ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Compiling $(4) $< " &&\
  $(VERB_ECHO) $(CC) $(C_MMD) -c $(3) $(COPTIMISEDFLAGS) $(CSHAREDOBJECTFLAGS) $< -o $@ &&\
  (             $(CC) $(C_MMD) -c $(3) $(COPTIMISEDFLAGS) $(CSHAREDOBJECTFLAGS) $< -o $@ $(5) $(endlog_$(2)))
endef
define compile_fortran_common
  @$(startlog_$(2)) [ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Compiling $(4) $< " &&\
  $(VERB_ECHO) $(FC) $(F77_MMD) -c $(3) $(FOPTIMISEDFLAGS) $(FCSHAREDOBJECTFLAGS) $< -o $@ &&\
  (             $(FC) $(F77_MMD) -c $(3) $(FOPTIMISEDFLAGS) $(FCSHAREDOBJECTFLAGS) $< -o $@ $(5) $(endlog_$(2)))
endef
##############################################################################
define compile_cxx
  $(call compile_cxx_common,$1,$2,$(call AdjustFlags,$1,,CPPFLAGS CXXFLAGS))
endef
define compile_cxx_capabilities
  $(call compile_cxx_common,$1,$2,$(call AdjustFlags,$1,EDM CAPABILITIES,CPPFLAGS CXXFLAGS),capabilities)
endef
define compile_cxx_edm
  $(call compile_cxx_common,$1,$2,$(call AdjustFlags,$1,EDM,CPPFLAGS CXXFLAGS),edm plugin)
endef
define compile_c
  $(call compile_c_common,$1,$2,$(call AdjustFlags,$1,,CPPFLAGS CFLAGS))
endef
define compile_c_edm
  $(call compile_c_common,$1,$2,$(call AdjustFlags,$1,EDM,CPPFLAGS CFLAGS),edm plugin)
endef  
define compile_fortran
  $(call compile_fortran_common,$1,$2,$(call AdjustFlags,$1,,CPPFLAGS FFLAGS))
endef  
define compile_boost
  $(call compile_cxx_common,$1,$2,-DSCRAM_PYTHON_MODULE="BOOST_PYTHON_MODULE($*)" $(call AdjustFlags,$1,,CPPFLAGS PY_CXXFLAG),boost)
endef  
define compile_pywrapper
  $(call compile_cxx_common,$1,$2,-DSCRAM_PYTHON_MODULE="BOOST_PYTHON_MODULE($(1)_PyWrapper)" $(call AdjustFlags,$1,,CPPFLAGS PY_CXXFLAG),pywrapper)
endef
##############################################################################
# Dictionary compilation
define compile_lcgdict
  @$(startlog_$(2)) [ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Compiling LCG dictionary: $<" &&\
  $(VERB_ECHO)            $(CXX) $(CXX_MMD) -c $(call AdjustFlags,$1,LCGDICT,CPPFLAGS CXXFLAGS) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $(1)/$(patsubst $($(1)_objdir)/%,%,$<) -o $(1)/$(patsubst $($(1)_objdir)/%,%,$@) &&\
  ((cd $($(1)_objdir)/..; $(CXX) $(CXX_MMD) -c $(call AdjustFlags,$1,LCGDICT,CPPFLAGS CXXFLAGS) $(CXXOPTIMISEDFLAGS) $(CXXSHAREDOBJECTFLAGS) $(1)/$(patsubst $($(1)_objdir)/%,%,$<) -o $(1)/$(patsubst $($(1)_objdir)/%,%,$@)) || ($(CMD_rm) -f $< && exit 1)) $(endlog_$(2))
  @$(startlog_$(2))[ -f $(basename $@).d ] && $(CMD_sed) -e 's#^.*/$(3).o:#$<:#g' -e 's# .*$(3).cc ##g' $(basename $@).d | $(CMD_grep) -v '^ *\\$$' > $<.d &&\
  if [ -f $<.d ] ; then $(CMD_sed) -i -e 's|$(LOCALTOP)/||' $<.d ; $(CMD_rm) -f $(basename $@).d; fi $(endlog_$(2))
endef
# Root Dictionary compilation
define compile_rootdict
  $(call compile_cxx_common,$1,$2,$(call AdjustFlags,$1,ROOTDICT,CPPFLAGS CXXFLAGS),root dictionary,|| ($(CMD_rm) -f $< && exit 1))
  @$(startlog_$(2))[ -f $(basename $@).d ] && $(CMD_sed) -e 2d -e 's#^[ ]\\##g' -e 's#LinkDef.o:#LinkDef.cc:#g' -e 's#LinkDef.cc #LinkDef.cc: #g' \
  $(basename $@).d > $<.d &&\
  if [ -f $<.d ] ; then $(CMD_sed) 's|$(LOCALTOP)/||' $<.d > $<.d.backup ; $(CMD_mv) $<.d.backup $<.d; fi $(endlog_$(2))
endef
# compiling python
define set_python_timestamp
  for mod in $2; do \
    [ -f $(1)/$$mod.pyc ] && $(CMD_touch) -r $(1)/$$mod.py $(1)/$$mod.pyc;\
  done
endef

define compile_python
  @$(startlog_$(2)) [ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_touch) -t $(OLD_TIMESTAMP) $@ &&\
  $(CMD_echo) "01:$(CMD_find) $(4)/ -name '*.pyc' -type f 2>/dev/null | $(CMD_xargs) $(CMD_rm) -f " > $(call AutoCleanFile,$@,python) &&\
  pymods="" &&\
  for mod in `$(CMD_find) $(4)/ -name '*_cf[if].py' -type f | $(CMD_sed) 's|^$(4)/*||;s|.py$$||'`; do \
    pyc=$(4)/$$mod.pyc ;\
    py=$(4)/$$mod.py ;\
    if [ ! -f $$pyc ] || [ "X`$(call timestamp_cmp,$$py,$$pyc)`" != "X0" ] ;  then pymods="$$mod $$pymods";  fi;\
  done; \
  if [ "X$$pymods" != "X" ] ; then \
    $(CMD_echo) ">> Compiling cfi/cff python modules: $4";\
    modules=`$(CMD_echo) $(3).$$pymods | $(CMD_sed) 's|/|.|g;s| |,$(3).|g'`;\
    $(VERB_ECHO) "$(CMD_python) -c 'import $$modules'";\
    (($(CMD_python) -c "import $$modules" > /dev/null 2>&1 && $(call set_python_timestamp,$4,$$pymods)) || ($(call compile_python_individual,$1,$3,$$pymods,$4)));\
  fi $(endlog_$(2))
endef

define compile_python_individual
  $(CMD_rm) -f  $($(1)_objdir)/py.errors &&\
  for mod in $3; do \
    pyc=$(4)/$$mod.pyc ;\
    py=$(4)/$$mod.py ;\
    $(CMD_echo) ">> Compiling: $$py";\
    modx=`$(CMD_echo) $(2).$$mod | $(CMD_sed) 's|/|.|g'`;\
    $(VERB_ECHO) "$(CMD_python) -c 'import $$modx'";\
    (($(CMD_python) -c "import $$modx" && [ -f $$pyc ] && $(CMD_touch) -r $$py $$pyc) || ($(CMD_echo) "gmake: *** [$$py] Error $$?" && $(CMD_touch) $($(1)_objdir)/py.errors)) ;\
  done; \
  if [ -f $($(1)_objdir)/py.errors ] ; then \
    $(CMD_rm) -f $($(1)_objdir)/py.errors ;\
    ([ "X$(RELEASETOP)" == "X" ] || exit 1) ;\
  fi
endef
##############################################################################
# Source Generators Rules
# boost source generation from Pyste
define pyste2boost
  @$(startlog_$(2))$(CMD_echo)  ">> Generating and compiling Boost stub for module $*" 	&& \
  $(VERB_ECHO) python $(PYSTE_EXEC) -D_REENTRANT $($(1)_CPPFLAGS) --out=$@ --module=$* $< &&\
  python $(PYSTE_EXEC) -D_REENTRANT $($(1)_CPPFLAGS) --out=$@ --module=$* $< $(endlog_$(2))
endef  
# PyWrapper Generation
define generate_pywrapper
  @$(startlog_$(2))$(CMD_echo) "Generating wrapper code to put the following files in a single module called: $(1)" $(endlog_$(2))
  @exec 5>&1;	\
  ( $(CMD_echo) "#include <boost/python.hpp>"; echo;	\
  for c in $($(1)_classnames) ..; do		\
    case $$c in .. ) continue ;; esac ;		\
    $(CMD_echo) "  $$c" 1>&5;				\
    $(CMD_echo) "extern void init_module_$$c ();";	\
  done;						\
  echo; $(CMD_echo) "void init_module_$(1) () {";	\
  for c in $($(1)_classnames) ..; do		\
    case $$c in .. ) continue ;; esac ;		\
    $(CMD_echo) "  init_module_$$c ();";		\
  done;						\
  $(CMD_echo) "}"; echo;				\
  $(CMD_echo) "extern \"C\" void init$(1) () {";	\
  $(CMD_echo) 'boost::python::detail::init_module("$(1)",'\
	'init_module_$(1));';			\
  $(CMD_echo) "}";					\
  ) > $@.tmp
  @$(CMD_mv) $@.tmp $@
endef  
#LCG dictionary generation
define generate_lcgdict
  @$(startlog_$(2))[ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) && $(CMD_rm) -f $@ &&\
  $(CMD_echo) ">> Building LCG reflex dict from header file $4" &&\
  $(VERB_ECHO) $(GENREFLEX) $(4) -s $(3) -o $7 $($(6)_GENREFLEX_ARGS) --gccxmlopt=\"$(GENREFLEX_GCCXMLOPT)\" --gccxmlpath=$(GCCXML_BASE)/bin --capabilities=$(notdir $(5)) $(GENREFLEX_CPPFLAGS) $(call AdjustFlags,$1,LCGDICT,CPPFLAGS) &&\
               $(GENREFLEX) $(4) -s $(3) -o $7 $($(6)_GENREFLEX_ARGS) --gccxmlopt="$(GENREFLEX_GCCXMLOPT)"   --gccxmlpath=$(GCCXML_BASE)/bin --capabilities=$(notdir $(5)) $(GENREFLEX_CPPFLAGS) $(call AdjustFlags,$1,LCGDICT,CPPFLAGS) &&\
  $(CMD_touch) $@ $(endlog_$(2))
endef
# ROOt dictionary generation
define generate_rootdict
  @$(startlog_$(2))[ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Building Root dict from header file $< " &&\
  $(VERB_ECHO) $(ROOTCINT) -f $@ -c -p -DGNU_SOURCE $($(1)_CPPFLAGS) $< &&\
  ($(ROOTCINT) -f $@ -c -p -DGNU_SOURCE $(call AdjustFlags,$1,ROOTDICT,CPPFLAGS) $< || ($(CMD_rm) -f $@ && exit 1)) &&\
  $(CMD_mv) $@ $@.base	&&\
  $(CMD_cat) $< $@.base > $@ &&\
  $(CMD_rm) -f $@.base $(endlog_$(2))
endef
# CodeGen record Generation
define generate_codegen_record
  @$(startlog_$(2))$(CMD_echo) ">> Generating file $(@F) from class descriptor $<" &&\
  $(VERB_ECHO) $($(1)_CODEGENPY) $(1) $($(1)_objdir) $< &&\
  $($(1)_CODEGENPY) $(1) $($(1)_objdir) $< $(endlog_$(2))
endef
# MOC generation
define generate_moc
  @$(startlog_$(2))[ -d $(@D) ] ||  $(CMD_mkdir) -p $(@D) &&\
  $(CMD_echo) ">> Running moc ( $(3) ) for $<" &&\
  $(3) -o $@ $< $(endlog_$(2))
endef
# Flex Generaton
define generate_lex
  @$(startlog_$(2))$(CMD_echo) "Flex: Generating $@ from $<" &&\
  $(VERB_ECHO) $(LEX) -o$@ -P$(patsubst %lex,%,$*) $< &&\
  ($(LEX) -o$@ -P$(patsubst %lex,%,$*) $< || ($(CMD_rm) -f $@ && exit 1))$(endlog_$(2))
endef
define generate_parse
  @$(startlog_$(2))$(CMD_echo) "Bison: Generating $@ from $<" &&\
  $(VERB_ECHO) $(YACC) -p$(patsubst %parse,%,$*) --defines=$(basename $@).h -o$(basename $@).cc $< &&\
  ($(YACC) -p$(patsubst %parse,%,$*) --defines=$(basename $@).h -o$(basename $@).cc $< ||($(CMD_rm) -f $(basename $@).h $(basename $@).cc && exit 1)) &&\
  cd $(WORKINGDIR)/$(3) &&\
  $(CMD_rm) -f $*parse.h && $(CMD_ln) -s $(1)/$*parse.h $*parse.h $(endlog_$(2))
endef
##############################################################################
# Library linking Rules
# Shared library linking
define link_lib_common
  @$(startlog_$(2))$(CMD_echo) ">> Building $(5) $@" &&\
  $(CMD_touch) $(WORKINGDIR)/cache/prod/lib$(1) &&\
  $(VERB_ECHO)                $(CXX) $(6) $(CXXSHAREDFLAGS) $(call GetMissingSymbolFlags,$1)     $($(1)_objs) -o $@ $(MODULEFLAGS) $(if $7,$7,$(call AdjustFlags,$1,,LDFLAGS)) &&\
  (($(call checklibs,$(1)) && $(CXX) $(6) $(CXXSHAREDFLAGS) $(call GetMissingSymbolFlags,$1,yes) $($(1)_objs) -o $@ $(MODULEFLAGS) $(if $7,$7,$(call AdjustFlags,$1,,LDFLAGS))) || ($(call delete_plugin_build_prod,$(3),$(4)) && exit 1)) &&\
  if [ "X$($(1)_no_lib_copy)" = X ] ; then \
    $(call copy_lib_to_main_productstore,$(3)) ;\
  fi &&\
  $(call check_missing_symbols,$($(1)_libcheck),$(3),$(4)) $(endlog_$(2))
  @$(startlog_$(2))$(CMD_rm) -f $@.dep && $(CMD_touch) $@.dep &&\
  for dep in $(foreach d,$($(1)_objs:.$(OBJEXT)=.d),$d) ; do \
    if [ -f $$dep ] ; then $(CMD_sed) 's|$(LOCALTOP)/||' $$dep >> $@.dep ; fi ; \
  done $(endlog_$(2))
  @$(CMD_tr) ' ' '\012' <  $@.dep | $(CMD_sed) -e 's/^'\\\\'$$//' -e '/^$$/ d' \
  -e '/:$$/ d' -e 's/$$/ :/' > $@.dep.new
  @$(CMD_sort) $@.dep.new | $(CMD_uniq) >> $@.dep
  @$(CMD_rm) -f $@.dep.new
endef
define link_lib
  $(call link_lib_common,$1,$2,$3,$4,shared library,$(call AdjustFlags,$1,,CXXFLAGS))
endef  
define link_lib_edm
  $(call link_lib_common,$1,$2,$3,$4,edm plugin,$(call AdjustFlags,$1,EDM,CXXFLAGS),$(call AdjustFlags,$1,EDM,LDFLAGS))
endef
define big_obj
  @$(startlog_$(2))$(CMD_echo) ">> Building big object file $@" &&\
  $(VERB_ECHO) $(LD) $(LD_UNIT) $(LD_UNIT_FLAGS) -o $@ $3 &&\
  (            $(LD) $(LD_UNIT) $(LD_UNIT_FLAGS) -o $@ $3 || ($(call delete_build_prod,$(4)) && exit 1)) &&\
  $(call copy_bigobj_to_main_productstore,$(4)) $(endlog_$(2))
endef
define link_pylib
  @$(startlog_$(2))$(CMD_echo) ">> Building Python module $($(1)_product)" && \
  $(CMD_touch) $(WORKINGDIR)/cache/prod/lib$(1) &&\
  $(VERB_ECHO)                $(CXX) $(CXXSHAREDFLAGS) $($(1)_objs) -o $@ $(MODULEFLAGS) $($(1)_CXXSharedLink) &&\
  (($(call checklibs,$(1)) && $(CXX) $(CXXSHAREDFLAGS) $($(1)_objs) -o $@ $(MODULEFLAGS) $($(1)_CXXSharedLink)) || ($(call delete_build_prod,$(3)) && exit 1)) &&\
  $(call copy_lib_to_main_productstore,$(3)) $(endlog_$(2))
  @$(startlog_$(2))$(CMD_rm) -f $@.dep && $(CMD_touch) $@.dep &&\
  for dep in $(foreach d,$($(1)_objs:.$(OBJEXT)=.d),$d) ; do \
    if [ -f $$dep ] ; then $(CMD_sed) 's|$(LOCALTOP)/||' $$dep >> $@.dep ; fi ; \
  done $(endlog_$(2))
  @$(CMD_tr) ' ' '\012' <  $@.dep | $(CMD_sed) -e 's/^'\\\\'$$//' -e '/^$$/ d' \
  -e '/:$$/ d' -e 's/$$/ :/' > $@.dep.new 
  @$(CMD_sort) $@.dep.new | $(CMD_uniq) >> $@.dep
  @$(CMD_rm) -f $@.dep.new
endef  
#Shared Capabilities library
define link_lib_capabilities
  @$(startlog_$(2))$(CMD_echo) ">> Building capability library $@" &&\
  $(VERB_ECHO)                $(CXX) $(call AdjustFlags,$1,EDM CAPABILITIES,CXXFLAGS) $(call GetMissingSymbolFlags,$1)     $(CXXSHAREDFLAGS) $5 -o $@ $(MODULEFLAGS) $(call AdjustFlags,$(4)_CDICT,EDM LCGDICT,LDFLAGS) &&\
  (($(call checklibs,$(1)) && $(CXX) $(call AdjustFlags,$1,EDM CAPABILITIES,CXXFLAGS) $(call GetMissingSymbolFlags,$1,yes) $(CXXSHAREDFLAGS) $5 -o $@ $(MODULEFLAGS) $(call AdjustFlags,$(4)_CDICT,EDM LCGDICT,LDFLAGS)) || ($(call delete_plugin_build_prod,$(3),$(4)) && exit 1)) &&\
  if [ "X$($(4)_no_lib_copy)" = X ] ; then \
    $(call copy_lib_to_main_productstore,$(3)) ;\
  fi &&\
  $(call check_missing_symbols,$($(1)_libcheck),$(3),$(4)) &&\
  $(call check_edm_class_version,$1,$6,$3,$4) $(endlog_$(2))
endef

##############################################################################
# Binary/test building Rules
# Binary building 
define build_bin
  @$(startlog_$(2))$(CMD_echo) ">> Building binary $(1)" &&\
  $(VERB_ECHO)                $(CXX) $(call AdjustFlags,$1,$4,CXXFLAGS) $(CXXSHAREDOBJECTFLAGS) $($(1)_objs) $($(1)_LDFLAGS) -o $@ &&\
  (($(call checklibs,$(1)) && $(CXX) $(call AdjustFlags,$1,$4,CXXFLAGS) $(CXXSHAREDOBJECTFLAGS) $($(1)_objs) $($(1)_LDFLAGS) -o $@) || ($(call delete_build_prod,$(3)) && exit 1)) &&\
  $(call copy_bin_to_main_productstore,$(3)) $(endlog_$(2))
  @$(startlog_$(2))$(CMD_rm) -f $@.dep && $(CMD_touch) $@.dep &&\
  for dep in $(foreach d,$($(1)_objs:.$(OBJEXT)=.d),$d) ; do \
    if [ -f $$dep ] ; then $(CMD_sed) 's|$(LOCALTOP)/||' $$dep >> $@.dep ; fi ; \
  done $(endlog_$(2))
  @$(CMD_tr) ' ' '\012' <  $@.dep | $(CMD_sed) -e 's/^'\\\\'$$//' -e '/^$$/ d' \
  -e '/:$$/ d' -e 's/$$/ :/' > $@.dep.new 
  @$(CMD_sort) $@.dep.new | $(CMD_uniq) >> $@.dep
  @$(CMD_rm) -f $@.dep.new
endef
# Test executable building
define build_test
  $(call build_bin,$(1),$(2),$(3),$(4))
endef  
##############################################################################
# Data download and Copy
define script_copy
  @$(startlog_$(2))[ -d $(@D) ] || $(CMD_mkdir) -p $(@D) &&\
  $(CMD_rm) -rf $@ &&\
  $(CMD_cp) -rp $< $@	&&\
  $(CMD_echo) ">> Copied $(@F)" $(endlog_$(2))
endef
define generate_python_bytecode
  if [ "X$(PYTHON_COMPILE)" != X ] ; then \
    $(CMD_echo) ">> Generating python byte-code: $(1)" && \
    python $(PYTHON_COMPILE) -f $(1) >/dev/null 2>&1; \
  else \
    $(CMD_echo) "Python tool is not used. So not going to generate byte-code." ; \
  fi
endef
define python_script_copy
  @$(startlog_$(2))if [ ! -d $(LOCALTOP)/$(3) ]; then \
    $(CMD_mkdir) -p $(LOCALTOP)/$(3) &&\
    $(CMD_echo) "Creating product storage directory: $(LOCALTOP)/$(3)"; 	\
  fi &&\
  $(CMD_rm) -rf $($(1)_python_dir) && $(CMD_mkdir) -p $($(1)_python_dir) &&\
  $(CMD_echo) ">> Copying python/* to $($(1)_python_dir)" &&\
  for name in `$(CMD_ls) $($(1)_srcdir) | $(CMD_grep) -v "CVS\|BuildFile\|BuildFile.xml"` ; do \
    f=$($(1)_srcdir)/$$name &&\
    if [ -d $$f ] ; then \
      $(CMD_cp) -rp $$f $($(1)_python_dir) || continue ;\
    else  \
      [ "X`$(CMD_echo) $$f | $(CMD_grep) '\.py$$'`" != X ] || continue ; \
      $(CMD_cp) -rp $$f $($(1)_python_dir)/ || continue ;\
    fi \
  done &&\
  $(call generate_python_bytecode,$(LOCALTOP)/$($(1)_python_dir)) &&\
  for dir in `$(CMD_find) $($(1)_python_dir) -name "*" -type d` ; do \
    if [ ! -f $$dir/__init__.py ] ; then \
      $(CMD_touch) $$dir/__init__.py; \
    fi \
  done &&\
  $(CMD_touch) $($(1)_python_dir)/__init__.py &&\
  $(CMD_touch) $($(1)_python_dir)/../__init__.py $(endlog_$(2))
endef
define copy_src_scripts
  @$(startlog_$(2))$(CMD_echo) "------- copying scripts from $(1) -------" &&\
  for f in $(3); do \
    [ -f $(LOCALTOP)/$(1)/$$f ] || continue ;\
    $(CMD_echo) ">> Copying $(LOCALTOP)/$(1)/$$f"	&&\
    $(CMD_cp) -p $(LOCALTOP)/$(1)/$$f  $(LOCALTOP)/$(4) || continue ;\
  done $(endlog_$(2))
endef
define src2store_copy
  @$(startlog_$(2)) $(CMD_echo) "------- copying files from $(1) -------" &&\
  [ -d $(LOCALTOP)/$(4) ] || $(CMD_mkdir) -p $(LOCALTOP)/$(4) &&\
  for f in $(3) ; do \
    if [ -d $(LOCALTOP)/$(4)/$$f ] ; then \
      $(CMD_rm) -rf $(LOCALTOP)/$(4)/$$f; \
    fi &&\
    $(CMD_cp) -rp $(LOCALTOP)/$(1)/$$f $(LOCALTOP)/$(4)/$$f &&\
    $(CMD_echo) ">> copied $$f"; \
  done $(endlog_$(2))
endef
define copy_python_products
  @$(startlog_$(2))[ -d $(4) ] || ($(CMD_mkdir) -p $(4) && $(CMD_echo) ">> $(4) created") &&\
  $(CMD_cp) $(3) $(4) $(endlog_$(2))
endef
#############################################################################
# Tesings test executable
define run_test
  @if [ "X$($(1)_NO_TESTRUN)" == "Xyes" ] ; then \
    $(CMD_echo) "Package "$(patsubst src/%/test,%,$(4))": Skipping test $(1)"; \
  else \
    $(CMD_echo) "Package "$(patsubst src/%/test,%,$(4))": Running test $(1)" &&\
    $(CMD_rm) -f $($(1)_objdir)/testing.log; $(CMD_touch) $($(1)_objdir)/testing.log  &&\
    $(CMD_echo) " " >> $($(1)_objdir)/testing.log &&\
    $(CMD_echo) "===== Test \"$(1)\" ====" >> $($(1)_objdir)/testing.log &&\
    export PATH=$(LOCALTOP)/$(2):$(LOCALTOP)/$(4):$(PATH) && (($($(1)_TEST_RUNNER_CMD)) >> $($(1)_objdir)/testing.log 2>&1 || $(CMD_echo) "---> test $(1) had ERRORS") &&\
    $(CMD_echo) " " >> $($(1)_objdir)/testing.log &&\
    $(CMD_echo) "^^^^ End Test $(1) ^^^^" >> $($(1)_objdir)/testing.log &&\
    $(CMD_cat) $($(1)_objdir)/testing.log &&\
    $(CMD_cat) $($(1)_objdir)/testing.log >> $(LOCALTOP)/$(3)/testing.log; $(CMD_rm) -f $($(1)_objdir)/testing.log; \
  fi
endef

##############################################################################
define bf_update
  @if [ ! -f $@ ] || [ "X$($(1)_BuildFile)" = X ] ; then \
    $(CMD_touch) $@;\
  elif [ "X`$(call get_time_stamp,$@)`" != "X`$(call get_time_stamp,$($(1)_BuildFile))`" ] ; then \
      $(CMD_touch) $@;\
  fi
endef
define config_update
  @[ -d  $(@D)] || $(CMD_mkdir) -p $(@D) ; $(CMD_touch) $@ ;\
  if [ "X$($(1)_BuildFile)" != X ] ; then \
    $(CMD_touch) -r $($(1)_BuildFile) $(WORKINGDIR)/cache/bf/$(1);\
  fi
endef
define timestamp_cmp
  $(CMD_perl) -e "my @s1=stat '$1'; my @s2=stat '$2';"'print $$s1[9]<=>$$s2[9];'
endef
define get_time_stamp
  $(CMD_perl) -e 'my @d=stat "$(1)"; print "$$d[9]\n";'
endef
#############################################################################
define SubSystem
.PHONY: $(1) src/$(1) $(2) all_$(2) runtests_$(2) compile_$(2) precompile_$(2)
$(1) src/$(1) $(2) all_$(2): $(subdirs_$(2))
	@$(CMD_echo) ">> Subsystem $(1) built"
runtests_$(2): $(addprefix runtests_,$(subdirs_$(2)))
	@:
runpython_$(2): $(addprefix runpython_,$(subdirs_$(2)))
	@:
compile_$(2): $(addprefix compile_,$(subdirs_$(2)))
	@:
precompile_$(2): $(addprefix precompile_,$(subdirs_$(2)))
	@:
endef
define EmptyPackage
$(1)_libdeps      := $(prelibdeps) $(addprefix $(WORKINGDIR)/cache/prod/lib,$(sort $($(1)_EX_LIB) $($($u)_EX_UOLIB) $(foreach u,$($(1)_EX_USE),$($u))))
$(1)_CONFIGDEPS := $(CONFIGDEPS) $(sort $(foreach u,$(sort $($(1)_LOC_USE) $($(1)_EX_USE)),$($($(u))_XDEPS) $(if $($($(u))_BuildFile),$($($(u))_BuildFile),$(wildcard .SCRAM/$(SCRAM_ARCH)/timestamps/$(u)))))
ifneq ($$(strip $($(1)_BuildFile)),)
ALL_BUILDFILES += $($(1)_BuildFile)
$($(1)_BuildFile): $$($(1)_CONFIGDEPS)
	@$(CMD_touch) $($(1)_BuildFile)
endif
$(WORKINGDIR)/cache/prod/lib$(1): $($(1)_BuildFile) $$($(1)_libdeps)
	@$(CMD_touch) $$@
endef
define Package
.PHONY: $(1) src/$(1) $(2) all_$(2) runtests_$(2) msg_$(2) compile_$(2) precompile_$(2)
ifeq ($(strip $(BUILD_LOG)),yes)
logfile_$(2) := $(WORKINGDIR)/cache/log/src/$(1)/build.log
redirectlog_$(2) := >> $(WORKINGDIR)/cache/log/src/$(1)/build.log
else
logfile_$(2) := 
redirectlog_$(2) := 
endif
msg_$(2): $$(logfile_$(2))
	@$(DO_BUILD_LOG) $(CMD_echo) ">> Entering Package $(1)" $$(redirectlog_$(2)) &&\
	$(CMD_echo) ">> Entering Package $(1)"
$(1) src/$(1) $(2) all_$(2): msg_$(2) $(addprefix all_,$(subdirs_$(2)))
	$$(call outputlog,$(1),$(2))
	@$(DO_BUILD_LOG) $(CMD_echo) ">> Leaving Package $(1)"  $$(redirectlog_$(2)) &&\
	$(DO_BUILD_LOG) $(CMD_echo) ">> Package $(1) built" $$(redirectlog_$(2)) &&\
	$(DO_BUILD_LOG) $(CMD_cat) $(WORKINGDIR)/cache/log/src/$(1)/build.log &&\
	$(CMD_echo) ">> Leaving Package $(1)" &&\
	$(CMD_echo) ">> Package $(1) built"
ifeq ($$(filter $(2)_test,$(subdirs_$(2))),$(2)_test)
runtests_$(2): $(2) runtests_$(2)_test
	@$(CMD_echo) ">> Tests for package $(1) ran."
endif
precompile_$(2): $(addprefix precompile_,$(subdirs_$(2)))
	@:
compile_$(2): $(addprefix compile_,$(subdirs_$(2)))
	@:
ifeq ($$(filter $(2)_python,$(subdirs_$(2))),$(2)_python)
runpython_$(2): runpython_$(2)_python
	@$(CMD_echo) ">> Python for package $(1) ran."
endif
endef

define addPlugin
$(2)_pluginname    := $(1)
ALL_$(3)_PLUGINS   += $(1)
$(1)_plugintype    := $(3)
$(1)_no_lib_copy   := $(4)
$(1)_plugindir     := $(5)
$(1)_pluginrefresh := $(6)
$(1)_plugincache   := $(7)
$(1)_pluginprod    := $(5)/$(8)
$(1)_pluginlib     := $($(2)_objdir)/$(MODULE_PREFIX)$(1).$(SHAREDSUFFIX)
all_$(2)           += $(5)/$(8)
$(1)_extra_deps    += $(WORKINGDIR)/cache/prod/$(6) 
ifndef SCRAM_NOEDMWRITECONFIG
ifeq ($$(strip $(3)),edm)
$(1)_extra_deps    += $(WORKINGDIR)/cache/prod/$(EDM_WRITE_CONFIG)
$(1)_package       := $(patsubst $(SCRAM_SOURCEDIR)/%,%,$(patsubst self/%,%,$($(1))))
$(1)_package       := $$(if $$(strip $$(filter $$($(1)_package),$(ALL_PACKAGES))),$$($(1)_package),$$(dir  $$($(1)_package)))
endif
endif
$(5)/$(8): $$($(1)_pluginlib) $$($(1)_extra_deps)
	$$(call $(3)_register_plugin,$(1),$(9))
endef
define edmPlugin
$(eval $(call addPlugin,$1,$2,edm,yes,$3,EdmPluginRefresh,.edmplugincache,$(1).edmplugin,$1))
$(1)_BUILDRULES := _edm
endef
define rivetPlugin
$(eval $(call addPlugin,$1,$2,rivet,yes,$3,,,Rivet$(1).$(SHAREDSUFFIX),$1))
endef

define CXXCompileRule
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.$(2) $($(1)_objdir)/precompile
	$$(call compile_cxx$(4),$(1),$(3))
endef
define CCompileRule
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.$(2) $($(1)_objdir)/precompile
	$$(call compile_c$(4),$(1),$(3))
endef
define F77CompileRule
$($(1)_objdir)/%.$(OBJEXT): $($(1)_srcdir)/%.$(2) $$($(1)_objdir)/precompile
	$$(call compile_fortran$(4),$(1),$(3))
endef
define EmptyProduct
.PHONY: $(1) all_$(1) $(2) all_$(2)
$(1) $(2): all_$(1)
	@:
endef

define LogFile
startlog_$(1) = $$(FORCE_BUILD_START)
endlog_$(1)   = $$(FORCE_BUILD_END)
ifeq ($$(strip $$(BUILD_LOG)),yes)
redirectlog_$(1) := >> $(WORKINGDIR)/cache/log/$(2)/$(1)
startlog_$(1) += (
endlog_$(1)   += ) $$(redirectlog_$(1)) 2>&1
logfile_$(1)  := $(WORKINGDIR)/cache/log/$(2)/$(1)
else
logfile_$(1)     := 
redirectlog_$(1) := 
endif
endef

#safename,path,safepath,scriptstore,scripts,binstore
define CommonBinaryHead
$(3)          += all_$(1)
$(eval $(call LogFile,$(1),$(2)))
.PHONY: $(1) all_$(1)
$(1)_objdir := $(WORKINGDIR)/$(2)/$(1)
$(1)_srcdir       := $(LOCALTOP)/$(2)
$(1)_libdeps      := $(prelibdeps) $(addprefix $(WORKINGDIR)/cache/prod/lib,$(sort $($(1)_LOC_LIB) $(foreach u,$($(1)_LOC_USE) $($(1)_EX_USE),$($u) $($($u)_EX_LIB) $($($u)_EX_UOLIB))))
$(1)_files        := $$(filter-out $($(1)_SKIP_FILES), $$($(1)_files))
$(1)_objs         := $$(addprefix $$($(1)_objdir)/, $$(addsuffix .$(OBJEXT), $$(basename $$($(1)_files))))
ifneq ($(strip $(5)),)
.PHONE: $(1)_install_scripts_rule
$(1)_install_scripts_rule: $(logfile_$(1))
	$$(call copy_src_scripts,$(2),$(1),$(5),$(4))
all_$(1) += $(1)_install_scripts_rule
endif
$(1)_CONFIGDEPS := $(CONFIGDEPS) $(WORKINGDIR)/$(2)/productautocleanup $(sort $(foreach u,$(sort $($(1)_LOC_USE) $($(1)_EX_USE)),$($($(u))_XDEPS) $(if $($($(u))_BuildFile),$($($(u))_BuildFile),$(wildcard .SCRAM/$(SCRAM_ARCH)/timestamps/$(u)))))
ifneq ($$(strip $($(1)_BuildFile)),)
ifeq ($(filter $($(1)_BuildFile),$(ALL_BUILDFILES)),)
ALL_BUILDFILES += $($(1)_BuildFile)
$($(1)_BuildFile): $$($(1)_CONFIGDEPS)
	@$(CMD_touch) $($(1)_BuildFile)
endif
$$($(1)_objdir)/config: $($(1)_BuildFile)
	@$$(call BuildClean,$(2)/$(1),0[0-9],1); $(CMD_mkdir) -p $$(@D) ; $(CMD_touch) $$@
else
$$($(1)_objdir)/config: $$($(1)_CONFIGDEPS)
	@$$(call BuildClean,$(2)/$(1),0[0-9],1); $(CMD_mkdir) -p $$(@D) ; $(CMD_touch) $$@
endif
$(1)_config += $$($(1)_objdir)/config $(logfile_$(1))
endef

#safename,path,productstore,type,logprodstore,safepath
define CommonBinaryTail
$(eval $($(1)_PRE_INIT_FUNC))
ifneq ($$(strip $($(1)_objs)),)
ALL_$(4)_PRODUCTS += $(1)
$(1):  $($(1)_objdir)/$($(1)_product)
$($(1)_objdir)/$($(1)_product): $($(1)_objdir)/compile $($(1)_libdeps)
ifeq ($(strip $(4)),lib)
	$$(call link_lib$($(1)_BUILDRULES),$(1),$(1),$(3),$($(1)_pluginname))
	@$$(startlog_$(1))$(CMD_echo) "Leaving library rule at $(patsubst src/%/src,%,$(2))" $(endlog_$(1))
$$(eval $$(call BigObject,$1,$1,$($(1)_objs)))
endif
ifeq ($(strip $(4)),bin)
	$$(call build_bin,$(1),$(1),$(3),BIN)
endif
ifeq ($(strip $(4)),python)
	$$(call link_pylib,$(1),$(1),$(3))
endif
ifeq ($(strip $(4)),test)
	$$(call build_test,$(1),$(1),$(3),TEST)
.PHONE: runtests_$(1)
ifeq ($$(strip $$(filter $(1),$(SKIP_UNITTESTS))),$(1))
$(1)_NO_TESTRUN := yes
endif
runtests_$(6) += runtests_$(1)
runtests_$(1): all_$(1) $(LOCALTOP)/$(5)/testing.log
	$$(call run_test,$(1),$(3),$(5),$(2))
endif
$(WORKINGDIR)/cache/prod/$(1): $($(1)_objdir)/$($(1)_product)
	@if [ ! -f $$@ ] ; then $(CMD_touch) $$@; fi
ifneq ($$(strip $($(1)_product)),)
ifneq ($(wildcard $($(1)_objdir)/$($(1)_product).dep),)
-include $($(1)_objdir)/$($(1)_product).dep
endif
endif
precompile_$(6):: $($(1)_objdir)/precompile
	@:
compile_$(6):: $($(1)_objdir)/compile
	@:
$($(1)_objdir)/precompile: $($(1)_config) $($(1)_precompile) $(logfile_$(1))
	@$(CMD_touch) $$@
ifeq ($$(strip $(4)),lib)
	@$(startlog_$(1))$(CMD_echo) "Entering library rule at $(patsubst src/%/src,%,$(2))" $(endlog_$(1))
endif
$($(1)_objdir)/compile: $($(1)_objdir)/precompile $($(1)_objs) $($(1)_compile)
	@$(CMD_touch) $$@
$($(1)_objdir)/link: $($(1)_objdir)/compile $($(1)_objdir)/$($(1)_product) $($(1)_link)
	@$(CMD_touch) $$@
all_$(1): $($(1)_objdir)/link $$(all_$(1))
	@:
endif
endef

define BigObject
ifeq ($(strip $(BIGOBJS)),yes)
$(2)_objprefix := $(if $(strip $(filter edmX,$($(2)_plugintype)X)),plugin,lib)
all_$(1) += $($(1)_objdir)/$$($(2)_objprefix)$(2).$(BIGLIB_OBJEXT)
ALL_BIGOBJS += $($(1)_objdir)/$$($(2)_objprefix)$(2).$(BIGLIB_OBJEXT)
$($(1)_objdir)/$$($(2)_objprefix)$(2).$(BIGLIB_OBJEXT): $(3)
	$$(call big_obj,$(2),$(1),$(3),$(SCRAMSTORENAME_OBJS))
endif
endef

define FindBuildFile
$(if $(wildcard $(1).xml),$(1).xml,$(1))
endef

define MultipleWarningMsg
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(call $$(multipletools),****WARNING: Multiple products with same name $(1))
$$(call $$(multipletools),             Previous defination: $($(1)))
$$(call $$(multipletools),             Current  defination: $(2))
endif
endef

define ProductWithNoFiles
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(info ****WARNING: Skipped building of $(1) from $$(call FindBuildFile,$(2)/$(SCRAM_BUILDFILE)) because)
ifeq ($(strip $(3)),)
$$(info $$(space)             there are no files mentioned in the this Buildfile)
else
$$(info $$(space)             \"$(3)\" does not match any file under $(2) directory)
endif
endif
endef

define UseError
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(call $$(wrongtool),****WARNING: Invalid tool $(1). Please fix $$(call FindBuildFile,$$(subst tmp/$(SCRAM_ARCH)/cache/bf/,,$2)) file.)
endif
endef

#safename,path,safepath,scriptstore,scripts,productstore,fileext,type,logprodstore
define Binary
$(eval $(call CommonBinaryHead,$(1),$(2),$(3),$(4),$(5)))
ALL_BINARIES += $(1)
$(1)_product := $(1)
$$(eval $$(call CommonBinaryTail,$(1),$(2),$(6),$(8),$(9),$(3)))
$(foreach ext,$(filter $(CXXSRC_FILES_SUFFIXES),$(7)),$(eval $(call CXXCompileRule,$(1),$(ext),$(1))))
$(foreach ext,$(filter $(CSRC_FILES_SUFFIXES),$(7)),$(eval $(call CCompileRule,$(1),$(ext),$(1))))
endef

#safename,path,safepath,scriptstore,scripts,libstore,fileext,logprodstore
define Library
$(eval $(call LibraryHead,$(1),$(2),$(3),$(4),$(5)))
$(eval $(call LibraryTail,$(1),$(2),$(6),$(7),$(8),$(3)))
endef

#safename,path,safepath,scriptstore,scripts
define LibraryHead
$(eval $(call CommonBinaryHead,$(1),$(2),$(3),$(4),$(5)))
$(1)_product      := $(MODULE_PREFIX)$(1).$(SHAREDSUFFIX)
endef

#safename,path,libstore,fileext,logprodstore,safepath
define LibraryTail
$(eval $(call CommonBinaryTail,$(1),$(2),$(3),lib,$(5),$(6)))
ifneq ($$(strip $$($(1)_objs)),)
ALL_LIBRARIES += $(1)
$(WORKINGDIR)/cache/prod/lib$(1): $($(1)_objdir)/$($(1)_product)
	@:
$(foreach ext,$(filter $(CXXSRC_FILES_SUFFIXES),$(4)),    $(eval $(call CXXCompileRule,$(1),$(ext),$(1),$($(1)_BUILDRULES))))
$(foreach ext,$(filter $(CSRC_FILES_SUFFIXES),$(4)),      $(eval $(call CCompileRule,$(1),$(ext),$(1),$($(1)_BUILDRULES))))
$(foreach ext,$(filter $(FORTRANSRC_FILES_SUFFIXES),$(4)),$(eval $(call F77CompileRule,$(1),$(ext),$(1))))
else
$(1) all_$(1): $$(all_$(1))
	@:
endif
endef

define AddExtraPythonProdRule
$(if $(2),$(eval $(call ExtraPythonProd,$(1),$(firstword $(2)),$(firstword $(3))))$(eval $(call AddExtraPythonProdRule,$(1),$(wordlist 2,100,$(2)),$(wordlist 2,100,$(3)))),)
endef

define ExtraPythonProd
all_$(1)_extra_python_prod += $(3)/$(2)
$(3)/$(2): $(2) $(1)_copy_python_scripts $($(1)_CONFIGDEPS)
	@$(CMD_echo) ">> Copying python products \"$(2)\" => $(3)"
	$$(call copy_python_products,$(1),$(logfile_$(1)),$(2),$(3))
endef

#safename,path,safepath,hasscripts,symlinkpython,pythonstore,xprodfiles,xproddirs
define PythonProductHead
$(3)          += all_$(1)
.PHONY: $(1) all_$(1) $(1)_copy_python_scripts
$(eval $(call LogFile,$(1),$(2)))
$(1)_objdir       := $(WORKINGDIR)/$(2)/$(1)
$(1)_python_dir := $(addprefix $(6)/,$(patsubst $(SCRAM_SOURCEDIR)/%/python,%,$(2)))
$(1)_CONFIGDEPS := $(CONFIGDEPS) $(sort $(foreach u,$(sort $($(1)_LOC_USE) $($(1)_EX_USE)),$($($(u))_XDEPS) $(if $($($(u))_BuildFile),$($($(u))_BuildFile),$(wildcard .SCRAM/$(SCRAM_ARCH)/timestamps/$(u)))))
ifneq ($$(strip $($(1)_BuildFile)),)
ALL_BUILDFILES += $($(1)_BuildFile)
$($(1)_BuildFile): $$($(1)_CONFIGDEPS)
	@$(CMD_touch) $($(1)_BuildFile)
$$($(1)_objdir)/config: $($(1)_BuildFile)
	@$$(call BuildClean,$(2)/$(1),0[0-9],1); $(CMD_mkdir) -p $$(@D) ; $(CMD_touch) $$@
else
$$($(1)_objdir)/config: $$($(1)_CONFIGDEPS)
	@$$(call BuildClean,$(2)/$(1),0[0-9],1); $(CMD_mkdir) -p $$(@D) ; $(CMD_touch) $$@
endif
$(1)_config += $$($(1)_objdir)/config
all_$(1) += $(1)_copy_python_scripts
ifeq ($(strip $(4)),1)
ifeq ($$(strip $(5)),1)
ifeq ($$(strip $(COMPILE_PYTHON_SCRIPTS)),yes)
$$($(1)_objdir)/cmssw_python_modules: FORCE_TARGET $(logfile_$(1)) $(COMMON_WORKINGDIR)/cache/python_symlinks
	$$(call compile_python,$1,$1,$(subst /,.,$(patsubst $(SCRAM_SOURCEDIR)/%/python,%,$(2))),$(2))
	$$(call outputLogFile,$(logfile_$(1)))
ALL_PYTHON_COMPILE += $$($(1)_objdir)/cmssw_python_modules
endif
$(1)_copy_python_scripts: $(logfile_$(1)) $(COMMON_WORKINGDIR)/cache/python_symlinks
	@:
else
$(1)_copy_python_scripts: $(logfile_$(1))
	$$(call python_script_copy,$(1),$(logfile_$(1)),$(6))
endif
else
$(1)_copy_python_scripts: $(logfile_$(1))
	@$(CMD_echo) "No source files to compile. Nothing to be done for Python modules at $(2)."
endif
runpython_$(3): $(1)_copy_python_scripts
	@:
ifneq ($(strip $(7)),)
.PHONY: $(1)_extra_python_prod
all_$(1) += $(all_$(1)_extra_python_prod)
$(eval $(call AddExtraPythonProdRule,$(1),$(7),$(8)))
all_$(1) += $(all_$(1)_extra_python_prod)
endif
$(1)_srcdir       := $(LOCALTOP)/$(2)
$(1)_files        := $$(notdir $$(wildcard $$(foreach dir,$$($(1)_srcdir),$$(foreach ext,$(CXXSRC_FILES_SUFFIXES),$$(dir)/*.$$(ext)))))
$(1)_files        += $$(patsubst %.pyste,%_boost.cc,$$(notdir $$(wildcard $$($(1)_srcdir)/*.pyste)))
$(1)_files        := $$(filter-out $($(1)_SKIP_FILES),$$($(1)_files))
endef

define PythonProductFlags
$(1)_files        += $($(1)_objdir)/$(1)_PyWrapper.cc
$(1)_objs         := $$(addprefix $($(1)_objdir)/, $$(addsuffix .$(OBJEXT), $$(basename $$(notdir $$($(1)_files)))))
$(1)_PY_CXXFLAGS   = $$(filter-out -pedantic-errors -ansi, $$($(1)_CXXFLAGS))
$(1)_libdeps      := $(prelibdeps) $(addprefix $(WORKINGDIR)/cache/prod/lib,$(sort $($(1)_LOC_LIB) $(foreach u,$($(1)_LOC_USE),$($u) $($($u)_EX_LIB) $($($u)_EX_UOLIB))))
$(1)_objs         := $$(addprefix $($(1)_objdir)/, $$(addsuffix .$(OBJEXT), $$(basename $$(notdir $$($(1)_files)))))
$(1)_classnames   := $$(patsubst %_boost,%,$$(filter %_boost,$$(basename $$(notdir $$($(1)_files)))))
$(1)_CXXSharedLink = -rdynamic $$($(1)_LDFLAGS)
endef

#safename,path,productstore,logprodstore,safepath
define PythonProductTail
$(1)_product := $(1).$(SHAREDSUFFIX)
$$(eval $$(call CommonBinaryTail,$(1),$(2),$(3),python,$(4),$(5)))
$(foreach ext,$(CXXSRC_FILES_SUFFIXES),$(eval $(call CXXCompileRule,$(1),$(ext),$(1))))
.PRECIOUS: $($(1)_objdir)/%_boost.cc
$($(1)_objdir)/%_boost.cc: $($(1)_srcdir)/%.pyste $($(1)_config)
	$$(call pyste2boost,$(1),$(1))
$($(1)_objdir)/%_boost.o: $($(1)_srcdir)/%_boost.cc $($(1)_config)
	$$(call compile_boost,$(1),$(1))
$($(1)_objdir)/%_boost.o: $($(1)_objdir)/%_boost.cc
	$$(call compile_boost,$(1),$(1))
$($(1)_objdir)/$(1)_PyWrapper.o: $($(1)_objdir)/$(1)_PyWrapper.cc
	$$(call compile_pywrapper,$(1),$(1))
$($(1)_objdir)/$(1)_PyWrapper.cc: $($(1)_config)
	$$(call generate_pywrapper,$(1),$(1))
endef

#safename,path,safepath,hasscripts,symlinkpython,pythonstore,libstore,xprodfiles,xproddirs,logprodstore
define PythonProduct
$(eval $(call PythonProductHead,$(1),$(2),$(3),$(4),$(5),$(6),$(8),$(9)))
ifneq ($$(strip $$($(1)_files)),)
ifneq ($$(strip $$($(1)_BuildFile)),)
ifneq ($$(strip $$(filter boost_python,$($(1)_LOC_USE))),)
$$(eval $$(call PythonProductFlags,$(1)))
$$(eval $$(call PythonProductTail,$(1),$(2),$(7),$(10),$(3)))
else
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(info ****WARNING: Skipped building product $(1).$(SHAREDSUFFIX) due to missing boost_python tool selecting in $(2)/$(SCRAM_BUILDFILE))
endif
endif
else
ifeq ($(strip $(ONLYECHOTARGETS)),)
$$(info ****WARNING: Skipped building product $(1).$(SHAREDSUFFIX) due to missing $(2)/$(SCRAM_BUILDFILE))
endif
endif
endif
ifeq ($$(strip $$($(1)_product)),)
$(1) all_$(1): $(all_$(1))
	@:
endif
endef

define Src2StoreCopy
.PHONY: $(1) all_$(1)
$(1)_files := $(filter-out CVS $(SCRAM_BUILDFILE) $(SCRAM_BUILDFILE).xml $($(1)_SKIP_FILES), $($(1)_files))
$(1): all_$(1)
	@:
ifneq ($$(strip $$($(1)_files)),)
$(eval $(call LogFile,$(1),$(2)))
$(1)_installdir := $(3)
all_$(1): $(logfile_$(1))
	@$$(call clean_files,$($(1)_SKIP_FILES),$$($(1)_installdir))
	$$(call src2store_copy,$(2),$(1),$$($(1)_files),$$($(1)_installdir))
endif
endef

define CommonDataRules
.PHONY: $(1) all_$(1)
$(1) all_$(1): $($(1)_data_copy_rule)
endef

define CommonProductRules
.PHONY: $(1) all_$(1)
ifeq ($(strip $(3)),TEST)
.PHONY: runtests_$(1)
$(1) += $($(1)_data_copy_rule)
runtests_$(1): $(1) $(runtests_$(1))
	@:
endif
$(1) all_$(1): $($(1))
	@:
endef

define AddMOC
$(1)_LOC_FLAGS_CPPFLAGS     += -I$($(1)_objdir)/moc
$(1)_FILE_MOC	  := $(foreach suffix,h cc cpp cxx,$(patsubst %.$(suffix),%_$(suffix)_moc.cc,$(filter %.$(suffix),$(2))))
$(1)_FILE_MOC_SRC := $$(filter %_cc_moc.cc %_cpp_moc.cc %_cxx_moc.cc, $$($(1)_FILE_MOC))
$(1)_FILE_MOC_INC := $(filter-out $$($(1)_FILE_MOC_SRC),$$($(1)_FILE_MOC))
$(1)_files        += $$($(1)_FILE_MOC_INC)
$(1)_objs         += $$(addprefix $($(1)_objdir)/moc/, $$(addsuffix .$(OBJEXT), $$(basename $$(notdir $$($(1)_FILE_MOC_INC)))))
$(1)_precompile   += $($(1)_objdir)/moc/run_moc
$($(1)_objdir)/moc/run_moc: $$(addprefix $($(1)_objdir)/moc/, $$($(1)_FILE_MOC))
	@[ -f $$@ ] || $(CMD_touch) $$@
$($(1)_objdir)/moc/%.$(OBJEXT):  $($(1)_objdir)/moc/%.cc
	$$(call compile_cxx,$(1),$(1))
$($(1)_objdir)/moc/%_h_moc.cc:   $(3)/%.h   $($(1)_config)
	$$(call generate_moc,$(1),$(1),$($(5))/bin/moc)
$($(1)_objdir)/moc/%_h_moc.cc:   $(4)/%.h   $($(1)_config)
	$$(call generate_moc,$(1),$(1),$($(5))/bin/moc)
$($(1)_objdir)/moc/%_cc_moc.cc:  $(4)/%.cc  $($(1)_config)
	$$(call generate_moc,$(1),$(1),$($(5))/bin/moc)
$($(1)_objdir)/moc/%_cpp_moc.cc: $(4)/%.cpp $($(1)_config)
	$$(call generate_moc,$(1),$(1),$($(5))/bin/moc)
$($(1)_objdir)/moc/%_cxx_moc.cc: $(4)/%.cxx $($(1)_config)
	$$(call generate_moc,$(1),$(1),$($(5))/bin/moc)
endef

#safename,path,*LinkDef.h files
define RootDict
$(1)_LinkDef_files          := $(addprefix $($(1)_objdir)/,$(patsubst %.h,%.cc,$(3)))
$(1)_LOC_FLAGS_CPPFLAGS     += -I$(LOCALTOP)/$(2)
$(1)_files                  += $$($(1)_LinkDef_files)
$(1)_objs                   += $(addprefix $($(1)_objdir)/,$(patsubst %.h,%.$(OBJEXT),$(3)))
.PRECIOUS: $$($(1)_LinkDef_files)
$(1)_precompile += $$($(1)_LinkDef_files)
$($(1)_objdir)/%.cc: $($(1)_srcdir)/%.h $($(1)_config)
	$$(call generate_rootdict,$(1),$(1))
$($(1)_objdir)/%.$(OBJEXT): $($(1)_objdir)/%.cc
	$$(call compile_rootdict,$(1),$(1))
ifneq ($$(wildcard $($(1)_objdir)/*LinkDef.cc.d),)
-include $$(wildcard $($(1)_objdir)/*LinkDef.cc.d)
endif
endef


#safename,prodpath
define RootMap
$($(1)_objdir)/$(1).rootmap: $($(1)_objdir)/$(MODULE_PREFIX)$(1).$(SHAREDSUFFIX)
	@$(startlog_$(1))$(CMD_echo) ">> Generating RootMap file: $$(@F)" &&\
	cd $$(<D); genmap -i $$(<F) -o $$(@F) $(endlog_$(1))
$(2)/$(1).rootmap: $($(1)_objdir)/$(1).rootmap
	@$(CMD_echo) "01:$(CMD_rm) -f $$@" > $$(call AutoCleanFile,$$<,prod)
	@$(CMD_cp) $$< $$@
all_$(1) += $(2)/$(1).rootmap
endef

#safename,libname,prodpath
define LcgDictRootMap
$(2)_GENREFLEX_ARGS += --rootmap=$(2).rootmap --rootmap-lib=$(MODULE_PREFIX)$(2).$(SHAREDSUFFIX)
$($(1)_objdir)/$(2).rootmap: $($(1)_objdir)/$(MODULE_PREFIX)$(2).$(SHAREDSUFFIX)
	@$(CMD_touch) $$@
$(3)/$(2).rootmap: $($(1)_objdir)/$(2).rootmap
	@$(CMD_echo) "01:$(CMD_rm) -f $$@" > $$(call AutoCleanFile,$$<,prod)
	@$(CMD_cp) $$< $$@
all_$(1) += $(3)/$(2).rootmap
endef

#safename,rootmap,headers,hfiles,defxmlfiles,prodstore,genreflexargs,Cababilities
define LCGDict
$(1)$(8)_GENREFLEX_ARGS := $(7)
$(eval $(call AddLCGDictRule,$(1),$(4),$(5),$(1)$(8),a/))
ifeq ($(strip $(2)),1)
$$(eval $$(call LcgDictRootMap,$1,$(1)$(8),$6))
endif
ifneq ($(strip $8),)
$(1)$(8)_CDICT_LDFLAGS   = $$($(1)_LDFLAGS) -l$(1)
all_$(1)       += $($(1)_objdir)/$(MODULE_PREFIX)$(1)$(8).$(SHAREDSUFFIX)
ALL_CLASS_VERSION_RULES += $($(1)_objdir)/updateclassversion
ifneq ($(strip $(UPDATE_CLASSVERSION)),)
all_$(1)       += $($(1)_objdir)/updateclassversion
$($(1)_objdir)/updateclassversion: $($(1)_objdir)/$(MODULE_PREFIX)$(1)$(8).$(SHAREDSUFFIX)
	@$(CMD_touch) $$@
endif
$($(1)_objdir)/$(MODULE_PREFIX)$(1)$(8).$(SHAREDSUFFIX): $$($(1)$(8)_ids) $(WORKINGDIR)/cache/prod/lib$(1)
	$$(call link_lib_capabilities,$(1),$(1),$(6),$(1)$(8),$$($(1)$(8)_ids),$(5))
$$(eval $$(call BigObject,$(1),$(1)$(8),$$($(1)$(8)_ids)))
endif
endef

define AddLCGDictRule
$(if $(2),$(eval rflx_name:=$(rflx_name)x)$(eval $(call LCGDictRule,$(1),$(5)$(rflx_name),$(firstword $(2)),$(firstword $(3)),$(4)))$(eval $$(call AddLCGDictRule,$(1),$(wordlist 2,100,$(2)),$(wordlist 2,100,$(3)),$(4),$(5)))$(eval rflx_name:=),)
endef

define LCGDictRule
$(1)_files  += $($(1)_objdir)/$(2)r.cc
$(1)_objs   += $($(1)_objdir)/$(2)r.$(OBJEXT)
$(1)_precompile += $($(1)_objdir)/$(2)r.cc
$($(1)_objdir)/$(2)lcgdict: $(4) $(3) $($(1)_config)
	$$(call generate_lcgdict,$(1),$(1),$(4),$(3),$(2)i.cc,$(5),$($(1)_objdir)/$(2)r.cc)
$($(1)_objdir)/$(2)r.cc: $($(1)_objdir)/$(2)lcgdict
	@[ -f $$< ] || $(CMD_rm) -f $$@
$($(1)_objdir)/$(2)r.$(OBJEXT): $($(1)_objdir)/$(2)r.cc
	$$(call compile_lcgdict,$(1),$(1),$(2)r)
ifneq ($1,$5)
$(1)_precompile += $($(1)_objdir)/$(2)i.cc
$(5)_ids    += $($(1)_objdir)/$(2)i.$(OBJEXT)
$($(1)_objdir)/$(2)i.cc: $($(1)_objdir)/$(2)lcgdict
	@[ -f $$< ] || $(CMD_rm) -f $$@
$($(1)_objdir)/$(2)i.$(OBJEXT): $($(1)_objdir)/$(2)i.cc
	$$(call compile_cxx_capabilities,$(1),$(1))
ifneq ($$(wildcard $($(1)_objdir)/$(2)r.cc.d),)
-include $($(1)_objdir)/$(2)r.cc.d
endif
endif
endef

#safename,path,lexyacc,parseyacc,
define LexYACC
$(1)_lex_files     :=  $(3)
$(1)_yacc_files    :=  $(4)
$(1)_generated_hdr := $$(addprefix $($(1)_objdir)/, $$(addsuffix .h,  $$(basename $$(notdir $$($(1)_yacc_files)))))
$(1)_generated_src := $$(addprefix $($(1)_objdir)/, $$(addsuffix .cc, $$(basename $$(notdir $$($(1)_lex_files)))))
$(1)_generated_src += $$(addprefix $($(1)_objdir)/, $$(addsuffix .cc, $$(basename $$(notdir $$($(1)_yacc_files)))))
ifneq ($$(strip $$($(1)_generated_src)),)
$(1)_LOC_FLAGS_CPPFLAGS  += -I$(LOCALTOP)/$(WORKINGDIR)/src
endif
$(1)_objs          += $$(patsubst %.cc,%.$(OBJEXT),$$($(1)_generated_src))
$(1)_precompile    += $$($(1)_generated_src) $$($(1)_generated_hdr)
.PRECIOUS: $$($(1)_generated_src) $$($(1)_generated_hdr)
$($(1)_objdir)/%lex.cc: $($(1)_srcdir)/%lex.l $($(1)_config)
	$$(call generate_lex,$(1),$(1))
$($(1)_objdir)/%parse.cc $($(1)_objdir)/%parse.h: $($(1)_srcdir)/%parse.y $($(1)_config)
	$$(call generate_parse,$(1),$(1),$(2))
$($(1)_objdir)/%.$(OBJEXT): $($(1)_objdir)/%.cc $($(1)_objdir)/precompile
	$$(call compile_cxx,$(1),$(1))
endef

#safename,path,CODEGENPATH
define CodeGen
$(1)_CODEGENPY            := python $(3)/bin/codegen.py
$(1)_CODEGENTEMPLATES     := $(3)/templates
$(1)_codegen_object_names := $(foreach file,$(wildcard $(foreach dir,$($(1)_srcdir),$(dir)/*.desc.xml)),$(notdir $(patsubst %.desc.xml,%,$(file))))
$(1)_codegen_src := $$(addprefix $($(1)_objdir)/,$(foreach objname,$$($(1)_codegen_object_names), \
			$$(foreach suffix,.cpp .reg.cpp _T_Context.cpp,$$(objname)$$(suffix))))
$(1)_codegen_hdr := $$(addprefix $($(1)_objdir)/, $$(foreach objname,$$($(1)_codegen_object_names), \
			$$(foreach suffix,.h Record.h,$$(objname)$$(suffix))))
$(1)_codegen_rtvr_src :=$(addprefix $($(1)_objdir)/,$(1)Retriever.cpp)
$(1)_codegen_rtvr_hdr :=$(addprefix $($(1)_objdir)/,$(1)Retriever.h)
ifneq ($$(strip $$($(1)_codegen_src)),)
$(1)_LOC_FLAGS_CPPFLAGS  += -I$(LOCALTOP)/$(WORKINGDIR)/src
endif
ifneq ($$(strip $$($(1)_codegen_rtvr_src)),)
$(1)_LOC_FLAGS_CPPFLAGS  += -I$(LOCALTOP)/$(WORKINGDIR)/src
endif
$(1)_objs       += $$(patsubst %.cpp, %.$(OBJEXT), $$($(1)_codegen_src))
$(1)_objs       += $$(patsubst %.cpp, %.$(OBJEXT), $$($(1)_codegen_rtvr_src))
$(1)_precompile += $$($(1)_codegen_src) $$($(1)_codegen_hdr)
$(1)_precompile += $$($(1)_codegen_rtvr_src) $$($(1)_codegen_rtvr_hdr)
.PRECIOUS: $$($(1)_codegen_src) $$($(1)_codegen_hdr)
$($(1)_objdir)/%.h $($(1)_objdir)/%Record.h $($(1)_objdir)/%.cpp $($(1)_objdir)/%.reg.cpp $($(1)_objdir)/%_T_Context.cpp: $($(1)_srcdir)/%.desc.xml $($(1)_config)
	$$(call generate_codegen_record,$(1),$(1))
$($(1)_objdir)/$(1)Retriever.$(OBJEXT): $($(1)_objdir)/$(1)Retriever.cpp
	$$(call compile_cxx,$(1),$(1))
$($(1)_objdir)/$(1)Retriever.cpp $($(1)_objdir)/$(1)Retriever.h: $$($(1)_codegen_hdr)
	@:
$($(1)_objdir)/%.reg.$(OBJEXT): $($(1)_objdir)/%.reg.cpp $($(1)_objdir)/precompile
	$$(call compile_cxx,$(1),$(1))
$($(1)_objdir)/%_T_Context.$(OBJEXT): $($(1)_objdir)/%_T_Context.cpp $($(1)_objdir)/precompile
	$$(call compile_cxx,$(1),$(1))
$($(1)_objdir)/%.$(OBJEXT): $($(1)_objdir)/%.cpp $($(1)_objdir)/precompile
	$$(call compile_cxx,$(1),$(1))
endef
##############################################################################
define SetTargetType
ifneq ($(strip $(filter bigobj,$(MAKECMDGOALS))),)
  BIGOBJS:=yes
endif
ifneq ($(strip $(filter updateclassversion,$(MAKECMDGOALS))),)
  UPDATE_CLASSVERSION:=yes
endif
ifeq ($(strip $(MAKECMDGOALS)),outputlog)
  FAST :=yes
  XFAST:=yes
  UFAST:=yes
endif
ifeq ($(strip $(MAKECMDGOALS)),clean)
  ONLYECHOTARGETS:=yes
  FAST :=yes
  XFAST:=yes
  UFAST:=yes
else
ifeq ($(strip $(filter-out productmap gindices skiptest_% echo_% clean_% fast xfast ufast bigobj outputlog updateclassversion,$(MAKECMDGOALS))),)
  ONLYECHOTARGETS:=yes
  ifneq ($(strip $(filter ufast,$(MAKECMDGOALS))),)
    FAST :=yes
    XFAST:=yes
    UFAST:=yes
  else
    ifneq ($(strip $(filter xfast,$(MAKECMDGOALS))),)
      FAST :=yes
      XFAST:=yes
    else
      ifneq ($(strip $(filter fast,$(MAKECMDGOALS))),)
        FAST :=yes
      endif
    endif
  endif
endif
endif
endef
define UpdateMakeGoalTypes
$(if $(strip $(MAKECMDGOALS)),$(eval $(call SetTargetType)),)
endef
define GetEchoVariable
$(if $(strip $(filter echo_%,$(1))),$(patsubst echo_%,%,$(1)),)
endef
$(eval $(call UpdateMakeGoalTypes))
##############################################################################
.PHONY: FORCE_TARGET ToolUpdated_% ToolUpdated ExternalLinks Non-xml\ BuildFile\ check
Non-xml\ BuildFile\ check:
	@if [ "X$(NON_XML_BUILDFILE)" != "X" ] ; then \
	  echo "****ERROR: Non-XML BuildFiles found. Please convert these to xml format using 'scram build -c'";\
          $(foreach bf,$(NON_XML_BUILDFILE),echo "          => $(bf)";) \
	  [ "X$(RELEASETOP)" = "X" ] || exit 1 ;\
	fi
FORCE_TARGET:  Non-xml\ BuildFile\ check
	@:
$(WORKINGDIR)/cache/prod/%:
	@$(CMD_touch) $@
$(LOCALTOP)/$(SCRAMSTORENAME_LOGS)/testing.log: FORCE_TARGET
	@$(CMD_mkdir) -p $(@D) ;\
	$(CMD_rm) -rf $@; \
	$(CMD_echo) "Creating test log file $(SCRAMSTORENAME_LOGS)/testing.log" ;\
	$(CMD_touch) $@
$(WORKINGDIR)/cache/log/%: FORCE_TARGET
	@if [ -f $@ ] ; then  \
	  $(CMD_rm) -f $@ ;\
	else \
	  [ -d $(@D) ] || $(CMD_mkdir) -p $(@D) ;\
	fi
	@$(CMD_touch) -t $(OLD_TIMESTAMP) $@
ToolUpdated_%: ToolUpdated
ExternalLinks ToolUpdated:
	@$(LOCALTOP)/$(SCRAM_CONFIGDIR)/SCRAM/linkexternal.pl --arch $(SCRAM_ARCH)
$(WORKINGDIR)/cache/xlibs: $(WORKINGDIR)/cache/xlibs.backup
	@$(CMD_touch) -t $(OLD_TIMESTAMP) $@
$(WORKINGDIR)/cache/xlibs.backup: $(LOCALTOP)/external/$(SCRAM_ARCH)/links.DB 
	@$(CMD_touch) $@
$(LOCALTOP)/external/$(SCRAM_ARCH)/links.DB: $(ToolTimeStamps) $(LOCALTOP)/external/$(SCRAM_ARCH)
	@$(LOCALTOP)/$(SCRAM_CONFIGDIR)/SCRAM/linkexternal.pl --arch $(SCRAM_ARCH)
$(LOCALTOP)/external/$(SCRAM_ARCH): FORCE_TARGET
	@[ -d $@ ] || $(CMD_mkdir) -p $@
######################################################################
$(eval curtop:=$(shell $(CMD_echo) $$LOCALTOP))
ifneq ($(curtop),$(SCRAM_INIT_LOCALTOP))
  PROJECT_RENAME_TARGET:=
  ifeq ($(strip $(MAKECMDGOALS)),ProjectRename)
    PROJECT_RENAME_TARGET:=yes
  else
    ifeq ($(strip $(MAKECMDGOALS)),projectrename)
      PROJECT_RENAME_TARGET:=yes
    else
      ifeq ($(strip $(MAKECMDGOALS)),PROJECTRENAME)
        PROJECT_RENAME_TARGET:=yes
      endif
    endif
  endif
  ifneq ($(PROJECT_RENAME_TARGET),yes)
    $(eval dummyfile:=localtopchecking.file.$(shell date +%s.%N 2>/dev/null))
    $(eval xxtmp:=$(shell $(CMD_touch) $(SCRAM_INIT_LOCALTOP)/$(dummyfile) 2> /dev/null))
    ifeq ($(strip $(wildcard $(curtop)/$(dummyfile))),)
      $(eval xxtmp:=$(shell $(CMD_rm) -f $(SCRAM_INIT_LOCALTOP)/$(dummyfile)))
      $(info **** ERROR: You have moved/renamed this project area "$(curtop)" from "$(SCRAM_INIT_LOCALTOP)")
      $(error Please first run \"scramv1 b ProjectRename\")
    endif
    $(eval xxtmp:=$(shell $(CMD_rm) -f $(SCRAM_INIT_LOCALTOP)/$(dummyfile)))
  endif
endif

.PHONY: projectrename ProjectRename PROJECTRENAME
ProjectRename projectrename PROJECTRENAME:
	@if [ -f ./$(SCRAM_CONFIGDIR)/SCRAM/projectAreaRename.pl ] ; then \
	  ./$(SCRAM_CONFIGDIR)/SCRAM/projectAreaRename.pl $(SCRAM_INIT_LOCALTOP) $(curtop) $(SCRAM_ARCH); \
	  $(CMD_echo) "Done: $@"; \
	fi
######################################################################
#Common Rules
.PHONY: all project project_all all_$(SCRAM_SOURCEDIR) ProjectPluginRefresh CompilePython PostBuild
all: all_$(TARGETDIR)
	@if [ "X$(TARGETDIR)" != "X$(SCRAM_SOURCEDIR)" ] ; then \
	  $(DO_BUILD_LOG) $(MAKE) -f $(SCRAM_MAKEFILE) ufast outputlog ;\
	  $(MAKE) -f $(SCRAM_MAKEFILE) PostBuild ;\
	fi
project project_all all_$(SCRAM_SOURCEDIR): $(SCRAM_SOURCEDIR)
	@:

.PHONY: python help compile precompile runtests clean distclean cache_clean project_clean project_help 
.PHONY: clean_$(SCRAM_SOURCEDIR) help_$(SCRAM_SOURCEDIR)
help: help_$(TARGETDIR)
clean: clean_$(TARGETDIR)
runtests: runtests_$(TARGETDIR)
python: runpython_$(TARGETDIR)
compile: compile_$(TARGETDIR)
precompile: precompile_$(TARGETDIR)

project_clean clean_$(SCRAM_SOURCEDIR) vclean cache_clean distclean:
	@$(CMD_echo) "Cleaning ProductStore directories:"
	$(CMD_rm) -rf $(ALL_PRODUCT_STORES)
	@$(CMD_echo) "Resetting project cache:"; $(CMD_mkdir) -p .SCRAM/$(SCRAM_ARCH)
	@$(CMD_touch) .SCRAM/$(SCRAM_ARCH)/ProjectCache.db.gz
	$(CMD_rm) -f .SCRAM/$(SCRAM_ARCH)/ProjectCache.db*
	@$(CMD_touch) .SCRAM/$(SCRAM_ARCH)/DirCache.db.gz
	$(CMD_rm) -f .SCRAM/$(SCRAM_ARCH)/DirCache.db*
	@$(CMD_touch) .SCRAM/$(SCRAM_ARCH)/RuntimeCache.db.gz
	$(CMD_rm) -f .SCRAM/$(SCRAM_ARCH)/RuntimeCache.db*
	$(CMD_rm) -rf .SCRAM/$(SCRAM_ARCH)/MakeData
	@if [ "X$(COMPILE_PYTHON_SCRIPTS)" = "Xyes" ] && [ "X$(ALL_PYTHON_DIRS)" != "X" ] ; then \
	  $(CMD_echo) "Cleaning up the compiled .pyc files in the $(SCRAM_SOURCEDIR) directory.";\
	  for d in $(ALL_PYTHON_DIRS) ; do \
	    $(call BuildClean,$(SCRAM_SOURCEDIR)/$$d,,no);\
	  done;\
	fi
	$(CMD_rm) -rf $(SCRAM_INTwork)

project_help help_$(SCRAM_SOURCEDIR):
	@$(CMD_echo) "------------ Help for Project-level Builds ------------"
	@$(CMD_echo) ""
	@$(CMD_echo) "clean:"
	@$(CMD_echo) "     Clean the local working directory only."
	@$(CMD_echo) ""
	@$(CMD_echo) "python:"
	@$(CMD_echo) "     To just build python i.e. creating sym-links and compiling python modules."
	@$(CMD_echo) ""
	@$(CMD_echo) "prebuild:"
	@$(CMD_echo) "     Execute pre-build target for the project."
	@$(CMD_echo) ""
	@$(CMD_echo) "postbuild:"
	@$(CMD_echo) "     Execute the post-build target for the project."
	@$(CMD_echo) ""
	@$(CMD_echo) "release-test:"
	@$(CMD_echo) "     Run the integration test suite"
	@$(CMD_echo) ""
	@$(CMD_echo) "runtests:"
	@$(CMD_echo) "     Build and run all tests for the project, or package-level tests only."
	@$(CMD_echo) "     (Depends on the location where \"scram b runtests\" is run)."
	@$(CMD_echo) ""

.PHONY: release release-build release-reset release-check release-test release-doc release-docs release-freeze

release: release-reset release-build postbuild

release-build: project_all

release-reset: distclean

release-check: release-test

release-test: integration-test

release-docs release-doc: doc

release-freeze: release-check
	@$(CMD_echo) "Cleaning up and protecting directories:"
	@cd $(LOCALTOP); \
	$(CMD_rm) -fr $(SCRAM_INTwork)/$(SCRAM_SOURCEDIR) ; \
	$(CMD_rm) -fr $(SCRAM_INTwork)/cache ; \
	$(CMD_find) . -type f -print | $(CMD_xargs) $(CMD_chmod) a-w; \
	$(CMD_find) . -type d -print | $(CMD_xargs) $(CMD_chmod) 555

###############################################################################
ifdef SCRAM_NOLOADCHECK
SHARED_LIB_LOAD_CHECK :=
endif
PLUGIN_REFRESH_CMDS :=
###############################################################################
-include $(TOOLS_MKDIR).mk
-include $(TOOLS_MKDIR)/SCRAMBased/self_libs_def.mk
-include $(PUB_DIRCACHE_MKDIR)/src.mk
-include $(PUB_DIRCACHE_MKDIR)/DirCache.mk
-include $(DIRCACHE_MKDIR)/ExtraBuilsRules/*.mk
-include $(DIRCACHE_MKDIR)/DirCache.mk
-include $(TOOLS_MKDIR)/SCRAMBased/all.mk
-include $(DIRCACHE_MKDIR)/RmvDirCache.mk
ifneq ($(strip $(RELEASETOP)),)
POISON_INCLUDE_DIR := $(wildcard $(LOCALTOP)/poison)
self_LOC_INCLUDE := $(subst $(RELEASETOP)/$(SCRAM_SOURCEDIR),$(POISON_INCLUDE_DIR) $(RELEASETOP)/$(SCRAM_SOURCEDIR),$(self_LOC_INCLUDE))
self_EX_INCLUDE :=  $(self_LOC_INCLUDE)
endif
####### Clean up the directories which were already build but now have been removed from src area ######
ifneq ($(strip $(REMOVED_DIRS)),)
$(shell $(CMD_echo) "" > $(WORKINGDIR)/.AUTOCLEAN)
$(foreach d,$(sort $(REMOVED_DIRS)),$(if $(wildcard $(WORKINGDIR)/$(d)),$(eval xx:=$(shell $(CMD_find) $(WORKINGDIR)/$(d) -name "AUTOCLEAN.*.clean" -type f | $(CMD_xargs) $(CMD_cat) | $(CMD_grep) "^0[0-9]:" | $(CMD_sed) "s|^0[0-9]:||" |$(CMD_sort) | $(CMD_uniq) >> $(WORKINGDIR)/.AUTOCLEAN)$(info Cleaning up removed directory:$(d))$(shell $(CMD_rm) -rf $(WORKINGDIR)/$(d))),))
$(foreach d,$(REMOVED_DIRS),$(if $(wildcard $(WORKINGDIR)/cache/bf/$(d)/$(SCRAM_BUILDFILE)),$(shell $(CMD_touch) $(SCRAM_INTwork)/cache/bf/$(d)/$(SCRAM_BUILDFILE)),))
$(shell $(CMD_sh) $(WORKINGDIR)/.AUTOCLEAN; $(CMD_rm) -rf $(DIRCACHE_MKDIR)/RmvDirCache.mk $(DIRCACHE_MKDIR)/RmvDirCache; $(CMD_mkdir) -p $(DIRCACHE_MKDIR)/RmvDirCache; $(CMD_touch) $(DIRCACHE_MKDIR)/RmvDirCache.mk)
endif
####### Update Tools and Prods rules ##############
ifeq ($(strip $(UFAST)),)
$(foreach x,$(ALL_TOOLS),$(eval $($(x)_INIT_FUNC)))
$(foreach x,$(ALL_TOOLS),$(foreach err,$($(x)_USE_ERR),$(eval $(call UseError,$(err),$(x)))))
ifeq ($(strip $(XFAST)),)
$(foreach x,$(ALL_EXTERNAL_PRODS),$(eval $(call ProductCommonVarsExternal,$(x)))$(eval $($(x)_INIT_FUNC)))
$(foreach x,$(ALL_PRODS),$(eval $(call ProductCommonVars,$(x),,,$($(x)_BuildFile))))
ifeq ($(strip $(FAST)),)
$(info >> Local Products Rules ..... started)
$(foreach x,$(ALL_PRODS),$(eval $($(x)_INIT_FUNC)))
$(info >> Local Products Rules ..... done)
endif
$(foreach bf,$(ALL_BUILDFILES),$(foreach err,$(sort $($(bf)_USE_ERR)),$(eval $(call UseError,$(err),$(bf)))))
$(foreach x,$(ALL_COMMONRULES),$(eval $($(x)_INIT_FUNC)))
endif
####### Update Subsystems and Packages rules ##############
$(foreach dir,$(ALL_SUBSYSTEMS),$(eval $(call SubSystem,$(dir),src_$(subst /,_,$(dir)))))
$(foreach dir,$(ALL_PACKAGES),$(eval $(call Package,$(dir),src_$(subst /,_,$(dir)))))
endif
###########################################################
PHONY: $(SCRAM_SOURCEDIR) prebuild postbuild runtests_$(SCRAM_SOURCEDIR) runpython_$(SCRAM_SOURCEDIR) compile_$(SCRAM_SOURCEDIR) precompile_$(SCRAM_SOURCEDIR)
$(SCRAM_SOURCEDIR): prebuild $($(SCRAM_SOURCEDIR)) $(subdirs_$(SCRAM_SOURCEDIR))
	@$(DO_BUILD_LOG) $(MAKE) -f $(SCRAM_MAKEFILE) ufast outputlog
	@$(MAKE) -f $(SCRAM_MAKEFILE) PostBuild
prebuild: $(prebuild)
	@$(CMD_echo) ">> Building $(SCRAM_PROJECTNAME) version $(SCRAM_PROJECTVERSION) ----"; \
	[ -d $(LOCALTOP)/logs/$(SCRAM_ARCH) ] || $(CMD_mkdir) -p $(LOCALTOP)/logs/$(SCRAM_ARCH)
postbuild: $(postbuild) release-check
	@$(CMD_echo) "Release $(SCRAM_PROJECTNAME) version $(SCRAM_PROJECTVERSION) build finished at `date`"
runpython_$(SCRAM_SOURCEDIR): $(addprefix runpython_, $(subdirs_$(SCRAM_SOURCEDIR)))
	@$(CMD_echo) ">> Python completed for $(SCRAM_PROJECTNAME) $(SCRAM_PROJECTVERSION)"
runtests_$(SCRAM_SOURCEDIR): $(addprefix runtests_, $(subdirs_$(SCRAM_SOURCEDIR)))
	@$(CMD_echo) ">> Test sequence completed for $(SCRAM_PROJECTNAME) $(SCRAM_PROJECTVERSION)"
compile_$(SCRAM_SOURCEDIR): $(addprefix compile_, $(subdirs_$(SCRAM_SOURCEDIR)))
	@$(CMD_echo) ">> Compile sequence completed for $(SCRAM_PROJECTNAME) $(SCRAM_PROJECTVERSION)"
precompile_$(SCRAM_SOURCEDIR): $(addprefix precompile_, $(subdirs_$(SCRAM_SOURCEDIR)))
	@$(CMD_echo) ">> Pre-compile sequence completed for $(SCRAM_PROJECTNAME) $(SCRAM_PROJECTVERSION)"
###########################################################
define GetMissingSymbolFlags
  $(if $($(1)_libcheck),$(if $2,$(info @@@@ Checking for missing symbols was SKIPPED due to NO_LIB_CHECKING flag in BuildFile: $(@F)),),$(MISSING_SYMBOL_FLAGS))
endef
ifndef SCRAM_NOSYMCHECK
ifeq ($(strip $(MISSING_SYMBOL_FLAGS)),)
define check_missing_symbols
  if [ "X$(1)" = X ] ; then \
    $(CMD_echo) "@@@@ Checking shared library for missing symbols: $(@F)" &&\
    $(CMD_echo) "int main(){}" > $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp  &&\
    $(VERB_ECHO) $(CXX) $(CXXFLAGS) $(CXXSHAREDOBJECTFLAGS) $(LDFLAGS) -o $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).out $@ $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp &&\
    ($(CXX) $(CXXFLAGS) $(CXXSHAREDOBJECTFLAGS) $(LDFLAGS) -o $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).out $@ $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp || ($(CMD_rm) -f $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).out && $(call delete_plugin_build_prod,$(2),$(3)) && exit 1)) &&\
    $(CMD_rm) -f $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).cpp $(LOCALTOP)/$(SCRAM_INTwork)/$(@F).out	&&\
    $(CMD_echo) "@@@@ ----> OK, shared library FULLY-BOUND (no missing symbols): $(@F)" ; \
  else \
    $(CMD_echo) "@@@@ Checking for missing symbols was SKIPPED due to NO_LIB_CHECKING flag in BuildFile: $(@F)"; \
  fi
endef
else
check_missing_symbols:=true
endif
else
define check_missing_symbols
  $(CMD_echo) "@@@@ Checking for missing symbols was SKIPPED due to SCRAM_NOSYMCHECK: $(@F)"
endef
endif
###############################################################################
ifneq ($(strip $(EDM_CHECK_CLASS_VERSION)),)
EDM_CHECK_CLASS_VERSION_SCRIPT:=$(if $(strip $(wildcard $(LOCALTOP)/$(EDM_CHECK_CLASS_VERSION))),$(LOCALTOP)/$(EDM_CHECK_CLASS_VERSION),)
ifeq ($(strip $(EDM_CHECK_CLASS_VERSION_SCRIPT)),)
ifneq ($(strip $(RELEASETOP)),)
EDM_CHECK_CLASS_VERSION_SCRIPT:=$(if $(strip $(wildcard $(RELEASETOP)/$(EDM_CHECK_CLASS_VERSION))),$(RELEASETOP)/$(EDM_CHECK_CLASS_VERSION),)
endif
endif
ifeq ($(strip $(EDM_CHECK_CLASS_VERSION_SCRIPT)),)
EDM_CHECK_CLASS_VERSION_SCRIPT:=echo ">> Skipped running EDM Class Version test" && true
endif
endif

#product,list of def.xmls file,plugin,productstore
ifneq ($(strip $(EDM_CHECK_CLASS_VERSION)),)
ifneq ($(strip $(UPDATE_CLASSVERSION)),)
define update_edm_class_version
  for x in $2; do \
    fname=`basename $$x` &&\
    $(CMD_echo) ">> Generating EDM Class Version for $$x in $(@F)" &&\
    $(VERB_ECHO)  $(EDM_CHECK_CLASS_VERSION_SCRIPT) -g -l $(@F) -x $$x &&\
    ((cd $(@D) && $(EDM_CHECK_CLASS_VERSION_SCRIPT) -g -l $(@F) -x $$x) || (true)) &&\
    if [ -f $(@D)/classes_def.xml.generated ] ; then \
      if [ "X`diff $(@D)/classes_def.xml.generated $$x | wc -l`" != "X0" ] ; then \
        $(CMD_cp) $(@D)/classes_def.xml.generated $$x.generated &&\
        $(CMD_echo) ">> New Class Version File:  $$x.generated" ;\
      fi &&\
      $(CMD_rm) -f $(@D)/classes_def.xml.generated ;\
    fi ;\
  done &&\
  $(CMD_echo) "@@@@ ----> Generated EDM Class Version" &&
endef
else
define update_edm_class_version
endef
endif
define check_edm_class_version
  $(call update_edm_class_version,$1,$2,$3,$4) \
  for x in $2; do \
    $(CMD_echo) ">> Checking EDM Class Version for $$x in $(@F)" &&\
    $(VERB_ECHO) $(OS_LDLIB_PATH)=$$LOCALTOP/$(@D):$$$(OS_LDLIB_PATH) $(EDM_CHECK_CLASS_VERSION_SCRIPT) -l $(@F) -x $$x &&\
    (($(OS_LDLIB_PATH)=$$LOCALTOP/$(@D):$$$(OS_LDLIB_PATH) $(EDM_CHECK_CLASS_VERSION_SCRIPT) -l $(@F) -x $$x) || ($(call delete_plugin_build_prod,$(3),$(4)) && exit 1)) ;\
  done &&\
  $(CMD_echo) "@@@@ ----> OK  EDM Class Version "
endef
else
define check_edm_class_version
true
endef
define update_edm_class_version
true
endef
endif
###########################################################

.PHONY: all_% clean_% help_% runtests_% runpython_% compile_% precompile_% ufast xfast fast %_USED_BY %_USES echo_% outputlog
.PHONY: help_%_python help_%_src help_%_plugins help_%_bin help_%_test help_$(SCRAM_SOURCEDIR)_%
.PHONY: skiptest_%
help_%_python:
	@$(CMD_echo) "Running \"scram build\" here will run rules for pythin i.e. creates sym-links and compiles python modules"
help_%_src:
	@$(CMD_echo) "Running \"scram build\" here normally build a shared library."
help_%_plugins:
	@$(CMD_echo) "Running \"scram build\" here normally build EDM-plugins."
help_%_bin:
	@$(CMD_echo) "Running \"scram build\" here normally build public executables and shared libs (if any)."
help_%_test:
	@$(CMD_echo) "Running \"scram build\" here normally build test executables and shared libs (if any)."
help_$(SCRAM_SOURCEDIR)_%:
	@$(CMD_echo) "Doing \"scram build\" here will build every thing exist under this directory."
all_% runtests_% help_% runpython_% compile_% precompile_%:
	@if [ "X$(TARGETDIR)" = "X$*" ] ; then \
	  $(CMD_echo) ">> Nothing to be done for $(THISDIR)";\
	fi
clean_%:
	@if [ "X$($*_objdir)" != "X" ] ; then \
	  dir=`$(CMD_echo) $($*_objdir) | $(CMD_grep) '^$(WORKINGDIR)/' | $(CMD_sed) 's|^$(WORKINGDIR)/||'`;\
	  if [ "X$$dir" != "X" ] ; then \
	    if [ -d $(WORKINGDIR)/$$dir ] ; then \
	      $(CMD_echo) "Cleaning up $$dir"; $(call BuildClean,$$dir) ; exit 0;\
	    fi;\
	  fi;\
	elif [ "$(TARGETDIR)" == "$*" ] ; then \
	  $(CMD_echo) "Cleaning up $(THISDIR)"; $(call BuildClean,$(THISDIR));\
	else \
	  $(CMD_echo) "***WARNING: Unknown product $*. Failed to cleanup.";\
	fi
ufast xfast fast:
	@:
%_USED_BY:
	@var=$(call GetEchoVariable,$@);\
	if [ "X$$var" != "X" ] ; then \
	  $(SCRAM_CONFIGDIR)/SCRAM/projectInfo.pl $(LOCALTOP) USED_BY $(patsubst %_USED_BY,%,$(call GetEchoVariable,$@)) $(SCRAM_ARCH);\
	fi
%_USES:
	@var=$(call GetEchoVariable,$@);\
	if [ "X$$var" != "X" ] ; then \
	  $(SCRAM_CONFIGDIR)/SCRAM/projectInfo.pl $(LOCALTOP) USES $(patsubst %_USES,%,$(call GetEchoVariable,$@)) $(SCRAM_ARCH);\
	fi
%_ORIGIN:
	@var=$(call GetEchoVariable,$@);\
	if [ "X$$var" != "X" ] ; then \
	  $(SCRAM_CONFIGDIR)/SCRAM/projectInfo.pl $(LOCALTOP) ORIGIN $(patsubst %_ORIGIN,%,$(call GetEchoVariable,$@)) $(SCRAM_ARCH);\
	fi
echo_%:
	@$(CMD_echo) "$* = $(subst ",\",$($*))"

$(COMMON_WORKINGDIR)/cache/python_symlinks: $(COMMON_WORKINGDIR)/cache/project_links FORCE_TARGET
	@[ -d python ] || $(CMD_mkdir) python; \
	$(SCRAM_CONFIGDIR)/SCRAM/createPyInitFiles.pl ;\
	$(CMD_touch) python/__init__.py
	@for d in `$(CMD_find) python -name "*" -type l | $(CMD_sed) s'|^python/||'`; do \
	  for dir in `$(CMD_find) src/$$d/python -name "*" -type d | $(CMD_grep) -v '/CVS$$\|/CVS/'`; do \
	    if [ ! -f $$dir/__init__.py ] ; then \
	      $(CMD_echo) "#Automatically created by SCRAM" > $$dir/__init__.py;\
              if [ "$$dir" == "src/$$d/python" ] ; then \
                if [ "X$(SCRAM_NOEDMWRITECONFIG)" = "X" ] ; then \
                  $(CMD_echo) "import os" >> $$dir/__init__.py;\
                  $(CMD_echo) "__path__.append(os.path.dirname(os.path.abspath(__file__).rsplit('/$$d/',1)[0])+'/cfipython/$(SCRAM_ARCH)/$$d')"  >> $$dir/__init__.py;\
                fi;\
              fi;\
	      [ -d $(WORKINGDIR)/$$dir ] || $(CMD_mkdir) -p $(WORKINGDIR)/$$dir ;\
	      cf=$(call AutoCleanFile,$(WORKINGDIR)/$$dir/__init__.py,python) ;\
	      $(CMD_echo) "01:$(CMD_rm) -f $$dir/__init__.py $$dir/__init__.pyc" > $$cf;\
	    fi;\
	  done;\
	  if [ ! -f python/$$d/__init__.py ] ; then $(CMD_rm) -f python/$$d; fi;\
	done
	@[ -f $@ ] || ($(CMD_mkdir) -p $(@D) ; $(CMD_touch) -t $(OLD_TIMESTAMP) $@)
$(WORKINGDIR)/%/productautocleanup: FORCE_TARGET
	@for dir in $(foreach x,$(patsubst productautocleanup,,$(notdir $(patsubst %/,%,$(dir $(wildcard $(@D)/*/AUTOCLEAN.*.clean))))),$(if $(findstring all_$x,$($(subst /,_,$*))),,$x)) ; do \
	  $(call BuildClean,$*/$$dir,0[0-9]);\
	done
	@[ -d $(@D) ] || $(CMD_mkdir) -p $(@D) &&\
	$(CMD_touch) -t $(OLD_TIMESTAMP) $@
bigobj: $(ALL_BIGOBJS)
	@:
outputlog:
	$(eval DO_BUILD_LOG:=)
	@$(call outputlog,,,)
runtime:
	@$(CMD_echo) ">> Runtime environment:"; env
skiptest_%:
	@:
updateclassversion: $(filter $(WORKINGDIR)/$(THISDIR)/%,$(ALL_CLASS_VERSION_RULES))
	@:
PostBuild: CompilePython ProjectPluginRefresh
	@:
CompilePython: $(WORKINGDIR)/cache/CompilePython
	@:
$(WORKINGDIR)/cache/CompilePython: FORCE_TARGET $(filter $(WORKINGDIR)/$(THISDIR)/%/cmssw_python_modules,$(ALL_PYTHON_COMPILE))
	@$(CMD_echo) ">> All python modules compiled"
	@$(CMD_touch) $@
ProjectPluginRefresh: FORCE_TARGET $(foreach file,$(addsuffix _cache,$(PLUGIN_REFRESH_CMDS)),$($(file)))
	@$(CMD_echo) ">> Pluging of all type refreshed."
%:
	@$(CMD_echo) TARGET:$@
	@var=$(call GetEchoVariable,$@);\
	if [ "X$$var" != "X" ] ; then \
	  $(CMD_echo) "$$var = $(subst ",\",$($(patsubst echo_%,%,$@)))";\
	fi
